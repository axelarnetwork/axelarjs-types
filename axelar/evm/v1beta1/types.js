"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.31.1
// source: axelar/evm/v1beta1/types.proto
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PollMetadata = exports.Gateway = exports.TokenDetails = exports.Asset = exports.TransferKey = exports.SigMetadata = exports.CommandBatchMetadata = exports.Command = exports.TransactionMetadata = exports.ERC20TokenMetadata = exports.ERC20Deposit = exports.BurnerInfo = exports.NetworkInfo = exports.EventMultisigOperatorshipTransferred = exports.EventMultisigOwnershipTransferred = exports.EventTokenDeployed = exports.EventTransfer = exports.EventContractCallWithToken = exports.EventContractCall = exports.EventTokenSent = exports.Event = exports.VoteEvents = exports.event_StatusToJSON = exports.event_StatusFromJSON = exports.Event_Status = exports.depositStatusToJSON = exports.depositStatusFromJSON = exports.DepositStatus = exports.transferKeyTypeToJSON = exports.transferKeyTypeFromJSON = exports.TransferKeyType = exports.sigTypeToJSON = exports.sigTypeFromJSON = exports.SigType = exports.batchedCommandsStatusToJSON = exports.batchedCommandsStatusFromJSON = exports.BatchedCommandsStatus = exports.commandTypeToJSON = exports.commandTypeFromJSON = exports.CommandType = exports.statusToJSON = exports.statusFromJSON = exports.Status = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const any_1 = require("../../../google/protobuf/any");
const typeRegistry_1 = require("../../../typeRegistry");
exports.protobufPackage = "axelar.evm.v1beta1";
var Status;
(function (Status) {
    /**
     * STATUS_UNSPECIFIED - these enum values are used for bitwise operations, therefore they need to
     * be powers of 2
     */
    Status[Status["STATUS_UNSPECIFIED"] = 0] = "STATUS_UNSPECIFIED";
    Status[Status["STATUS_INITIALIZED"] = 1] = "STATUS_INITIALIZED";
    Status[Status["STATUS_PENDING"] = 2] = "STATUS_PENDING";
    Status[Status["STATUS_CONFIRMED"] = 4] = "STATUS_CONFIRMED";
    Status[Status["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Status = exports.Status || (exports.Status = {}));
function statusFromJSON(object) {
    switch (object) {
        case 0:
        case "STATUS_UNSPECIFIED":
            return Status.STATUS_UNSPECIFIED;
        case 1:
        case "STATUS_INITIALIZED":
            return Status.STATUS_INITIALIZED;
        case 2:
        case "STATUS_PENDING":
            return Status.STATUS_PENDING;
        case 4:
        case "STATUS_CONFIRMED":
            return Status.STATUS_CONFIRMED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Status.UNRECOGNIZED;
    }
}
exports.statusFromJSON = statusFromJSON;
function statusToJSON(object) {
    switch (object) {
        case Status.STATUS_UNSPECIFIED:
            return "STATUS_UNSPECIFIED";
        case Status.STATUS_INITIALIZED:
            return "STATUS_INITIALIZED";
        case Status.STATUS_PENDING:
            return "STATUS_PENDING";
        case Status.STATUS_CONFIRMED:
            return "STATUS_CONFIRMED";
        case Status.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.statusToJSON = statusToJSON;
var CommandType;
(function (CommandType) {
    CommandType[CommandType["COMMAND_TYPE_UNSPECIFIED"] = 0] = "COMMAND_TYPE_UNSPECIFIED";
    CommandType[CommandType["COMMAND_TYPE_MINT_TOKEN"] = 1] = "COMMAND_TYPE_MINT_TOKEN";
    CommandType[CommandType["COMMAND_TYPE_DEPLOY_TOKEN"] = 2] = "COMMAND_TYPE_DEPLOY_TOKEN";
    CommandType[CommandType["COMMAND_TYPE_BURN_TOKEN"] = 3] = "COMMAND_TYPE_BURN_TOKEN";
    CommandType[CommandType["COMMAND_TYPE_TRANSFER_OPERATORSHIP"] = 4] = "COMMAND_TYPE_TRANSFER_OPERATORSHIP";
    CommandType[CommandType["COMMAND_TYPE_APPROVE_CONTRACT_CALL_WITH_MINT"] = 5] = "COMMAND_TYPE_APPROVE_CONTRACT_CALL_WITH_MINT";
    CommandType[CommandType["COMMAND_TYPE_APPROVE_CONTRACT_CALL"] = 6] = "COMMAND_TYPE_APPROVE_CONTRACT_CALL";
    CommandType[CommandType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CommandType = exports.CommandType || (exports.CommandType = {}));
function commandTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "COMMAND_TYPE_UNSPECIFIED":
            return CommandType.COMMAND_TYPE_UNSPECIFIED;
        case 1:
        case "COMMAND_TYPE_MINT_TOKEN":
            return CommandType.COMMAND_TYPE_MINT_TOKEN;
        case 2:
        case "COMMAND_TYPE_DEPLOY_TOKEN":
            return CommandType.COMMAND_TYPE_DEPLOY_TOKEN;
        case 3:
        case "COMMAND_TYPE_BURN_TOKEN":
            return CommandType.COMMAND_TYPE_BURN_TOKEN;
        case 4:
        case "COMMAND_TYPE_TRANSFER_OPERATORSHIP":
            return CommandType.COMMAND_TYPE_TRANSFER_OPERATORSHIP;
        case 5:
        case "COMMAND_TYPE_APPROVE_CONTRACT_CALL_WITH_MINT":
            return CommandType.COMMAND_TYPE_APPROVE_CONTRACT_CALL_WITH_MINT;
        case 6:
        case "COMMAND_TYPE_APPROVE_CONTRACT_CALL":
            return CommandType.COMMAND_TYPE_APPROVE_CONTRACT_CALL;
        case -1:
        case "UNRECOGNIZED":
        default:
            return CommandType.UNRECOGNIZED;
    }
}
exports.commandTypeFromJSON = commandTypeFromJSON;
function commandTypeToJSON(object) {
    switch (object) {
        case CommandType.COMMAND_TYPE_UNSPECIFIED:
            return "COMMAND_TYPE_UNSPECIFIED";
        case CommandType.COMMAND_TYPE_MINT_TOKEN:
            return "COMMAND_TYPE_MINT_TOKEN";
        case CommandType.COMMAND_TYPE_DEPLOY_TOKEN:
            return "COMMAND_TYPE_DEPLOY_TOKEN";
        case CommandType.COMMAND_TYPE_BURN_TOKEN:
            return "COMMAND_TYPE_BURN_TOKEN";
        case CommandType.COMMAND_TYPE_TRANSFER_OPERATORSHIP:
            return "COMMAND_TYPE_TRANSFER_OPERATORSHIP";
        case CommandType.COMMAND_TYPE_APPROVE_CONTRACT_CALL_WITH_MINT:
            return "COMMAND_TYPE_APPROVE_CONTRACT_CALL_WITH_MINT";
        case CommandType.COMMAND_TYPE_APPROVE_CONTRACT_CALL:
            return "COMMAND_TYPE_APPROVE_CONTRACT_CALL";
        case CommandType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.commandTypeToJSON = commandTypeToJSON;
var BatchedCommandsStatus;
(function (BatchedCommandsStatus) {
    BatchedCommandsStatus[BatchedCommandsStatus["BATCHED_COMMANDS_STATUS_UNSPECIFIED"] = 0] = "BATCHED_COMMANDS_STATUS_UNSPECIFIED";
    BatchedCommandsStatus[BatchedCommandsStatus["BATCHED_COMMANDS_STATUS_SIGNING"] = 1] = "BATCHED_COMMANDS_STATUS_SIGNING";
    BatchedCommandsStatus[BatchedCommandsStatus["BATCHED_COMMANDS_STATUS_ABORTED"] = 2] = "BATCHED_COMMANDS_STATUS_ABORTED";
    BatchedCommandsStatus[BatchedCommandsStatus["BATCHED_COMMANDS_STATUS_SIGNED"] = 3] = "BATCHED_COMMANDS_STATUS_SIGNED";
    BatchedCommandsStatus[BatchedCommandsStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BatchedCommandsStatus = exports.BatchedCommandsStatus || (exports.BatchedCommandsStatus = {}));
function batchedCommandsStatusFromJSON(object) {
    switch (object) {
        case 0:
        case "BATCHED_COMMANDS_STATUS_UNSPECIFIED":
            return BatchedCommandsStatus.BATCHED_COMMANDS_STATUS_UNSPECIFIED;
        case 1:
        case "BATCHED_COMMANDS_STATUS_SIGNING":
            return BatchedCommandsStatus.BATCHED_COMMANDS_STATUS_SIGNING;
        case 2:
        case "BATCHED_COMMANDS_STATUS_ABORTED":
            return BatchedCommandsStatus.BATCHED_COMMANDS_STATUS_ABORTED;
        case 3:
        case "BATCHED_COMMANDS_STATUS_SIGNED":
            return BatchedCommandsStatus.BATCHED_COMMANDS_STATUS_SIGNED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return BatchedCommandsStatus.UNRECOGNIZED;
    }
}
exports.batchedCommandsStatusFromJSON = batchedCommandsStatusFromJSON;
function batchedCommandsStatusToJSON(object) {
    switch (object) {
        case BatchedCommandsStatus.BATCHED_COMMANDS_STATUS_UNSPECIFIED:
            return "BATCHED_COMMANDS_STATUS_UNSPECIFIED";
        case BatchedCommandsStatus.BATCHED_COMMANDS_STATUS_SIGNING:
            return "BATCHED_COMMANDS_STATUS_SIGNING";
        case BatchedCommandsStatus.BATCHED_COMMANDS_STATUS_ABORTED:
            return "BATCHED_COMMANDS_STATUS_ABORTED";
        case BatchedCommandsStatus.BATCHED_COMMANDS_STATUS_SIGNED:
            return "BATCHED_COMMANDS_STATUS_SIGNED";
        case BatchedCommandsStatus.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.batchedCommandsStatusToJSON = batchedCommandsStatusToJSON;
var SigType;
(function (SigType) {
    SigType[SigType["SIG_TYPE_UNSPECIFIED"] = 0] = "SIG_TYPE_UNSPECIFIED";
    SigType[SigType["SIG_TYPE_TX"] = 1] = "SIG_TYPE_TX";
    SigType[SigType["SIG_TYPE_COMMAND"] = 2] = "SIG_TYPE_COMMAND";
    SigType[SigType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SigType = exports.SigType || (exports.SigType = {}));
function sigTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "SIG_TYPE_UNSPECIFIED":
            return SigType.SIG_TYPE_UNSPECIFIED;
        case 1:
        case "SIG_TYPE_TX":
            return SigType.SIG_TYPE_TX;
        case 2:
        case "SIG_TYPE_COMMAND":
            return SigType.SIG_TYPE_COMMAND;
        case -1:
        case "UNRECOGNIZED":
        default:
            return SigType.UNRECOGNIZED;
    }
}
exports.sigTypeFromJSON = sigTypeFromJSON;
function sigTypeToJSON(object) {
    switch (object) {
        case SigType.SIG_TYPE_UNSPECIFIED:
            return "SIG_TYPE_UNSPECIFIED";
        case SigType.SIG_TYPE_TX:
            return "SIG_TYPE_TX";
        case SigType.SIG_TYPE_COMMAND:
            return "SIG_TYPE_COMMAND";
        case SigType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.sigTypeToJSON = sigTypeToJSON;
/**
 * DEPRECATED: Removed in v0.20, reinstated in v1.3 for backward compatibility.
 * This enum must remain to allow decoding of historical transactions.
 * DO NOT use in new code.
 *
 * @deprecated
 */
var TransferKeyType;
(function (TransferKeyType) {
    TransferKeyType[TransferKeyType["TRANSFER_KEY_TYPE_UNSPECIFIED"] = 0] = "TRANSFER_KEY_TYPE_UNSPECIFIED";
    TransferKeyType[TransferKeyType["TRANSFER_KEY_TYPE_OWNERSHIP"] = 1] = "TRANSFER_KEY_TYPE_OWNERSHIP";
    TransferKeyType[TransferKeyType["TRANSFER_KEY_TYPE_OPERATORSHIP"] = 2] = "TRANSFER_KEY_TYPE_OPERATORSHIP";
    TransferKeyType[TransferKeyType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(TransferKeyType = exports.TransferKeyType || (exports.TransferKeyType = {}));
function transferKeyTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "TRANSFER_KEY_TYPE_UNSPECIFIED":
            return TransferKeyType.TRANSFER_KEY_TYPE_UNSPECIFIED;
        case 1:
        case "TRANSFER_KEY_TYPE_OWNERSHIP":
            return TransferKeyType.TRANSFER_KEY_TYPE_OWNERSHIP;
        case 2:
        case "TRANSFER_KEY_TYPE_OPERATORSHIP":
            return TransferKeyType.TRANSFER_KEY_TYPE_OPERATORSHIP;
        case -1:
        case "UNRECOGNIZED":
        default:
            return TransferKeyType.UNRECOGNIZED;
    }
}
exports.transferKeyTypeFromJSON = transferKeyTypeFromJSON;
function transferKeyTypeToJSON(object) {
    switch (object) {
        case TransferKeyType.TRANSFER_KEY_TYPE_UNSPECIFIED:
            return "TRANSFER_KEY_TYPE_UNSPECIFIED";
        case TransferKeyType.TRANSFER_KEY_TYPE_OWNERSHIP:
            return "TRANSFER_KEY_TYPE_OWNERSHIP";
        case TransferKeyType.TRANSFER_KEY_TYPE_OPERATORSHIP:
            return "TRANSFER_KEY_TYPE_OPERATORSHIP";
        case TransferKeyType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.transferKeyTypeToJSON = transferKeyTypeToJSON;
var DepositStatus;
(function (DepositStatus) {
    DepositStatus[DepositStatus["DEPOSIT_STATUS_UNSPECIFIED"] = 0] = "DEPOSIT_STATUS_UNSPECIFIED";
    DepositStatus[DepositStatus["DEPOSIT_STATUS_PENDING"] = 1] = "DEPOSIT_STATUS_PENDING";
    DepositStatus[DepositStatus["DEPOSIT_STATUS_CONFIRMED"] = 2] = "DEPOSIT_STATUS_CONFIRMED";
    DepositStatus[DepositStatus["DEPOSIT_STATUS_BURNED"] = 3] = "DEPOSIT_STATUS_BURNED";
    DepositStatus[DepositStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DepositStatus = exports.DepositStatus || (exports.DepositStatus = {}));
function depositStatusFromJSON(object) {
    switch (object) {
        case 0:
        case "DEPOSIT_STATUS_UNSPECIFIED":
            return DepositStatus.DEPOSIT_STATUS_UNSPECIFIED;
        case 1:
        case "DEPOSIT_STATUS_PENDING":
            return DepositStatus.DEPOSIT_STATUS_PENDING;
        case 2:
        case "DEPOSIT_STATUS_CONFIRMED":
            return DepositStatus.DEPOSIT_STATUS_CONFIRMED;
        case 3:
        case "DEPOSIT_STATUS_BURNED":
            return DepositStatus.DEPOSIT_STATUS_BURNED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return DepositStatus.UNRECOGNIZED;
    }
}
exports.depositStatusFromJSON = depositStatusFromJSON;
function depositStatusToJSON(object) {
    switch (object) {
        case DepositStatus.DEPOSIT_STATUS_UNSPECIFIED:
            return "DEPOSIT_STATUS_UNSPECIFIED";
        case DepositStatus.DEPOSIT_STATUS_PENDING:
            return "DEPOSIT_STATUS_PENDING";
        case DepositStatus.DEPOSIT_STATUS_CONFIRMED:
            return "DEPOSIT_STATUS_CONFIRMED";
        case DepositStatus.DEPOSIT_STATUS_BURNED:
            return "DEPOSIT_STATUS_BURNED";
        case DepositStatus.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.depositStatusToJSON = depositStatusToJSON;
var Event_Status;
(function (Event_Status) {
    Event_Status[Event_Status["STATUS_UNSPECIFIED"] = 0] = "STATUS_UNSPECIFIED";
    Event_Status[Event_Status["STATUS_CONFIRMED"] = 1] = "STATUS_CONFIRMED";
    Event_Status[Event_Status["STATUS_COMPLETED"] = 2] = "STATUS_COMPLETED";
    Event_Status[Event_Status["STATUS_FAILED"] = 3] = "STATUS_FAILED";
    Event_Status[Event_Status["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Event_Status = exports.Event_Status || (exports.Event_Status = {}));
function event_StatusFromJSON(object) {
    switch (object) {
        case 0:
        case "STATUS_UNSPECIFIED":
            return Event_Status.STATUS_UNSPECIFIED;
        case 1:
        case "STATUS_CONFIRMED":
            return Event_Status.STATUS_CONFIRMED;
        case 2:
        case "STATUS_COMPLETED":
            return Event_Status.STATUS_COMPLETED;
        case 3:
        case "STATUS_FAILED":
            return Event_Status.STATUS_FAILED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Event_Status.UNRECOGNIZED;
    }
}
exports.event_StatusFromJSON = event_StatusFromJSON;
function event_StatusToJSON(object) {
    switch (object) {
        case Event_Status.STATUS_UNSPECIFIED:
            return "STATUS_UNSPECIFIED";
        case Event_Status.STATUS_CONFIRMED:
            return "STATUS_CONFIRMED";
        case Event_Status.STATUS_COMPLETED:
            return "STATUS_COMPLETED";
        case Event_Status.STATUS_FAILED:
            return "STATUS_FAILED";
        case Event_Status.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.event_StatusToJSON = event_StatusToJSON;
function createBaseVoteEvents() {
    return { $type: "axelar.evm.v1beta1.VoteEvents", chain: "", events: [] };
}
exports.VoteEvents = {
    $type: "axelar.evm.v1beta1.VoteEvents",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.chain !== "") {
            writer.uint32(10).string(message.chain);
        }
        for (const v of message.events) {
            exports.Event.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVoteEvents();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.chain = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.events.push(exports.Event.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.VoteEvents.$type,
            chain: isSet(object.chain) ? gt.String(object.chain) : "",
            events: gt.Array.isArray(object === null || object === void 0 ? void 0 : object.events) ? object.events.map((e) => exports.Event.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        var _a;
        const obj = {};
        if (message.chain !== "") {
            obj.chain = message.chain;
        }
        if ((_a = message.events) === null || _a === void 0 ? void 0 : _a.length) {
            obj.events = message.events.map((e) => exports.Event.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.VoteEvents.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseVoteEvents();
        message.chain = (_a = object.chain) !== null && _a !== void 0 ? _a : "";
        message.events = ((_b = object.events) === null || _b === void 0 ? void 0 : _b.map((e) => exports.Event.fromPartial(e))) || [];
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.VoteEvents.$type, exports.VoteEvents);
function createBaseEvent() {
    return {
        $type: "axelar.evm.v1beta1.Event",
        chain: "",
        txId: Buffer.alloc(0),
        index: long_1.default.UZERO,
        status: 0,
        tokenSent: undefined,
        contractCall: undefined,
        contractCallWithToken: undefined,
        transfer: undefined,
        tokenDeployed: undefined,
        multisigOwnershipTransferred: undefined,
        multisigOperatorshipTransferred: undefined,
    };
}
exports.Event = {
    $type: "axelar.evm.v1beta1.Event",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.chain !== "") {
            writer.uint32(10).string(message.chain);
        }
        if (message.txId.length !== 0) {
            writer.uint32(18).bytes(message.txId);
        }
        if (!message.index.equals(long_1.default.UZERO)) {
            writer.uint32(24).uint64(message.index);
        }
        if (message.status !== 0) {
            writer.uint32(32).int32(message.status);
        }
        if (message.tokenSent !== undefined) {
            exports.EventTokenSent.encode(message.tokenSent, writer.uint32(42).fork()).ldelim();
        }
        if (message.contractCall !== undefined) {
            exports.EventContractCall.encode(message.contractCall, writer.uint32(50).fork()).ldelim();
        }
        if (message.contractCallWithToken !== undefined) {
            exports.EventContractCallWithToken.encode(message.contractCallWithToken, writer.uint32(58).fork()).ldelim();
        }
        if (message.transfer !== undefined) {
            exports.EventTransfer.encode(message.transfer, writer.uint32(66).fork()).ldelim();
        }
        if (message.tokenDeployed !== undefined) {
            exports.EventTokenDeployed.encode(message.tokenDeployed, writer.uint32(74).fork()).ldelim();
        }
        if (message.multisigOwnershipTransferred !== undefined) {
            exports.EventMultisigOwnershipTransferred.encode(message.multisigOwnershipTransferred, writer.uint32(82).fork()).ldelim();
        }
        if (message.multisigOperatorshipTransferred !== undefined) {
            exports.EventMultisigOperatorshipTransferred.encode(message.multisigOperatorshipTransferred, writer.uint32(90).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEvent();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.chain = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.txId = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.index = reader.uint64();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.status = reader.int32();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.tokenSent = exports.EventTokenSent.decode(reader, reader.uint32());
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.contractCall = exports.EventContractCall.decode(reader, reader.uint32());
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.contractCallWithToken = exports.EventContractCallWithToken.decode(reader, reader.uint32());
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.transfer = exports.EventTransfer.decode(reader, reader.uint32());
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.tokenDeployed = exports.EventTokenDeployed.decode(reader, reader.uint32());
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.multisigOwnershipTransferred = exports.EventMultisigOwnershipTransferred.decode(reader, reader.uint32());
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.multisigOperatorshipTransferred = exports.EventMultisigOperatorshipTransferred.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.Event.$type,
            chain: isSet(object.chain) ? gt.String(object.chain) : "",
            txId: isSet(object.txId) ? Buffer.from(bytesFromBase64(object.txId)) : Buffer.alloc(0),
            index: isSet(object.index) ? long_1.default.fromValue(object.index) : long_1.default.UZERO,
            status: isSet(object.status) ? event_StatusFromJSON(object.status) : 0,
            tokenSent: isSet(object.tokenSent) ? exports.EventTokenSent.fromJSON(object.tokenSent) : undefined,
            contractCall: isSet(object.contractCall) ? exports.EventContractCall.fromJSON(object.contractCall) : undefined,
            contractCallWithToken: isSet(object.contractCallWithToken)
                ? exports.EventContractCallWithToken.fromJSON(object.contractCallWithToken)
                : undefined,
            transfer: isSet(object.transfer) ? exports.EventTransfer.fromJSON(object.transfer) : undefined,
            tokenDeployed: isSet(object.tokenDeployed)
                ? exports.EventTokenDeployed.fromJSON(object.tokenDeployed)
                : undefined,
            multisigOwnershipTransferred: isSet(object.multisigOwnershipTransferred)
                ? exports.EventMultisigOwnershipTransferred.fromJSON(object.multisigOwnershipTransferred)
                : undefined,
            multisigOperatorshipTransferred: isSet(object.multisigOperatorshipTransferred)
                ? exports.EventMultisigOperatorshipTransferred.fromJSON(object.multisigOperatorshipTransferred)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.chain !== "") {
            obj.chain = message.chain;
        }
        if (message.txId.length !== 0) {
            obj.txId = base64FromBytes(message.txId);
        }
        if (!message.index.equals(long_1.default.UZERO)) {
            obj.index = (message.index || long_1.default.UZERO).toString();
        }
        if (message.status !== 0) {
            obj.status = event_StatusToJSON(message.status);
        }
        if (message.tokenSent !== undefined) {
            obj.tokenSent = exports.EventTokenSent.toJSON(message.tokenSent);
        }
        if (message.contractCall !== undefined) {
            obj.contractCall = exports.EventContractCall.toJSON(message.contractCall);
        }
        if (message.contractCallWithToken !== undefined) {
            obj.contractCallWithToken = exports.EventContractCallWithToken.toJSON(message.contractCallWithToken);
        }
        if (message.transfer !== undefined) {
            obj.transfer = exports.EventTransfer.toJSON(message.transfer);
        }
        if (message.tokenDeployed !== undefined) {
            obj.tokenDeployed = exports.EventTokenDeployed.toJSON(message.tokenDeployed);
        }
        if (message.multisigOwnershipTransferred !== undefined) {
            obj.multisigOwnershipTransferred = exports.EventMultisigOwnershipTransferred.toJSON(message.multisigOwnershipTransferred);
        }
        if (message.multisigOperatorshipTransferred !== undefined) {
            obj.multisigOperatorshipTransferred = exports.EventMultisigOperatorshipTransferred.toJSON(message.multisigOperatorshipTransferred);
        }
        return obj;
    },
    create(base) {
        return exports.Event.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseEvent();
        message.chain = (_a = object.chain) !== null && _a !== void 0 ? _a : "";
        message.txId = (_b = object.txId) !== null && _b !== void 0 ? _b : Buffer.alloc(0);
        message.index =
            object.index !== undefined && object.index !== null ? long_1.default.fromValue(object.index) : long_1.default.UZERO;
        message.status = (_c = object.status) !== null && _c !== void 0 ? _c : 0;
        message.tokenSent =
            object.tokenSent !== undefined && object.tokenSent !== null
                ? exports.EventTokenSent.fromPartial(object.tokenSent)
                : undefined;
        message.contractCall =
            object.contractCall !== undefined && object.contractCall !== null
                ? exports.EventContractCall.fromPartial(object.contractCall)
                : undefined;
        message.contractCallWithToken =
            object.contractCallWithToken !== undefined && object.contractCallWithToken !== null
                ? exports.EventContractCallWithToken.fromPartial(object.contractCallWithToken)
                : undefined;
        message.transfer =
            object.transfer !== undefined && object.transfer !== null
                ? exports.EventTransfer.fromPartial(object.transfer)
                : undefined;
        message.tokenDeployed =
            object.tokenDeployed !== undefined && object.tokenDeployed !== null
                ? exports.EventTokenDeployed.fromPartial(object.tokenDeployed)
                : undefined;
        message.multisigOwnershipTransferred =
            object.multisigOwnershipTransferred !== undefined && object.multisigOwnershipTransferred !== null
                ? exports.EventMultisigOwnershipTransferred.fromPartial(object.multisigOwnershipTransferred)
                : undefined;
        message.multisigOperatorshipTransferred =
            object.multisigOperatorshipTransferred !== undefined && object.multisigOperatorshipTransferred !== null
                ? exports.EventMultisigOperatorshipTransferred.fromPartial(object.multisigOperatorshipTransferred)
                : undefined;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.Event.$type, exports.Event);
function createBaseEventTokenSent() {
    return {
        $type: "axelar.evm.v1beta1.EventTokenSent",
        sender: Buffer.alloc(0),
        destinationChain: "",
        destinationAddress: "",
        symbol: "",
        amount: Buffer.alloc(0),
    };
}
exports.EventTokenSent = {
    $type: "axelar.evm.v1beta1.EventTokenSent",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender.length !== 0) {
            writer.uint32(10).bytes(message.sender);
        }
        if (message.destinationChain !== "") {
            writer.uint32(18).string(message.destinationChain);
        }
        if (message.destinationAddress !== "") {
            writer.uint32(26).string(message.destinationAddress);
        }
        if (message.symbol !== "") {
            writer.uint32(34).string(message.symbol);
        }
        if (message.amount.length !== 0) {
            writer.uint32(42).bytes(message.amount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEventTokenSent();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.sender = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.destinationChain = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.destinationAddress = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.symbol = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.amount = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.EventTokenSent.$type,
            sender: isSet(object.sender) ? Buffer.from(bytesFromBase64(object.sender)) : Buffer.alloc(0),
            destinationChain: isSet(object.destinationChain) ? gt.String(object.destinationChain) : "",
            destinationAddress: isSet(object.destinationAddress) ? gt.String(object.destinationAddress) : "",
            symbol: isSet(object.symbol) ? gt.String(object.symbol) : "",
            amount: isSet(object.amount) ? Buffer.from(bytesFromBase64(object.amount)) : Buffer.alloc(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.sender.length !== 0) {
            obj.sender = base64FromBytes(message.sender);
        }
        if (message.destinationChain !== "") {
            obj.destinationChain = message.destinationChain;
        }
        if (message.destinationAddress !== "") {
            obj.destinationAddress = message.destinationAddress;
        }
        if (message.symbol !== "") {
            obj.symbol = message.symbol;
        }
        if (message.amount.length !== 0) {
            obj.amount = base64FromBytes(message.amount);
        }
        return obj;
    },
    create(base) {
        return exports.EventTokenSent.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseEventTokenSent();
        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : Buffer.alloc(0);
        message.destinationChain = (_b = object.destinationChain) !== null && _b !== void 0 ? _b : "";
        message.destinationAddress = (_c = object.destinationAddress) !== null && _c !== void 0 ? _c : "";
        message.symbol = (_d = object.symbol) !== null && _d !== void 0 ? _d : "";
        message.amount = (_e = object.amount) !== null && _e !== void 0 ? _e : Buffer.alloc(0);
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.EventTokenSent.$type, exports.EventTokenSent);
function createBaseEventContractCall() {
    return {
        $type: "axelar.evm.v1beta1.EventContractCall",
        sender: Buffer.alloc(0),
        destinationChain: "",
        contractAddress: "",
        payloadHash: Buffer.alloc(0),
    };
}
exports.EventContractCall = {
    $type: "axelar.evm.v1beta1.EventContractCall",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender.length !== 0) {
            writer.uint32(10).bytes(message.sender);
        }
        if (message.destinationChain !== "") {
            writer.uint32(18).string(message.destinationChain);
        }
        if (message.contractAddress !== "") {
            writer.uint32(26).string(message.contractAddress);
        }
        if (message.payloadHash.length !== 0) {
            writer.uint32(34).bytes(message.payloadHash);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEventContractCall();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.sender = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.destinationChain = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.contractAddress = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.payloadHash = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.EventContractCall.$type,
            sender: isSet(object.sender) ? Buffer.from(bytesFromBase64(object.sender)) : Buffer.alloc(0),
            destinationChain: isSet(object.destinationChain) ? gt.String(object.destinationChain) : "",
            contractAddress: isSet(object.contractAddress) ? gt.String(object.contractAddress) : "",
            payloadHash: isSet(object.payloadHash)
                ? Buffer.from(bytesFromBase64(object.payloadHash))
                : Buffer.alloc(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.sender.length !== 0) {
            obj.sender = base64FromBytes(message.sender);
        }
        if (message.destinationChain !== "") {
            obj.destinationChain = message.destinationChain;
        }
        if (message.contractAddress !== "") {
            obj.contractAddress = message.contractAddress;
        }
        if (message.payloadHash.length !== 0) {
            obj.payloadHash = base64FromBytes(message.payloadHash);
        }
        return obj;
    },
    create(base) {
        return exports.EventContractCall.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseEventContractCall();
        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : Buffer.alloc(0);
        message.destinationChain = (_b = object.destinationChain) !== null && _b !== void 0 ? _b : "";
        message.contractAddress = (_c = object.contractAddress) !== null && _c !== void 0 ? _c : "";
        message.payloadHash = (_d = object.payloadHash) !== null && _d !== void 0 ? _d : Buffer.alloc(0);
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.EventContractCall.$type, exports.EventContractCall);
function createBaseEventContractCallWithToken() {
    return {
        $type: "axelar.evm.v1beta1.EventContractCallWithToken",
        sender: Buffer.alloc(0),
        destinationChain: "",
        contractAddress: "",
        payloadHash: Buffer.alloc(0),
        symbol: "",
        amount: Buffer.alloc(0),
    };
}
exports.EventContractCallWithToken = {
    $type: "axelar.evm.v1beta1.EventContractCallWithToken",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender.length !== 0) {
            writer.uint32(10).bytes(message.sender);
        }
        if (message.destinationChain !== "") {
            writer.uint32(18).string(message.destinationChain);
        }
        if (message.contractAddress !== "") {
            writer.uint32(26).string(message.contractAddress);
        }
        if (message.payloadHash.length !== 0) {
            writer.uint32(34).bytes(message.payloadHash);
        }
        if (message.symbol !== "") {
            writer.uint32(42).string(message.symbol);
        }
        if (message.amount.length !== 0) {
            writer.uint32(50).bytes(message.amount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEventContractCallWithToken();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.sender = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.destinationChain = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.contractAddress = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.payloadHash = reader.bytes();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.symbol = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.amount = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.EventContractCallWithToken.$type,
            sender: isSet(object.sender) ? Buffer.from(bytesFromBase64(object.sender)) : Buffer.alloc(0),
            destinationChain: isSet(object.destinationChain) ? gt.String(object.destinationChain) : "",
            contractAddress: isSet(object.contractAddress) ? gt.String(object.contractAddress) : "",
            payloadHash: isSet(object.payloadHash)
                ? Buffer.from(bytesFromBase64(object.payloadHash))
                : Buffer.alloc(0),
            symbol: isSet(object.symbol) ? gt.String(object.symbol) : "",
            amount: isSet(object.amount) ? Buffer.from(bytesFromBase64(object.amount)) : Buffer.alloc(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.sender.length !== 0) {
            obj.sender = base64FromBytes(message.sender);
        }
        if (message.destinationChain !== "") {
            obj.destinationChain = message.destinationChain;
        }
        if (message.contractAddress !== "") {
            obj.contractAddress = message.contractAddress;
        }
        if (message.payloadHash.length !== 0) {
            obj.payloadHash = base64FromBytes(message.payloadHash);
        }
        if (message.symbol !== "") {
            obj.symbol = message.symbol;
        }
        if (message.amount.length !== 0) {
            obj.amount = base64FromBytes(message.amount);
        }
        return obj;
    },
    create(base) {
        return exports.EventContractCallWithToken.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseEventContractCallWithToken();
        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : Buffer.alloc(0);
        message.destinationChain = (_b = object.destinationChain) !== null && _b !== void 0 ? _b : "";
        message.contractAddress = (_c = object.contractAddress) !== null && _c !== void 0 ? _c : "";
        message.payloadHash = (_d = object.payloadHash) !== null && _d !== void 0 ? _d : Buffer.alloc(0);
        message.symbol = (_e = object.symbol) !== null && _e !== void 0 ? _e : "";
        message.amount = (_f = object.amount) !== null && _f !== void 0 ? _f : Buffer.alloc(0);
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.EventContractCallWithToken.$type, exports.EventContractCallWithToken);
function createBaseEventTransfer() {
    return { $type: "axelar.evm.v1beta1.EventTransfer", to: Buffer.alloc(0), amount: Buffer.alloc(0) };
}
exports.EventTransfer = {
    $type: "axelar.evm.v1beta1.EventTransfer",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.to.length !== 0) {
            writer.uint32(10).bytes(message.to);
        }
        if (message.amount.length !== 0) {
            writer.uint32(18).bytes(message.amount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEventTransfer();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.to = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.amount = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.EventTransfer.$type,
            to: isSet(object.to) ? Buffer.from(bytesFromBase64(object.to)) : Buffer.alloc(0),
            amount: isSet(object.amount) ? Buffer.from(bytesFromBase64(object.amount)) : Buffer.alloc(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.to.length !== 0) {
            obj.to = base64FromBytes(message.to);
        }
        if (message.amount.length !== 0) {
            obj.amount = base64FromBytes(message.amount);
        }
        return obj;
    },
    create(base) {
        return exports.EventTransfer.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseEventTransfer();
        message.to = (_a = object.to) !== null && _a !== void 0 ? _a : Buffer.alloc(0);
        message.amount = (_b = object.amount) !== null && _b !== void 0 ? _b : Buffer.alloc(0);
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.EventTransfer.$type, exports.EventTransfer);
function createBaseEventTokenDeployed() {
    return { $type: "axelar.evm.v1beta1.EventTokenDeployed", symbol: "", tokenAddress: Buffer.alloc(0) };
}
exports.EventTokenDeployed = {
    $type: "axelar.evm.v1beta1.EventTokenDeployed",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.symbol !== "") {
            writer.uint32(10).string(message.symbol);
        }
        if (message.tokenAddress.length !== 0) {
            writer.uint32(18).bytes(message.tokenAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEventTokenDeployed();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.symbol = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.tokenAddress = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.EventTokenDeployed.$type,
            symbol: isSet(object.symbol) ? gt.String(object.symbol) : "",
            tokenAddress: isSet(object.tokenAddress)
                ? Buffer.from(bytesFromBase64(object.tokenAddress))
                : Buffer.alloc(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.symbol !== "") {
            obj.symbol = message.symbol;
        }
        if (message.tokenAddress.length !== 0) {
            obj.tokenAddress = base64FromBytes(message.tokenAddress);
        }
        return obj;
    },
    create(base) {
        return exports.EventTokenDeployed.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseEventTokenDeployed();
        message.symbol = (_a = object.symbol) !== null && _a !== void 0 ? _a : "";
        message.tokenAddress = (_b = object.tokenAddress) !== null && _b !== void 0 ? _b : Buffer.alloc(0);
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.EventTokenDeployed.$type, exports.EventTokenDeployed);
function createBaseEventMultisigOwnershipTransferred() {
    return {
        $type: "axelar.evm.v1beta1.EventMultisigOwnershipTransferred",
        preOwners: [],
        prevThreshold: Buffer.alloc(0),
        newOwners: [],
        newThreshold: Buffer.alloc(0),
    };
}
exports.EventMultisigOwnershipTransferred = {
    $type: "axelar.evm.v1beta1.EventMultisigOwnershipTransferred",
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.preOwners) {
            writer.uint32(10).bytes(v);
        }
        if (message.prevThreshold.length !== 0) {
            writer.uint32(18).bytes(message.prevThreshold);
        }
        for (const v of message.newOwners) {
            writer.uint32(26).bytes(v);
        }
        if (message.newThreshold.length !== 0) {
            writer.uint32(34).bytes(message.newThreshold);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEventMultisigOwnershipTransferred();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.preOwners.push(reader.bytes());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.prevThreshold = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.newOwners.push(reader.bytes());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.newThreshold = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.EventMultisigOwnershipTransferred.$type,
            preOwners: gt.Array.isArray(object === null || object === void 0 ? void 0 : object.preOwners)
                ? object.preOwners.map((e) => Buffer.from(bytesFromBase64(e)))
                : [],
            prevThreshold: isSet(object.prevThreshold)
                ? Buffer.from(bytesFromBase64(object.prevThreshold))
                : Buffer.alloc(0),
            newOwners: gt.Array.isArray(object === null || object === void 0 ? void 0 : object.newOwners)
                ? object.newOwners.map((e) => Buffer.from(bytesFromBase64(e)))
                : [],
            newThreshold: isSet(object.newThreshold)
                ? Buffer.from(bytesFromBase64(object.newThreshold))
                : Buffer.alloc(0),
        };
    },
    toJSON(message) {
        var _a, _b;
        const obj = {};
        if ((_a = message.preOwners) === null || _a === void 0 ? void 0 : _a.length) {
            obj.preOwners = message.preOwners.map((e) => base64FromBytes(e));
        }
        if (message.prevThreshold.length !== 0) {
            obj.prevThreshold = base64FromBytes(message.prevThreshold);
        }
        if ((_b = message.newOwners) === null || _b === void 0 ? void 0 : _b.length) {
            obj.newOwners = message.newOwners.map((e) => base64FromBytes(e));
        }
        if (message.newThreshold.length !== 0) {
            obj.newThreshold = base64FromBytes(message.newThreshold);
        }
        return obj;
    },
    create(base) {
        return exports.EventMultisigOwnershipTransferred.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseEventMultisigOwnershipTransferred();
        message.preOwners = ((_a = object.preOwners) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        message.prevThreshold = (_b = object.prevThreshold) !== null && _b !== void 0 ? _b : Buffer.alloc(0);
        message.newOwners = ((_c = object.newOwners) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        message.newThreshold = (_d = object.newThreshold) !== null && _d !== void 0 ? _d : Buffer.alloc(0);
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.EventMultisigOwnershipTransferred.$type, exports.EventMultisigOwnershipTransferred);
function createBaseEventMultisigOperatorshipTransferred() {
    return {
        $type: "axelar.evm.v1beta1.EventMultisigOperatorshipTransferred",
        newOperators: [],
        newThreshold: Buffer.alloc(0),
        newWeights: [],
    };
}
exports.EventMultisigOperatorshipTransferred = {
    $type: "axelar.evm.v1beta1.EventMultisigOperatorshipTransferred",
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.newOperators) {
            writer.uint32(26).bytes(v);
        }
        if (message.newThreshold.length !== 0) {
            writer.uint32(34).bytes(message.newThreshold);
        }
        for (const v of message.newWeights) {
            writer.uint32(42).bytes(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEventMultisigOperatorshipTransferred();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.newOperators.push(reader.bytes());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.newThreshold = reader.bytes();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.newWeights.push(reader.bytes());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.EventMultisigOperatorshipTransferred.$type,
            newOperators: gt.Array.isArray(object === null || object === void 0 ? void 0 : object.newOperators)
                ? object.newOperators.map((e) => Buffer.from(bytesFromBase64(e)))
                : [],
            newThreshold: isSet(object.newThreshold)
                ? Buffer.from(bytesFromBase64(object.newThreshold))
                : Buffer.alloc(0),
            newWeights: gt.Array.isArray(object === null || object === void 0 ? void 0 : object.newWeights)
                ? object.newWeights.map((e) => Buffer.from(bytesFromBase64(e)))
                : [],
        };
    },
    toJSON(message) {
        var _a, _b;
        const obj = {};
        if ((_a = message.newOperators) === null || _a === void 0 ? void 0 : _a.length) {
            obj.newOperators = message.newOperators.map((e) => base64FromBytes(e));
        }
        if (message.newThreshold.length !== 0) {
            obj.newThreshold = base64FromBytes(message.newThreshold);
        }
        if ((_b = message.newWeights) === null || _b === void 0 ? void 0 : _b.length) {
            obj.newWeights = message.newWeights.map((e) => base64FromBytes(e));
        }
        return obj;
    },
    create(base) {
        return exports.EventMultisigOperatorshipTransferred.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseEventMultisigOperatorshipTransferred();
        message.newOperators = ((_a = object.newOperators) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        message.newThreshold = (_b = object.newThreshold) !== null && _b !== void 0 ? _b : Buffer.alloc(0);
        message.newWeights = ((_c = object.newWeights) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.EventMultisigOperatorshipTransferred.$type, exports.EventMultisigOperatorshipTransferred);
function createBaseNetworkInfo() {
    return { $type: "axelar.evm.v1beta1.NetworkInfo", name: "", id: Buffer.alloc(0) };
}
exports.NetworkInfo = {
    $type: "axelar.evm.v1beta1.NetworkInfo",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.id.length !== 0) {
            writer.uint32(18).bytes(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseNetworkInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.id = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.NetworkInfo.$type,
            name: isSet(object.name) ? gt.String(object.name) : "",
            id: isSet(object.id) ? Buffer.from(bytesFromBase64(object.id)) : Buffer.alloc(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.id.length !== 0) {
            obj.id = base64FromBytes(message.id);
        }
        return obj;
    },
    create(base) {
        return exports.NetworkInfo.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseNetworkInfo();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
        message.id = (_b = object.id) !== null && _b !== void 0 ? _b : Buffer.alloc(0);
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.NetworkInfo.$type, exports.NetworkInfo);
function createBaseBurnerInfo() {
    return {
        $type: "axelar.evm.v1beta1.BurnerInfo",
        burnerAddress: Buffer.alloc(0),
        tokenAddress: Buffer.alloc(0),
        destinationChain: "",
        symbol: "",
        asset: "",
        salt: Buffer.alloc(0),
    };
}
exports.BurnerInfo = {
    $type: "axelar.evm.v1beta1.BurnerInfo",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.burnerAddress.length !== 0) {
            writer.uint32(10).bytes(message.burnerAddress);
        }
        if (message.tokenAddress.length !== 0) {
            writer.uint32(18).bytes(message.tokenAddress);
        }
        if (message.destinationChain !== "") {
            writer.uint32(26).string(message.destinationChain);
        }
        if (message.symbol !== "") {
            writer.uint32(34).string(message.symbol);
        }
        if (message.asset !== "") {
            writer.uint32(42).string(message.asset);
        }
        if (message.salt.length !== 0) {
            writer.uint32(50).bytes(message.salt);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBurnerInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.burnerAddress = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.tokenAddress = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.destinationChain = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.symbol = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.asset = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.salt = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.BurnerInfo.$type,
            burnerAddress: isSet(object.burnerAddress)
                ? Buffer.from(bytesFromBase64(object.burnerAddress))
                : Buffer.alloc(0),
            tokenAddress: isSet(object.tokenAddress)
                ? Buffer.from(bytesFromBase64(object.tokenAddress))
                : Buffer.alloc(0),
            destinationChain: isSet(object.destinationChain) ? gt.String(object.destinationChain) : "",
            symbol: isSet(object.symbol) ? gt.String(object.symbol) : "",
            asset: isSet(object.asset) ? gt.String(object.asset) : "",
            salt: isSet(object.salt) ? Buffer.from(bytesFromBase64(object.salt)) : Buffer.alloc(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.burnerAddress.length !== 0) {
            obj.burnerAddress = base64FromBytes(message.burnerAddress);
        }
        if (message.tokenAddress.length !== 0) {
            obj.tokenAddress = base64FromBytes(message.tokenAddress);
        }
        if (message.destinationChain !== "") {
            obj.destinationChain = message.destinationChain;
        }
        if (message.symbol !== "") {
            obj.symbol = message.symbol;
        }
        if (message.asset !== "") {
            obj.asset = message.asset;
        }
        if (message.salt.length !== 0) {
            obj.salt = base64FromBytes(message.salt);
        }
        return obj;
    },
    create(base) {
        return exports.BurnerInfo.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseBurnerInfo();
        message.burnerAddress = (_a = object.burnerAddress) !== null && _a !== void 0 ? _a : Buffer.alloc(0);
        message.tokenAddress = (_b = object.tokenAddress) !== null && _b !== void 0 ? _b : Buffer.alloc(0);
        message.destinationChain = (_c = object.destinationChain) !== null && _c !== void 0 ? _c : "";
        message.symbol = (_d = object.symbol) !== null && _d !== void 0 ? _d : "";
        message.asset = (_e = object.asset) !== null && _e !== void 0 ? _e : "";
        message.salt = (_f = object.salt) !== null && _f !== void 0 ? _f : Buffer.alloc(0);
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.BurnerInfo.$type, exports.BurnerInfo);
function createBaseERC20Deposit() {
    return {
        $type: "axelar.evm.v1beta1.ERC20Deposit",
        txId: Buffer.alloc(0),
        amount: Buffer.alloc(0),
        asset: "",
        destinationChain: "",
        burnerAddress: Buffer.alloc(0),
        logIndex: long_1.default.UZERO,
    };
}
exports.ERC20Deposit = {
    $type: "axelar.evm.v1beta1.ERC20Deposit",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.txId.length !== 0) {
            writer.uint32(10).bytes(message.txId);
        }
        if (message.amount.length !== 0) {
            writer.uint32(18).bytes(message.amount);
        }
        if (message.asset !== "") {
            writer.uint32(26).string(message.asset);
        }
        if (message.destinationChain !== "") {
            writer.uint32(34).string(message.destinationChain);
        }
        if (message.burnerAddress.length !== 0) {
            writer.uint32(42).bytes(message.burnerAddress);
        }
        if (!message.logIndex.equals(long_1.default.UZERO)) {
            writer.uint32(48).uint64(message.logIndex);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseERC20Deposit();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.txId = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.amount = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.asset = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.destinationChain = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.burnerAddress = reader.bytes();
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.logIndex = reader.uint64();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.ERC20Deposit.$type,
            txId: isSet(object.txId) ? Buffer.from(bytesFromBase64(object.txId)) : Buffer.alloc(0),
            amount: isSet(object.amount) ? Buffer.from(bytesFromBase64(object.amount)) : Buffer.alloc(0),
            asset: isSet(object.asset) ? gt.String(object.asset) : "",
            destinationChain: isSet(object.destinationChain) ? gt.String(object.destinationChain) : "",
            burnerAddress: isSet(object.burnerAddress)
                ? Buffer.from(bytesFromBase64(object.burnerAddress))
                : Buffer.alloc(0),
            logIndex: isSet(object.logIndex) ? long_1.default.fromValue(object.logIndex) : long_1.default.UZERO,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.txId.length !== 0) {
            obj.txId = base64FromBytes(message.txId);
        }
        if (message.amount.length !== 0) {
            obj.amount = base64FromBytes(message.amount);
        }
        if (message.asset !== "") {
            obj.asset = message.asset;
        }
        if (message.destinationChain !== "") {
            obj.destinationChain = message.destinationChain;
        }
        if (message.burnerAddress.length !== 0) {
            obj.burnerAddress = base64FromBytes(message.burnerAddress);
        }
        if (!message.logIndex.equals(long_1.default.UZERO)) {
            obj.logIndex = (message.logIndex || long_1.default.UZERO).toString();
        }
        return obj;
    },
    create(base) {
        return exports.ERC20Deposit.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseERC20Deposit();
        message.txId = (_a = object.txId) !== null && _a !== void 0 ? _a : Buffer.alloc(0);
        message.amount = (_b = object.amount) !== null && _b !== void 0 ? _b : Buffer.alloc(0);
        message.asset = (_c = object.asset) !== null && _c !== void 0 ? _c : "";
        message.destinationChain = (_d = object.destinationChain) !== null && _d !== void 0 ? _d : "";
        message.burnerAddress = (_e = object.burnerAddress) !== null && _e !== void 0 ? _e : Buffer.alloc(0);
        message.logIndex =
            object.logIndex !== undefined && object.logIndex !== null
                ? long_1.default.fromValue(object.logIndex)
                : long_1.default.UZERO;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.ERC20Deposit.$type, exports.ERC20Deposit);
function createBaseERC20TokenMetadata() {
    return {
        $type: "axelar.evm.v1beta1.ERC20TokenMetadata",
        asset: "",
        chainId: Buffer.alloc(0),
        details: undefined,
        tokenAddress: "",
        txHash: "",
        status: 0,
        isExternal: false,
        burnerCode: Buffer.alloc(0),
    };
}
exports.ERC20TokenMetadata = {
    $type: "axelar.evm.v1beta1.ERC20TokenMetadata",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.asset !== "") {
            writer.uint32(10).string(message.asset);
        }
        if (message.chainId.length !== 0) {
            writer.uint32(18).bytes(message.chainId);
        }
        if (message.details !== undefined) {
            exports.TokenDetails.encode(message.details, writer.uint32(26).fork()).ldelim();
        }
        if (message.tokenAddress !== "") {
            writer.uint32(34).string(message.tokenAddress);
        }
        if (message.txHash !== "") {
            writer.uint32(42).string(message.txHash);
        }
        if (message.status !== 0) {
            writer.uint32(56).int32(message.status);
        }
        if (message.isExternal !== false) {
            writer.uint32(64).bool(message.isExternal);
        }
        if (message.burnerCode.length !== 0) {
            writer.uint32(74).bytes(message.burnerCode);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseERC20TokenMetadata();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.asset = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.chainId = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.details = exports.TokenDetails.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.tokenAddress = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.txHash = reader.string();
                    continue;
                case 7:
                    if (tag !== 56) {
                        break;
                    }
                    message.status = reader.int32();
                    continue;
                case 8:
                    if (tag !== 64) {
                        break;
                    }
                    message.isExternal = reader.bool();
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.burnerCode = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.ERC20TokenMetadata.$type,
            asset: isSet(object.asset) ? gt.String(object.asset) : "",
            chainId: isSet(object.chainId) ? Buffer.from(bytesFromBase64(object.chainId)) : Buffer.alloc(0),
            details: isSet(object.details) ? exports.TokenDetails.fromJSON(object.details) : undefined,
            tokenAddress: isSet(object.tokenAddress) ? gt.String(object.tokenAddress) : "",
            txHash: isSet(object.txHash) ? gt.String(object.txHash) : "",
            status: isSet(object.status) ? statusFromJSON(object.status) : 0,
            isExternal: isSet(object.isExternal) ? gt.Boolean(object.isExternal) : false,
            burnerCode: isSet(object.burnerCode)
                ? Buffer.from(bytesFromBase64(object.burnerCode))
                : Buffer.alloc(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.asset !== "") {
            obj.asset = message.asset;
        }
        if (message.chainId.length !== 0) {
            obj.chainId = base64FromBytes(message.chainId);
        }
        if (message.details !== undefined) {
            obj.details = exports.TokenDetails.toJSON(message.details);
        }
        if (message.tokenAddress !== "") {
            obj.tokenAddress = message.tokenAddress;
        }
        if (message.txHash !== "") {
            obj.txHash = message.txHash;
        }
        if (message.status !== 0) {
            obj.status = statusToJSON(message.status);
        }
        if (message.isExternal !== false) {
            obj.isExternal = message.isExternal;
        }
        if (message.burnerCode.length !== 0) {
            obj.burnerCode = base64FromBytes(message.burnerCode);
        }
        return obj;
    },
    create(base) {
        return exports.ERC20TokenMetadata.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g;
        const message = createBaseERC20TokenMetadata();
        message.asset = (_a = object.asset) !== null && _a !== void 0 ? _a : "";
        message.chainId = (_b = object.chainId) !== null && _b !== void 0 ? _b : Buffer.alloc(0);
        message.details =
            object.details !== undefined && object.details !== null
                ? exports.TokenDetails.fromPartial(object.details)
                : undefined;
        message.tokenAddress = (_c = object.tokenAddress) !== null && _c !== void 0 ? _c : "";
        message.txHash = (_d = object.txHash) !== null && _d !== void 0 ? _d : "";
        message.status = (_e = object.status) !== null && _e !== void 0 ? _e : 0;
        message.isExternal = (_f = object.isExternal) !== null && _f !== void 0 ? _f : false;
        message.burnerCode = (_g = object.burnerCode) !== null && _g !== void 0 ? _g : Buffer.alloc(0);
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.ERC20TokenMetadata.$type, exports.ERC20TokenMetadata);
function createBaseTransactionMetadata() {
    return { $type: "axelar.evm.v1beta1.TransactionMetadata", rawTx: Buffer.alloc(0), pubKey: Buffer.alloc(0) };
}
exports.TransactionMetadata = {
    $type: "axelar.evm.v1beta1.TransactionMetadata",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.rawTx.length !== 0) {
            writer.uint32(10).bytes(message.rawTx);
        }
        if (message.pubKey.length !== 0) {
            writer.uint32(18).bytes(message.pubKey);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransactionMetadata();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.rawTx = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pubKey = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.TransactionMetadata.$type,
            rawTx: isSet(object.rawTx) ? Buffer.from(bytesFromBase64(object.rawTx)) : Buffer.alloc(0),
            pubKey: isSet(object.pubKey) ? Buffer.from(bytesFromBase64(object.pubKey)) : Buffer.alloc(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.rawTx.length !== 0) {
            obj.rawTx = base64FromBytes(message.rawTx);
        }
        if (message.pubKey.length !== 0) {
            obj.pubKey = base64FromBytes(message.pubKey);
        }
        return obj;
    },
    create(base) {
        return exports.TransactionMetadata.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseTransactionMetadata();
        message.rawTx = (_a = object.rawTx) !== null && _a !== void 0 ? _a : Buffer.alloc(0);
        message.pubKey = (_b = object.pubKey) !== null && _b !== void 0 ? _b : Buffer.alloc(0);
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.TransactionMetadata.$type, exports.TransactionMetadata);
function createBaseCommand() {
    return {
        $type: "axelar.evm.v1beta1.Command",
        id: Buffer.alloc(0),
        command: "",
        params: Buffer.alloc(0),
        keyId: "",
        maxGasCost: 0,
        type: 0,
    };
}
exports.Command = {
    $type: "axelar.evm.v1beta1.Command",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id.length !== 0) {
            writer.uint32(10).bytes(message.id);
        }
        if (message.command !== "") {
            writer.uint32(18).string(message.command);
        }
        if (message.params.length !== 0) {
            writer.uint32(26).bytes(message.params);
        }
        if (message.keyId !== "") {
            writer.uint32(34).string(message.keyId);
        }
        if (message.maxGasCost !== 0) {
            writer.uint32(40).uint32(message.maxGasCost);
        }
        if (message.type !== 0) {
            writer.uint32(48).int32(message.type);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommand();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.command = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.params = reader.bytes();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.keyId = reader.string();
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.maxGasCost = reader.uint32();
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.type = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.Command.$type,
            id: isSet(object.id) ? Buffer.from(bytesFromBase64(object.id)) : Buffer.alloc(0),
            command: isSet(object.command) ? gt.String(object.command) : "",
            params: isSet(object.params) ? Buffer.from(bytesFromBase64(object.params)) : Buffer.alloc(0),
            keyId: isSet(object.keyId) ? gt.String(object.keyId) : "",
            maxGasCost: isSet(object.maxGasCost) ? gt.Number(object.maxGasCost) : 0,
            type: isSet(object.type) ? commandTypeFromJSON(object.type) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id.length !== 0) {
            obj.id = base64FromBytes(message.id);
        }
        if (message.command !== "") {
            obj.command = message.command;
        }
        if (message.params.length !== 0) {
            obj.params = base64FromBytes(message.params);
        }
        if (message.keyId !== "") {
            obj.keyId = message.keyId;
        }
        if (message.maxGasCost !== 0) {
            obj.maxGasCost = Math.round(message.maxGasCost);
        }
        if (message.type !== 0) {
            obj.type = commandTypeToJSON(message.type);
        }
        return obj;
    },
    create(base) {
        return exports.Command.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseCommand();
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : Buffer.alloc(0);
        message.command = (_b = object.command) !== null && _b !== void 0 ? _b : "";
        message.params = (_c = object.params) !== null && _c !== void 0 ? _c : Buffer.alloc(0);
        message.keyId = (_d = object.keyId) !== null && _d !== void 0 ? _d : "";
        message.maxGasCost = (_e = object.maxGasCost) !== null && _e !== void 0 ? _e : 0;
        message.type = (_f = object.type) !== null && _f !== void 0 ? _f : 0;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.Command.$type, exports.Command);
function createBaseCommandBatchMetadata() {
    return {
        $type: "axelar.evm.v1beta1.CommandBatchMetadata",
        id: Buffer.alloc(0),
        commandIds: [],
        data: Buffer.alloc(0),
        sigHash: Buffer.alloc(0),
        status: 0,
        keyId: "",
        prevBatchedCommandsId: Buffer.alloc(0),
        signature: undefined,
    };
}
exports.CommandBatchMetadata = {
    $type: "axelar.evm.v1beta1.CommandBatchMetadata",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id.length !== 0) {
            writer.uint32(10).bytes(message.id);
        }
        for (const v of message.commandIds) {
            writer.uint32(18).bytes(v);
        }
        if (message.data.length !== 0) {
            writer.uint32(26).bytes(message.data);
        }
        if (message.sigHash.length !== 0) {
            writer.uint32(34).bytes(message.sigHash);
        }
        if (message.status !== 0) {
            writer.uint32(40).int32(message.status);
        }
        if (message.keyId !== "") {
            writer.uint32(50).string(message.keyId);
        }
        if (message.prevBatchedCommandsId.length !== 0) {
            writer.uint32(58).bytes(message.prevBatchedCommandsId);
        }
        if (message.signature !== undefined) {
            any_1.Any.encode(message.signature, writer.uint32(66).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommandBatchMetadata();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.commandIds.push(reader.bytes());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.data = reader.bytes();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.sigHash = reader.bytes();
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.status = reader.int32();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.keyId = reader.string();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.prevBatchedCommandsId = reader.bytes();
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.signature = any_1.Any.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.CommandBatchMetadata.$type,
            id: isSet(object.id) ? Buffer.from(bytesFromBase64(object.id)) : Buffer.alloc(0),
            commandIds: gt.Array.isArray(object === null || object === void 0 ? void 0 : object.commandIds)
                ? object.commandIds.map((e) => Buffer.from(bytesFromBase64(e)))
                : [],
            data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
            sigHash: isSet(object.sigHash) ? Buffer.from(bytesFromBase64(object.sigHash)) : Buffer.alloc(0),
            status: isSet(object.status) ? batchedCommandsStatusFromJSON(object.status) : 0,
            keyId: isSet(object.keyId) ? gt.String(object.keyId) : "",
            prevBatchedCommandsId: isSet(object.prevBatchedCommandsId)
                ? Buffer.from(bytesFromBase64(object.prevBatchedCommandsId))
                : Buffer.alloc(0),
            signature: isSet(object.signature) ? any_1.Any.fromJSON(object.signature) : undefined,
        };
    },
    toJSON(message) {
        var _a;
        const obj = {};
        if (message.id.length !== 0) {
            obj.id = base64FromBytes(message.id);
        }
        if ((_a = message.commandIds) === null || _a === void 0 ? void 0 : _a.length) {
            obj.commandIds = message.commandIds.map((e) => base64FromBytes(e));
        }
        if (message.data.length !== 0) {
            obj.data = base64FromBytes(message.data);
        }
        if (message.sigHash.length !== 0) {
            obj.sigHash = base64FromBytes(message.sigHash);
        }
        if (message.status !== 0) {
            obj.status = batchedCommandsStatusToJSON(message.status);
        }
        if (message.keyId !== "") {
            obj.keyId = message.keyId;
        }
        if (message.prevBatchedCommandsId.length !== 0) {
            obj.prevBatchedCommandsId = base64FromBytes(message.prevBatchedCommandsId);
        }
        if (message.signature !== undefined) {
            obj.signature = any_1.Any.toJSON(message.signature);
        }
        return obj;
    },
    create(base) {
        return exports.CommandBatchMetadata.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g;
        const message = createBaseCommandBatchMetadata();
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : Buffer.alloc(0);
        message.commandIds = ((_b = object.commandIds) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        message.data = (_c = object.data) !== null && _c !== void 0 ? _c : Buffer.alloc(0);
        message.sigHash = (_d = object.sigHash) !== null && _d !== void 0 ? _d : Buffer.alloc(0);
        message.status = (_e = object.status) !== null && _e !== void 0 ? _e : 0;
        message.keyId = (_f = object.keyId) !== null && _f !== void 0 ? _f : "";
        message.prevBatchedCommandsId = (_g = object.prevBatchedCommandsId) !== null && _g !== void 0 ? _g : Buffer.alloc(0);
        message.signature =
            object.signature !== undefined && object.signature !== null
                ? any_1.Any.fromPartial(object.signature)
                : undefined;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.CommandBatchMetadata.$type, exports.CommandBatchMetadata);
function createBaseSigMetadata() {
    return { $type: "axelar.evm.v1beta1.SigMetadata", type: 0, chain: "", commandBatchId: Buffer.alloc(0) };
}
exports.SigMetadata = {
    $type: "axelar.evm.v1beta1.SigMetadata",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.type !== 0) {
            writer.uint32(8).int32(message.type);
        }
        if (message.chain !== "") {
            writer.uint32(18).string(message.chain);
        }
        if (message.commandBatchId.length !== 0) {
            writer.uint32(26).bytes(message.commandBatchId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSigMetadata();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.type = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.chain = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.commandBatchId = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.SigMetadata.$type,
            type: isSet(object.type) ? sigTypeFromJSON(object.type) : 0,
            chain: isSet(object.chain) ? gt.String(object.chain) : "",
            commandBatchId: isSet(object.commandBatchId)
                ? Buffer.from(bytesFromBase64(object.commandBatchId))
                : Buffer.alloc(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.type !== 0) {
            obj.type = sigTypeToJSON(message.type);
        }
        if (message.chain !== "") {
            obj.chain = message.chain;
        }
        if (message.commandBatchId.length !== 0) {
            obj.commandBatchId = base64FromBytes(message.commandBatchId);
        }
        return obj;
    },
    create(base) {
        return exports.SigMetadata.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseSigMetadata();
        message.type = (_a = object.type) !== null && _a !== void 0 ? _a : 0;
        message.chain = (_b = object.chain) !== null && _b !== void 0 ? _b : "";
        message.commandBatchId = (_c = object.commandBatchId) !== null && _c !== void 0 ? _c : Buffer.alloc(0);
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.SigMetadata.$type, exports.SigMetadata);
function createBaseTransferKey() {
    return { $type: "axelar.evm.v1beta1.TransferKey", txId: Buffer.alloc(0), nextKeyId: "" };
}
exports.TransferKey = {
    $type: "axelar.evm.v1beta1.TransferKey",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.txId.length !== 0) {
            writer.uint32(10).bytes(message.txId);
        }
        if (message.nextKeyId !== "") {
            writer.uint32(26).string(message.nextKeyId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransferKey();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.txId = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.nextKeyId = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.TransferKey.$type,
            txId: isSet(object.txId) ? Buffer.from(bytesFromBase64(object.txId)) : Buffer.alloc(0),
            nextKeyId: isSet(object.nextKeyId) ? gt.String(object.nextKeyId) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.txId.length !== 0) {
            obj.txId = base64FromBytes(message.txId);
        }
        if (message.nextKeyId !== "") {
            obj.nextKeyId = message.nextKeyId;
        }
        return obj;
    },
    create(base) {
        return exports.TransferKey.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseTransferKey();
        message.txId = (_a = object.txId) !== null && _a !== void 0 ? _a : Buffer.alloc(0);
        message.nextKeyId = (_b = object.nextKeyId) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.TransferKey.$type, exports.TransferKey);
function createBaseAsset() {
    return { $type: "axelar.evm.v1beta1.Asset", chain: "", name: "" };
}
exports.Asset = {
    $type: "axelar.evm.v1beta1.Asset",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.chain !== "") {
            writer.uint32(10).string(message.chain);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAsset();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.chain = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.Asset.$type,
            chain: isSet(object.chain) ? gt.String(object.chain) : "",
            name: isSet(object.name) ? gt.String(object.name) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.chain !== "") {
            obj.chain = message.chain;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        return obj;
    },
    create(base) {
        return exports.Asset.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseAsset();
        message.chain = (_a = object.chain) !== null && _a !== void 0 ? _a : "";
        message.name = (_b = object.name) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.Asset.$type, exports.Asset);
function createBaseTokenDetails() {
    return {
        $type: "axelar.evm.v1beta1.TokenDetails",
        tokenName: "",
        symbol: "",
        decimals: 0,
        capacity: Buffer.alloc(0),
    };
}
exports.TokenDetails = {
    $type: "axelar.evm.v1beta1.TokenDetails",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.tokenName !== "") {
            writer.uint32(10).string(message.tokenName);
        }
        if (message.symbol !== "") {
            writer.uint32(18).string(message.symbol);
        }
        if (message.decimals !== 0) {
            writer.uint32(24).uint32(message.decimals);
        }
        if (message.capacity.length !== 0) {
            writer.uint32(34).bytes(message.capacity);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTokenDetails();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.tokenName = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.symbol = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.decimals = reader.uint32();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.capacity = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.TokenDetails.$type,
            tokenName: isSet(object.tokenName) ? gt.String(object.tokenName) : "",
            symbol: isSet(object.symbol) ? gt.String(object.symbol) : "",
            decimals: isSet(object.decimals) ? gt.Number(object.decimals) : 0,
            capacity: isSet(object.capacity) ? Buffer.from(bytesFromBase64(object.capacity)) : Buffer.alloc(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.tokenName !== "") {
            obj.tokenName = message.tokenName;
        }
        if (message.symbol !== "") {
            obj.symbol = message.symbol;
        }
        if (message.decimals !== 0) {
            obj.decimals = Math.round(message.decimals);
        }
        if (message.capacity.length !== 0) {
            obj.capacity = base64FromBytes(message.capacity);
        }
        return obj;
    },
    create(base) {
        return exports.TokenDetails.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseTokenDetails();
        message.tokenName = (_a = object.tokenName) !== null && _a !== void 0 ? _a : "";
        message.symbol = (_b = object.symbol) !== null && _b !== void 0 ? _b : "";
        message.decimals = (_c = object.decimals) !== null && _c !== void 0 ? _c : 0;
        message.capacity = (_d = object.capacity) !== null && _d !== void 0 ? _d : Buffer.alloc(0);
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.TokenDetails.$type, exports.TokenDetails);
function createBaseGateway() {
    return { $type: "axelar.evm.v1beta1.Gateway", address: Buffer.alloc(0) };
}
exports.Gateway = {
    $type: "axelar.evm.v1beta1.Gateway",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address.length !== 0) {
            writer.uint32(10).bytes(message.address);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGateway();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.Gateway.$type,
            address: isSet(object.address) ? Buffer.from(bytesFromBase64(object.address)) : Buffer.alloc(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.address.length !== 0) {
            obj.address = base64FromBytes(message.address);
        }
        return obj;
    },
    create(base) {
        return exports.Gateway.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseGateway();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : Buffer.alloc(0);
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.Gateway.$type, exports.Gateway);
function createBasePollMetadata() {
    return { $type: "axelar.evm.v1beta1.PollMetadata", chain: "", txId: Buffer.alloc(0) };
}
exports.PollMetadata = {
    $type: "axelar.evm.v1beta1.PollMetadata",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.chain !== "") {
            writer.uint32(10).string(message.chain);
        }
        if (message.txId.length !== 0) {
            writer.uint32(18).bytes(message.txId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePollMetadata();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.chain = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.txId = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.PollMetadata.$type,
            chain: isSet(object.chain) ? gt.String(object.chain) : "",
            txId: isSet(object.txId) ? Buffer.from(bytesFromBase64(object.txId)) : Buffer.alloc(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.chain !== "") {
            obj.chain = message.chain;
        }
        if (message.txId.length !== 0) {
            obj.txId = base64FromBytes(message.txId);
        }
        return obj;
    },
    create(base) {
        return exports.PollMetadata.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBasePollMetadata();
        message.chain = (_a = object.chain) !== null && _a !== void 0 ? _a : "";
        message.txId = (_b = object.txId) !== null && _b !== void 0 ? _b : Buffer.alloc(0);
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.PollMetadata.$type, exports.PollMetadata);
const gt = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    return Uint8Array.from(gt.Buffer.from(b64, "base64"));
}
function base64FromBytes(arr) {
    return gt.Buffer.from(arr).toString("base64");
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=types.js.map