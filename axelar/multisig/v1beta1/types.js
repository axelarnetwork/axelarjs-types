"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: axelar/multisig/v1beta1/types.proto
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyEpoch = exports.SigningSession = exports.MultiSig_SigsEntry = exports.MultiSig = exports.KeygenSession_IsPubKeyReceivedEntry = exports.KeygenSession = exports.Key_PubKeysEntry = exports.Key = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const any_1 = require("../../../google/protobuf/any");
const types_1 = require("../../snapshot/exported/v1beta1/types");
const threshold_1 = require("../../utils/v1beta1/threshold");
const types_2 = require("../exported/v1beta1/types");
exports.protobufPackage = "axelar.multisig.v1beta1";
function createBaseKey() {
    return { id: "", snapshot: undefined, pubKeys: {}, signingThreshold: undefined, state: 0 };
}
exports.Key = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.snapshot !== undefined) {
            types_1.Snapshot.encode(message.snapshot, writer.uint32(18).fork()).ldelim();
        }
        Object.entries(message.pubKeys).forEach(([key, value]) => {
            exports.Key_PubKeysEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();
        });
        if (message.signingThreshold !== undefined) {
            threshold_1.Threshold.encode(message.signingThreshold, writer.uint32(34).fork()).ldelim();
        }
        if (message.state !== 0) {
            writer.uint32(40).int32(message.state);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseKey();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.snapshot = types_1.Snapshot.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    const entry3 = exports.Key_PubKeysEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.pubKeys[entry3.key] = entry3.value;
                    }
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.signingThreshold = threshold_1.Threshold.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.state = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? gt.String(object.id) : "",
            snapshot: isSet(object.snapshot) ? types_1.Snapshot.fromJSON(object.snapshot) : undefined,
            pubKeys: isObject(object.pubKeys)
                ? Object.entries(object.pubKeys).reduce((acc, [key, value]) => {
                    acc[key] = Buffer.from(bytesFromBase64(value));
                    return acc;
                }, {})
                : {},
            signingThreshold: isSet(object.signingThreshold)
                ? threshold_1.Threshold.fromJSON(object.signingThreshold)
                : undefined,
            state: isSet(object.state) ? (0, types_2.keyStateFromJSON)(object.state) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.snapshot !== undefined) {
            obj.snapshot = types_1.Snapshot.toJSON(message.snapshot);
        }
        if (message.pubKeys) {
            const entries = Object.entries(message.pubKeys);
            if (entries.length > 0) {
                obj.pubKeys = {};
                entries.forEach(([k, v]) => {
                    obj.pubKeys[k] = base64FromBytes(v);
                });
            }
        }
        if (message.signingThreshold !== undefined) {
            obj.signingThreshold = threshold_1.Threshold.toJSON(message.signingThreshold);
        }
        if (message.state !== 0) {
            obj.state = (0, types_2.keyStateToJSON)(message.state);
        }
        return obj;
    },
    create(base) {
        return exports.Key.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseKey();
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
        message.snapshot =
            object.snapshot !== undefined && object.snapshot !== null
                ? types_1.Snapshot.fromPartial(object.snapshot)
                : undefined;
        message.pubKeys = Object.entries((_b = object.pubKeys) !== null && _b !== void 0 ? _b : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = value;
            }
            return acc;
        }, {});
        message.signingThreshold =
            object.signingThreshold !== undefined && object.signingThreshold !== null
                ? threshold_1.Threshold.fromPartial(object.signingThreshold)
                : undefined;
        message.state = (_c = object.state) !== null && _c !== void 0 ? _c : 0;
        return message;
    },
};
function createBaseKey_PubKeysEntry() {
    return { key: "", value: Buffer.alloc(0) };
}
exports.Key_PubKeysEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value.length !== 0) {
            writer.uint32(18).bytes(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseKey_PubKeysEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? gt.String(object.key) : "",
            value: isSet(object.value) ? Buffer.from(bytesFromBase64(object.value)) : Buffer.alloc(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value.length !== 0) {
            obj.value = base64FromBytes(message.value);
        }
        return obj;
    },
    create(base) {
        return exports.Key_PubKeysEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseKey_PubKeysEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : Buffer.alloc(0);
        return message;
    },
};
function createBaseKeygenSession() {
    return {
        key: undefined,
        state: 0,
        keygenThreshold: undefined,
        expiresAt: long_1.default.ZERO,
        completedAt: long_1.default.ZERO,
        isPubKeyReceived: {},
        gracePeriod: long_1.default.ZERO,
    };
}
exports.KeygenSession = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== undefined) {
            exports.Key.encode(message.key, writer.uint32(10).fork()).ldelim();
        }
        if (message.state !== 0) {
            writer.uint32(16).int32(message.state);
        }
        if (message.keygenThreshold !== undefined) {
            threshold_1.Threshold.encode(message.keygenThreshold, writer.uint32(26).fork()).ldelim();
        }
        if (!message.expiresAt.equals(long_1.default.ZERO)) {
            writer.uint32(32).int64(message.expiresAt);
        }
        if (!message.completedAt.equals(long_1.default.ZERO)) {
            writer.uint32(40).int64(message.completedAt);
        }
        Object.entries(message.isPubKeyReceived).forEach(([key, value]) => {
            exports.KeygenSession_IsPubKeyReceivedEntry.encode({ key: key, value }, writer.uint32(50).fork()).ldelim();
        });
        if (!message.gracePeriod.equals(long_1.default.ZERO)) {
            writer.uint32(56).int64(message.gracePeriod);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseKeygenSession();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = exports.Key.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.state = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.keygenThreshold = threshold_1.Threshold.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.expiresAt = reader.int64();
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.completedAt = reader.int64();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    const entry6 = exports.KeygenSession_IsPubKeyReceivedEntry.decode(reader, reader.uint32());
                    if (entry6.value !== undefined) {
                        message.isPubKeyReceived[entry6.key] = entry6.value;
                    }
                    continue;
                case 7:
                    if (tag !== 56) {
                        break;
                    }
                    message.gracePeriod = reader.int64();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? exports.Key.fromJSON(object.key) : undefined,
            state: isSet(object.state) ? (0, types_2.multisigStateFromJSON)(object.state) : 0,
            keygenThreshold: isSet(object.keygenThreshold) ? threshold_1.Threshold.fromJSON(object.keygenThreshold) : undefined,
            expiresAt: isSet(object.expiresAt) ? long_1.default.fromValue(object.expiresAt) : long_1.default.ZERO,
            completedAt: isSet(object.completedAt) ? long_1.default.fromValue(object.completedAt) : long_1.default.ZERO,
            isPubKeyReceived: isObject(object.isPubKeyReceived)
                ? Object.entries(object.isPubKeyReceived).reduce((acc, [key, value]) => {
                    acc[key] = Boolean(value);
                    return acc;
                }, {})
                : {},
            gracePeriod: isSet(object.gracePeriod) ? long_1.default.fromValue(object.gracePeriod) : long_1.default.ZERO,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== undefined) {
            obj.key = exports.Key.toJSON(message.key);
        }
        if (message.state !== 0) {
            obj.state = (0, types_2.multisigStateToJSON)(message.state);
        }
        if (message.keygenThreshold !== undefined) {
            obj.keygenThreshold = threshold_1.Threshold.toJSON(message.keygenThreshold);
        }
        if (!message.expiresAt.equals(long_1.default.ZERO)) {
            obj.expiresAt = (message.expiresAt || long_1.default.ZERO).toString();
        }
        if (!message.completedAt.equals(long_1.default.ZERO)) {
            obj.completedAt = (message.completedAt || long_1.default.ZERO).toString();
        }
        if (message.isPubKeyReceived) {
            const entries = Object.entries(message.isPubKeyReceived);
            if (entries.length > 0) {
                obj.isPubKeyReceived = {};
                entries.forEach(([k, v]) => {
                    obj.isPubKeyReceived[k] = v;
                });
            }
        }
        if (!message.gracePeriod.equals(long_1.default.ZERO)) {
            obj.gracePeriod = (message.gracePeriod || long_1.default.ZERO).toString();
        }
        return obj;
    },
    create(base) {
        return exports.KeygenSession.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseKeygenSession();
        message.key = object.key !== undefined && object.key !== null ? exports.Key.fromPartial(object.key) : undefined;
        message.state = (_a = object.state) !== null && _a !== void 0 ? _a : 0;
        message.keygenThreshold =
            object.keygenThreshold !== undefined && object.keygenThreshold !== null
                ? threshold_1.Threshold.fromPartial(object.keygenThreshold)
                : undefined;
        message.expiresAt =
            object.expiresAt !== undefined && object.expiresAt !== null
                ? long_1.default.fromValue(object.expiresAt)
                : long_1.default.ZERO;
        message.completedAt =
            object.completedAt !== undefined && object.completedAt !== null
                ? long_1.default.fromValue(object.completedAt)
                : long_1.default.ZERO;
        message.isPubKeyReceived = Object.entries((_b = object.isPubKeyReceived) !== null && _b !== void 0 ? _b : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = gt.Boolean(value);
            }
            return acc;
        }, {});
        message.gracePeriod =
            object.gracePeriod !== undefined && object.gracePeriod !== null
                ? long_1.default.fromValue(object.gracePeriod)
                : long_1.default.ZERO;
        return message;
    },
};
function createBaseKeygenSession_IsPubKeyReceivedEntry() {
    return { key: "", value: false };
}
exports.KeygenSession_IsPubKeyReceivedEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== false) {
            writer.uint32(16).bool(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseKeygenSession_IsPubKeyReceivedEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.value = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? gt.String(object.key) : "",
            value: isSet(object.value) ? gt.Boolean(object.value) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== false) {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return exports.KeygenSession_IsPubKeyReceivedEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseKeygenSession_IsPubKeyReceivedEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : false;
        return message;
    },
};
function createBaseMultiSig() {
    return { keyId: "", payloadHash: Buffer.alloc(0), sigs: {} };
}
exports.MultiSig = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.keyId !== "") {
            writer.uint32(10).string(message.keyId);
        }
        if (message.payloadHash.length !== 0) {
            writer.uint32(18).bytes(message.payloadHash);
        }
        Object.entries(message.sigs).forEach(([key, value]) => {
            exports.MultiSig_SigsEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMultiSig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.keyId = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.payloadHash = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    const entry3 = exports.MultiSig_SigsEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.sigs[entry3.key] = entry3.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            keyId: isSet(object.keyId) ? gt.String(object.keyId) : "",
            payloadHash: isSet(object.payloadHash)
                ? Buffer.from(bytesFromBase64(object.payloadHash))
                : Buffer.alloc(0),
            sigs: isObject(object.sigs)
                ? Object.entries(object.sigs).reduce((acc, [key, value]) => {
                    acc[key] = Buffer.from(bytesFromBase64(value));
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.keyId !== "") {
            obj.keyId = message.keyId;
        }
        if (message.payloadHash.length !== 0) {
            obj.payloadHash = base64FromBytes(message.payloadHash);
        }
        if (message.sigs) {
            const entries = Object.entries(message.sigs);
            if (entries.length > 0) {
                obj.sigs = {};
                entries.forEach(([k, v]) => {
                    obj.sigs[k] = base64FromBytes(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return exports.MultiSig.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMultiSig();
        message.keyId = (_a = object.keyId) !== null && _a !== void 0 ? _a : "";
        message.payloadHash = (_b = object.payloadHash) !== null && _b !== void 0 ? _b : Buffer.alloc(0);
        message.sigs = Object.entries((_c = object.sigs) !== null && _c !== void 0 ? _c : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = value;
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseMultiSig_SigsEntry() {
    return { key: "", value: Buffer.alloc(0) };
}
exports.MultiSig_SigsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value.length !== 0) {
            writer.uint32(18).bytes(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMultiSig_SigsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? gt.String(object.key) : "",
            value: isSet(object.value) ? Buffer.from(bytesFromBase64(object.value)) : Buffer.alloc(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value.length !== 0) {
            obj.value = base64FromBytes(message.value);
        }
        return obj;
    },
    create(base) {
        return exports.MultiSig_SigsEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMultiSig_SigsEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : Buffer.alloc(0);
        return message;
    },
};
function createBaseSigningSession() {
    return {
        id: long_1.default.UZERO,
        multiSig: undefined,
        state: 0,
        key: undefined,
        expiresAt: long_1.default.ZERO,
        completedAt: long_1.default.ZERO,
        gracePeriod: long_1.default.ZERO,
        module: "",
        moduleMetadata: undefined,
    };
}
exports.SigningSession = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.id.equals(long_1.default.UZERO)) {
            writer.uint32(8).uint64(message.id);
        }
        if (message.multiSig !== undefined) {
            exports.MultiSig.encode(message.multiSig, writer.uint32(18).fork()).ldelim();
        }
        if (message.state !== 0) {
            writer.uint32(24).int32(message.state);
        }
        if (message.key !== undefined) {
            exports.Key.encode(message.key, writer.uint32(34).fork()).ldelim();
        }
        if (!message.expiresAt.equals(long_1.default.ZERO)) {
            writer.uint32(40).int64(message.expiresAt);
        }
        if (!message.completedAt.equals(long_1.default.ZERO)) {
            writer.uint32(48).int64(message.completedAt);
        }
        if (!message.gracePeriod.equals(long_1.default.ZERO)) {
            writer.uint32(56).int64(message.gracePeriod);
        }
        if (message.module !== "") {
            writer.uint32(66).string(message.module);
        }
        if (message.moduleMetadata !== undefined) {
            any_1.Any.encode(message.moduleMetadata, writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSigningSession();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.id = reader.uint64();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.multiSig = exports.MultiSig.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.state = reader.int32();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.key = exports.Key.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.expiresAt = reader.int64();
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.completedAt = reader.int64();
                    continue;
                case 7:
                    if (tag !== 56) {
                        break;
                    }
                    message.gracePeriod = reader.int64();
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.module = reader.string();
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.moduleMetadata = any_1.Any.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? long_1.default.fromValue(object.id) : long_1.default.UZERO,
            multiSig: isSet(object.multiSig) ? exports.MultiSig.fromJSON(object.multiSig) : undefined,
            state: isSet(object.state) ? (0, types_2.multisigStateFromJSON)(object.state) : 0,
            key: isSet(object.key) ? exports.Key.fromJSON(object.key) : undefined,
            expiresAt: isSet(object.expiresAt) ? long_1.default.fromValue(object.expiresAt) : long_1.default.ZERO,
            completedAt: isSet(object.completedAt) ? long_1.default.fromValue(object.completedAt) : long_1.default.ZERO,
            gracePeriod: isSet(object.gracePeriod) ? long_1.default.fromValue(object.gracePeriod) : long_1.default.ZERO,
            module: isSet(object.module) ? gt.String(object.module) : "",
            moduleMetadata: isSet(object.moduleMetadata) ? any_1.Any.fromJSON(object.moduleMetadata) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (!message.id.equals(long_1.default.UZERO)) {
            obj.id = (message.id || long_1.default.UZERO).toString();
        }
        if (message.multiSig !== undefined) {
            obj.multiSig = exports.MultiSig.toJSON(message.multiSig);
        }
        if (message.state !== 0) {
            obj.state = (0, types_2.multisigStateToJSON)(message.state);
        }
        if (message.key !== undefined) {
            obj.key = exports.Key.toJSON(message.key);
        }
        if (!message.expiresAt.equals(long_1.default.ZERO)) {
            obj.expiresAt = (message.expiresAt || long_1.default.ZERO).toString();
        }
        if (!message.completedAt.equals(long_1.default.ZERO)) {
            obj.completedAt = (message.completedAt || long_1.default.ZERO).toString();
        }
        if (!message.gracePeriod.equals(long_1.default.ZERO)) {
            obj.gracePeriod = (message.gracePeriod || long_1.default.ZERO).toString();
        }
        if (message.module !== "") {
            obj.module = message.module;
        }
        if (message.moduleMetadata !== undefined) {
            obj.moduleMetadata = any_1.Any.toJSON(message.moduleMetadata);
        }
        return obj;
    },
    create(base) {
        return exports.SigningSession.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseSigningSession();
        message.id = object.id !== undefined && object.id !== null ? long_1.default.fromValue(object.id) : long_1.default.UZERO;
        message.multiSig =
            object.multiSig !== undefined && object.multiSig !== null
                ? exports.MultiSig.fromPartial(object.multiSig)
                : undefined;
        message.state = (_a = object.state) !== null && _a !== void 0 ? _a : 0;
        message.key = object.key !== undefined && object.key !== null ? exports.Key.fromPartial(object.key) : undefined;
        message.expiresAt =
            object.expiresAt !== undefined && object.expiresAt !== null
                ? long_1.default.fromValue(object.expiresAt)
                : long_1.default.ZERO;
        message.completedAt =
            object.completedAt !== undefined && object.completedAt !== null
                ? long_1.default.fromValue(object.completedAt)
                : long_1.default.ZERO;
        message.gracePeriod =
            object.gracePeriod !== undefined && object.gracePeriod !== null
                ? long_1.default.fromValue(object.gracePeriod)
                : long_1.default.ZERO;
        message.module = (_b = object.module) !== null && _b !== void 0 ? _b : "";
        message.moduleMetadata =
            object.moduleMetadata !== undefined && object.moduleMetadata !== null
                ? any_1.Any.fromPartial(object.moduleMetadata)
                : undefined;
        return message;
    },
};
function createBaseKeyEpoch() {
    return { epoch: long_1.default.UZERO, chain: "", keyId: "" };
}
exports.KeyEpoch = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.epoch.equals(long_1.default.UZERO)) {
            writer.uint32(8).uint64(message.epoch);
        }
        if (message.chain !== "") {
            writer.uint32(18).string(message.chain);
        }
        if (message.keyId !== "") {
            writer.uint32(26).string(message.keyId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseKeyEpoch();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.epoch = reader.uint64();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.chain = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.keyId = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            epoch: isSet(object.epoch) ? long_1.default.fromValue(object.epoch) : long_1.default.UZERO,
            chain: isSet(object.chain) ? gt.String(object.chain) : "",
            keyId: isSet(object.keyId) ? gt.String(object.keyId) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (!message.epoch.equals(long_1.default.UZERO)) {
            obj.epoch = (message.epoch || long_1.default.UZERO).toString();
        }
        if (message.chain !== "") {
            obj.chain = message.chain;
        }
        if (message.keyId !== "") {
            obj.keyId = message.keyId;
        }
        return obj;
    },
    create(base) {
        return exports.KeyEpoch.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseKeyEpoch();
        message.epoch =
            object.epoch !== undefined && object.epoch !== null ? long_1.default.fromValue(object.epoch) : long_1.default.UZERO;
        message.chain = (_a = object.chain) !== null && _a !== void 0 ? _a : "";
        message.keyId = (_b = object.keyId) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
const gt = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    return Uint8Array.from(gt.Buffer.from(b64, "base64"));
}
function base64FromBytes(arr) {
    return gt.Buffer.from(arr).toString("base64");
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=types.js.map