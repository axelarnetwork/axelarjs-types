"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.31.1
// source: axelar/snapshot/exported/v1beta1/types.proto
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Snapshot_ParticipantsEntry = exports.Snapshot = exports.Participant = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const timestamp_1 = require("../../../../google/protobuf/timestamp");
const typeRegistry_1 = require("../../../../typeRegistry");
exports.protobufPackage = "axelar.snapshot.exported.v1beta1";
function createBaseParticipant() {
    return {
        $type: "axelar.snapshot.exported.v1beta1.Participant",
        address: Buffer.alloc(0),
        weight: Buffer.alloc(0),
    };
}
exports.Participant = {
    $type: "axelar.snapshot.exported.v1beta1.Participant",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address.length !== 0) {
            writer.uint32(10).bytes(message.address);
        }
        if (message.weight.length !== 0) {
            writer.uint32(18).bytes(message.weight);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParticipant();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.weight = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.Participant.$type,
            address: isSet(object.address) ? Buffer.from(bytesFromBase64(object.address)) : Buffer.alloc(0),
            weight: isSet(object.weight) ? Buffer.from(bytesFromBase64(object.weight)) : Buffer.alloc(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.address.length !== 0) {
            obj.address = base64FromBytes(message.address);
        }
        if (message.weight.length !== 0) {
            obj.weight = base64FromBytes(message.weight);
        }
        return obj;
    },
    create(base) {
        return exports.Participant.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseParticipant();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : Buffer.alloc(0);
        message.weight = (_b = object.weight) !== null && _b !== void 0 ? _b : Buffer.alloc(0);
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.Participant.$type, exports.Participant);
function createBaseSnapshot() {
    return {
        $type: "axelar.snapshot.exported.v1beta1.Snapshot",
        timestamp: undefined,
        height: long_1.default.ZERO,
        participants: {},
        bondedWeight: Buffer.alloc(0),
    };
}
exports.Snapshot = {
    $type: "axelar.snapshot.exported.v1beta1.Snapshot",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.timestamp !== undefined) {
            timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(18).fork()).ldelim();
        }
        if (!message.height.equals(long_1.default.ZERO)) {
            writer.uint32(24).int64(message.height);
        }
        Object.entries(message.participants).forEach(([key, value]) => {
            exports.Snapshot_ParticipantsEntry.encode({
                $type: "axelar.snapshot.exported.v1beta1.Snapshot.ParticipantsEntry",
                key: key,
                value,
            }, writer.uint32(66).fork()).ldelim();
        });
        if (message.bondedWeight.length !== 0) {
            writer.uint32(74).bytes(message.bondedWeight);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSnapshot();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.height = reader.int64();
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    const entry8 = exports.Snapshot_ParticipantsEntry.decode(reader, reader.uint32());
                    if (entry8.value !== undefined) {
                        message.participants[entry8.key] = entry8.value;
                    }
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.bondedWeight = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.Snapshot.$type,
            timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
            height: isSet(object.height) ? long_1.default.fromValue(object.height) : long_1.default.ZERO,
            participants: isObject(object.participants)
                ? Object.entries(object.participants).reduce((acc, [key, value]) => {
                    acc[key] = exports.Participant.fromJSON(value);
                    return acc;
                }, {})
                : {},
            bondedWeight: isSet(object.bondedWeight)
                ? Buffer.from(bytesFromBase64(object.bondedWeight))
                : Buffer.alloc(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.timestamp !== undefined) {
            obj.timestamp = fromTimestamp(message.timestamp).toISOString();
        }
        if (!message.height.equals(long_1.default.ZERO)) {
            obj.height = (message.height || long_1.default.ZERO).toString();
        }
        if (message.participants) {
            const entries = Object.entries(message.participants);
            if (entries.length > 0) {
                obj.participants = {};
                entries.forEach(([k, v]) => {
                    obj.participants[k] = exports.Participant.toJSON(v);
                });
            }
        }
        if (message.bondedWeight.length !== 0) {
            obj.bondedWeight = base64FromBytes(message.bondedWeight);
        }
        return obj;
    },
    create(base) {
        return exports.Snapshot.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseSnapshot();
        message.timestamp =
            object.timestamp !== undefined && object.timestamp !== null
                ? timestamp_1.Timestamp.fromPartial(object.timestamp)
                : undefined;
        message.height =
            object.height !== undefined && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.ZERO;
        message.participants = Object.entries((_a = object.participants) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = exports.Participant.fromPartial(value);
            }
            return acc;
        }, {});
        message.bondedWeight = (_b = object.bondedWeight) !== null && _b !== void 0 ? _b : Buffer.alloc(0);
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.Snapshot.$type, exports.Snapshot);
function createBaseSnapshot_ParticipantsEntry() {
    return { $type: "axelar.snapshot.exported.v1beta1.Snapshot.ParticipantsEntry", key: "", value: undefined };
}
exports.Snapshot_ParticipantsEntry = {
    $type: "axelar.snapshot.exported.v1beta1.Snapshot.ParticipantsEntry",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.Participant.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSnapshot_ParticipantsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = exports.Participant.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.Snapshot_ParticipantsEntry.$type,
            key: isSet(object.key) ? gt.String(object.key) : "",
            value: isSet(object.value) ? exports.Participant.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = exports.Participant.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return exports.Snapshot_ParticipantsEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseSnapshot_ParticipantsEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value =
            object.value !== undefined && object.value !== null ? exports.Participant.fromPartial(object.value) : undefined;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.Snapshot_ParticipantsEntry.$type, exports.Snapshot_ParticipantsEntry);
const gt = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    return Uint8Array.from(gt.Buffer.from(b64, "base64"));
}
function base64FromBytes(arr) {
    return gt.Buffer.from(arr).toString("base64");
}
function toTimestamp(date) {
    const seconds = numberToLong(Math.trunc(date.getTime() / 1000));
    const nanos = (date.getTime() % 1000) * 1000000;
    return { $type: "google.protobuf.Timestamp", seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (t.seconds.toNumber() || 0) * 1000;
    millis += (t.nanos || 0) / 1000000;
    return new gt.Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof gt.Date) {
        return toTimestamp(o);
    }
    else if (typeof o === "string") {
        return toTimestamp(new gt.Date(o));
    }
    else {
        return timestamp_1.Timestamp.fromJSON(o);
    }
}
function numberToLong(number) {
    return long_1.default.fromNumber(number);
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=types.js.map