"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.31.1
// source: axelar/tss/tofnd/v1beta1/tofnd.proto
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignInit = exports.KeygenInit = exports.TrafficOut = exports.TrafficIn = exports.MessageOut_CriminalList_Criminal = exports.MessageOut_CriminalList = exports.MessageOut_SignResult = exports.MessageOut_KeygenResult = exports.MessageOut = exports.MessageIn = exports.KeygenOutput = exports.RecoverResponse = exports.RecoverRequest = exports.messageOut_CriminalList_Criminal_CrimeTypeToJSON = exports.messageOut_CriminalList_Criminal_CrimeTypeFromJSON = exports.MessageOut_CriminalList_Criminal_CrimeType = exports.recoverResponse_ResponseToJSON = exports.recoverResponse_ResponseFromJSON = exports.RecoverResponse_Response = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const typeRegistry_1 = require("../../../../typeRegistry");
exports.protobufPackage = "axelar.tss.tofnd.v1beta1";
var RecoverResponse_Response;
(function (RecoverResponse_Response) {
    RecoverResponse_Response[RecoverResponse_Response["RESPONSE_UNSPECIFIED"] = 0] = "RESPONSE_UNSPECIFIED";
    RecoverResponse_Response[RecoverResponse_Response["RESPONSE_SUCCESS"] = 1] = "RESPONSE_SUCCESS";
    RecoverResponse_Response[RecoverResponse_Response["RESPONSE_FAIL"] = 2] = "RESPONSE_FAIL";
    RecoverResponse_Response[RecoverResponse_Response["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(RecoverResponse_Response = exports.RecoverResponse_Response || (exports.RecoverResponse_Response = {}));
function recoverResponse_ResponseFromJSON(object) {
    switch (object) {
        case 0:
        case "RESPONSE_UNSPECIFIED":
            return RecoverResponse_Response.RESPONSE_UNSPECIFIED;
        case 1:
        case "RESPONSE_SUCCESS":
            return RecoverResponse_Response.RESPONSE_SUCCESS;
        case 2:
        case "RESPONSE_FAIL":
            return RecoverResponse_Response.RESPONSE_FAIL;
        case -1:
        case "UNRECOGNIZED":
        default:
            return RecoverResponse_Response.UNRECOGNIZED;
    }
}
exports.recoverResponse_ResponseFromJSON = recoverResponse_ResponseFromJSON;
function recoverResponse_ResponseToJSON(object) {
    switch (object) {
        case RecoverResponse_Response.RESPONSE_UNSPECIFIED:
            return "RESPONSE_UNSPECIFIED";
        case RecoverResponse_Response.RESPONSE_SUCCESS:
            return "RESPONSE_SUCCESS";
        case RecoverResponse_Response.RESPONSE_FAIL:
            return "RESPONSE_FAIL";
        case RecoverResponse_Response.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.recoverResponse_ResponseToJSON = recoverResponse_ResponseToJSON;
var MessageOut_CriminalList_Criminal_CrimeType;
(function (MessageOut_CriminalList_Criminal_CrimeType) {
    MessageOut_CriminalList_Criminal_CrimeType[MessageOut_CriminalList_Criminal_CrimeType["CRIME_TYPE_UNSPECIFIED"] = 0] = "CRIME_TYPE_UNSPECIFIED";
    MessageOut_CriminalList_Criminal_CrimeType[MessageOut_CriminalList_Criminal_CrimeType["CRIME_TYPE_NON_MALICIOUS"] = 1] = "CRIME_TYPE_NON_MALICIOUS";
    MessageOut_CriminalList_Criminal_CrimeType[MessageOut_CriminalList_Criminal_CrimeType["CRIME_TYPE_MALICIOUS"] = 2] = "CRIME_TYPE_MALICIOUS";
    MessageOut_CriminalList_Criminal_CrimeType[MessageOut_CriminalList_Criminal_CrimeType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(MessageOut_CriminalList_Criminal_CrimeType = exports.MessageOut_CriminalList_Criminal_CrimeType || (exports.MessageOut_CriminalList_Criminal_CrimeType = {}));
function messageOut_CriminalList_Criminal_CrimeTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "CRIME_TYPE_UNSPECIFIED":
            return MessageOut_CriminalList_Criminal_CrimeType.CRIME_TYPE_UNSPECIFIED;
        case 1:
        case "CRIME_TYPE_NON_MALICIOUS":
            return MessageOut_CriminalList_Criminal_CrimeType.CRIME_TYPE_NON_MALICIOUS;
        case 2:
        case "CRIME_TYPE_MALICIOUS":
            return MessageOut_CriminalList_Criminal_CrimeType.CRIME_TYPE_MALICIOUS;
        case -1:
        case "UNRECOGNIZED":
        default:
            return MessageOut_CriminalList_Criminal_CrimeType.UNRECOGNIZED;
    }
}
exports.messageOut_CriminalList_Criminal_CrimeTypeFromJSON = messageOut_CriminalList_Criminal_CrimeTypeFromJSON;
function messageOut_CriminalList_Criminal_CrimeTypeToJSON(object) {
    switch (object) {
        case MessageOut_CriminalList_Criminal_CrimeType.CRIME_TYPE_UNSPECIFIED:
            return "CRIME_TYPE_UNSPECIFIED";
        case MessageOut_CriminalList_Criminal_CrimeType.CRIME_TYPE_NON_MALICIOUS:
            return "CRIME_TYPE_NON_MALICIOUS";
        case MessageOut_CriminalList_Criminal_CrimeType.CRIME_TYPE_MALICIOUS:
            return "CRIME_TYPE_MALICIOUS";
        case MessageOut_CriminalList_Criminal_CrimeType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.messageOut_CriminalList_Criminal_CrimeTypeToJSON = messageOut_CriminalList_Criminal_CrimeTypeToJSON;
function createBaseRecoverRequest() {
    return { $type: "axelar.tss.tofnd.v1beta1.RecoverRequest", keygenInit: undefined, keygenOutput: undefined };
}
exports.RecoverRequest = {
    $type: "axelar.tss.tofnd.v1beta1.RecoverRequest",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.keygenInit !== undefined) {
            exports.KeygenInit.encode(message.keygenInit, writer.uint32(10).fork()).ldelim();
        }
        if (message.keygenOutput !== undefined) {
            exports.KeygenOutput.encode(message.keygenOutput, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRecoverRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.keygenInit = exports.KeygenInit.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.keygenOutput = exports.KeygenOutput.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.RecoverRequest.$type,
            keygenInit: isSet(object.keygenInit) ? exports.KeygenInit.fromJSON(object.keygenInit) : undefined,
            keygenOutput: isSet(object.keygenOutput) ? exports.KeygenOutput.fromJSON(object.keygenOutput) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.keygenInit !== undefined) {
            obj.keygenInit = exports.KeygenInit.toJSON(message.keygenInit);
        }
        if (message.keygenOutput !== undefined) {
            obj.keygenOutput = exports.KeygenOutput.toJSON(message.keygenOutput);
        }
        return obj;
    },
    create(base) {
        return exports.RecoverRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseRecoverRequest();
        message.keygenInit =
            object.keygenInit !== undefined && object.keygenInit !== null
                ? exports.KeygenInit.fromPartial(object.keygenInit)
                : undefined;
        message.keygenOutput =
            object.keygenOutput !== undefined && object.keygenOutput !== null
                ? exports.KeygenOutput.fromPartial(object.keygenOutput)
                : undefined;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.RecoverRequest.$type, exports.RecoverRequest);
function createBaseRecoverResponse() {
    return { $type: "axelar.tss.tofnd.v1beta1.RecoverResponse", response: 0 };
}
exports.RecoverResponse = {
    $type: "axelar.tss.tofnd.v1beta1.RecoverResponse",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.response !== 0) {
            writer.uint32(8).int32(message.response);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRecoverResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.response = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.RecoverResponse.$type,
            response: isSet(object.response) ? recoverResponse_ResponseFromJSON(object.response) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.response !== 0) {
            obj.response = recoverResponse_ResponseToJSON(message.response);
        }
        return obj;
    },
    create(base) {
        return exports.RecoverResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseRecoverResponse();
        message.response = (_a = object.response) !== null && _a !== void 0 ? _a : 0;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.RecoverResponse.$type, exports.RecoverResponse);
function createBaseKeygenOutput() {
    return {
        $type: "axelar.tss.tofnd.v1beta1.KeygenOutput",
        pubKey: Buffer.alloc(0),
        groupRecoverInfo: Buffer.alloc(0),
        privateRecoverInfo: Buffer.alloc(0),
    };
}
exports.KeygenOutput = {
    $type: "axelar.tss.tofnd.v1beta1.KeygenOutput",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pubKey.length !== 0) {
            writer.uint32(10).bytes(message.pubKey);
        }
        if (message.groupRecoverInfo.length !== 0) {
            writer.uint32(18).bytes(message.groupRecoverInfo);
        }
        if (message.privateRecoverInfo.length !== 0) {
            writer.uint32(26).bytes(message.privateRecoverInfo);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseKeygenOutput();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pubKey = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.groupRecoverInfo = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.privateRecoverInfo = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.KeygenOutput.$type,
            pubKey: isSet(object.pubKey) ? Buffer.from(bytesFromBase64(object.pubKey)) : Buffer.alloc(0),
            groupRecoverInfo: isSet(object.groupRecoverInfo)
                ? Buffer.from(bytesFromBase64(object.groupRecoverInfo))
                : Buffer.alloc(0),
            privateRecoverInfo: isSet(object.privateRecoverInfo)
                ? Buffer.from(bytesFromBase64(object.privateRecoverInfo))
                : Buffer.alloc(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.pubKey.length !== 0) {
            obj.pubKey = base64FromBytes(message.pubKey);
        }
        if (message.groupRecoverInfo.length !== 0) {
            obj.groupRecoverInfo = base64FromBytes(message.groupRecoverInfo);
        }
        if (message.privateRecoverInfo.length !== 0) {
            obj.privateRecoverInfo = base64FromBytes(message.privateRecoverInfo);
        }
        return obj;
    },
    create(base) {
        return exports.KeygenOutput.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseKeygenOutput();
        message.pubKey = (_a = object.pubKey) !== null && _a !== void 0 ? _a : Buffer.alloc(0);
        message.groupRecoverInfo = (_b = object.groupRecoverInfo) !== null && _b !== void 0 ? _b : Buffer.alloc(0);
        message.privateRecoverInfo = (_c = object.privateRecoverInfo) !== null && _c !== void 0 ? _c : Buffer.alloc(0);
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.KeygenOutput.$type, exports.KeygenOutput);
function createBaseMessageIn() {
    return {
        $type: "axelar.tss.tofnd.v1beta1.MessageIn",
        keygenInit: undefined,
        signInit: undefined,
        traffic: undefined,
        abort: undefined,
    };
}
exports.MessageIn = {
    $type: "axelar.tss.tofnd.v1beta1.MessageIn",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.keygenInit !== undefined) {
            exports.KeygenInit.encode(message.keygenInit, writer.uint32(10).fork()).ldelim();
        }
        if (message.signInit !== undefined) {
            exports.SignInit.encode(message.signInit, writer.uint32(18).fork()).ldelim();
        }
        if (message.traffic !== undefined) {
            exports.TrafficIn.encode(message.traffic, writer.uint32(26).fork()).ldelim();
        }
        if (message.abort !== undefined) {
            writer.uint32(32).bool(message.abort);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMessageIn();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.keygenInit = exports.KeygenInit.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.signInit = exports.SignInit.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.traffic = exports.TrafficIn.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.abort = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.MessageIn.$type,
            keygenInit: isSet(object.keygenInit) ? exports.KeygenInit.fromJSON(object.keygenInit) : undefined,
            signInit: isSet(object.signInit) ? exports.SignInit.fromJSON(object.signInit) : undefined,
            traffic: isSet(object.traffic) ? exports.TrafficIn.fromJSON(object.traffic) : undefined,
            abort: isSet(object.abort) ? gt.Boolean(object.abort) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.keygenInit !== undefined) {
            obj.keygenInit = exports.KeygenInit.toJSON(message.keygenInit);
        }
        if (message.signInit !== undefined) {
            obj.signInit = exports.SignInit.toJSON(message.signInit);
        }
        if (message.traffic !== undefined) {
            obj.traffic = exports.TrafficIn.toJSON(message.traffic);
        }
        if (message.abort !== undefined) {
            obj.abort = message.abort;
        }
        return obj;
    },
    create(base) {
        return exports.MessageIn.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMessageIn();
        message.keygenInit =
            object.keygenInit !== undefined && object.keygenInit !== null
                ? exports.KeygenInit.fromPartial(object.keygenInit)
                : undefined;
        message.signInit =
            object.signInit !== undefined && object.signInit !== null
                ? exports.SignInit.fromPartial(object.signInit)
                : undefined;
        message.traffic =
            object.traffic !== undefined && object.traffic !== null
                ? exports.TrafficIn.fromPartial(object.traffic)
                : undefined;
        message.abort = (_a = object.abort) !== null && _a !== void 0 ? _a : undefined;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.MessageIn.$type, exports.MessageIn);
function createBaseMessageOut() {
    return {
        $type: "axelar.tss.tofnd.v1beta1.MessageOut",
        traffic: undefined,
        keygenResult: undefined,
        signResult: undefined,
        needRecover: undefined,
    };
}
exports.MessageOut = {
    $type: "axelar.tss.tofnd.v1beta1.MessageOut",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.traffic !== undefined) {
            exports.TrafficOut.encode(message.traffic, writer.uint32(10).fork()).ldelim();
        }
        if (message.keygenResult !== undefined) {
            exports.MessageOut_KeygenResult.encode(message.keygenResult, writer.uint32(18).fork()).ldelim();
        }
        if (message.signResult !== undefined) {
            exports.MessageOut_SignResult.encode(message.signResult, writer.uint32(26).fork()).ldelim();
        }
        if (message.needRecover !== undefined) {
            writer.uint32(32).bool(message.needRecover);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMessageOut();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.traffic = exports.TrafficOut.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.keygenResult = exports.MessageOut_KeygenResult.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.signResult = exports.MessageOut_SignResult.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.needRecover = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.MessageOut.$type,
            traffic: isSet(object.traffic) ? exports.TrafficOut.fromJSON(object.traffic) : undefined,
            keygenResult: isSet(object.keygenResult)
                ? exports.MessageOut_KeygenResult.fromJSON(object.keygenResult)
                : undefined,
            signResult: isSet(object.signResult) ? exports.MessageOut_SignResult.fromJSON(object.signResult) : undefined,
            needRecover: isSet(object.needRecover) ? gt.Boolean(object.needRecover) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.traffic !== undefined) {
            obj.traffic = exports.TrafficOut.toJSON(message.traffic);
        }
        if (message.keygenResult !== undefined) {
            obj.keygenResult = exports.MessageOut_KeygenResult.toJSON(message.keygenResult);
        }
        if (message.signResult !== undefined) {
            obj.signResult = exports.MessageOut_SignResult.toJSON(message.signResult);
        }
        if (message.needRecover !== undefined) {
            obj.needRecover = message.needRecover;
        }
        return obj;
    },
    create(base) {
        return exports.MessageOut.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMessageOut();
        message.traffic =
            object.traffic !== undefined && object.traffic !== null
                ? exports.TrafficOut.fromPartial(object.traffic)
                : undefined;
        message.keygenResult =
            object.keygenResult !== undefined && object.keygenResult !== null
                ? exports.MessageOut_KeygenResult.fromPartial(object.keygenResult)
                : undefined;
        message.signResult =
            object.signResult !== undefined && object.signResult !== null
                ? exports.MessageOut_SignResult.fromPartial(object.signResult)
                : undefined;
        message.needRecover = (_a = object.needRecover) !== null && _a !== void 0 ? _a : undefined;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.MessageOut.$type, exports.MessageOut);
function createBaseMessageOut_KeygenResult() {
    return { $type: "axelar.tss.tofnd.v1beta1.MessageOut.KeygenResult", data: undefined, criminals: undefined };
}
exports.MessageOut_KeygenResult = {
    $type: "axelar.tss.tofnd.v1beta1.MessageOut.KeygenResult",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.data !== undefined) {
            exports.KeygenOutput.encode(message.data, writer.uint32(10).fork()).ldelim();
        }
        if (message.criminals !== undefined) {
            exports.MessageOut_CriminalList.encode(message.criminals, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMessageOut_KeygenResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.data = exports.KeygenOutput.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.criminals = exports.MessageOut_CriminalList.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.MessageOut_KeygenResult.$type,
            data: isSet(object.data) ? exports.KeygenOutput.fromJSON(object.data) : undefined,
            criminals: isSet(object.criminals) ? exports.MessageOut_CriminalList.fromJSON(object.criminals) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.data !== undefined) {
            obj.data = exports.KeygenOutput.toJSON(message.data);
        }
        if (message.criminals !== undefined) {
            obj.criminals = exports.MessageOut_CriminalList.toJSON(message.criminals);
        }
        return obj;
    },
    create(base) {
        return exports.MessageOut_KeygenResult.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseMessageOut_KeygenResult();
        message.data =
            object.data !== undefined && object.data !== null ? exports.KeygenOutput.fromPartial(object.data) : undefined;
        message.criminals =
            object.criminals !== undefined && object.criminals !== null
                ? exports.MessageOut_CriminalList.fromPartial(object.criminals)
                : undefined;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.MessageOut_KeygenResult.$type, exports.MessageOut_KeygenResult);
function createBaseMessageOut_SignResult() {
    return {
        $type: "axelar.tss.tofnd.v1beta1.MessageOut.SignResult",
        signature: undefined,
        criminals: undefined,
    };
}
exports.MessageOut_SignResult = {
    $type: "axelar.tss.tofnd.v1beta1.MessageOut.SignResult",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.signature !== undefined) {
            writer.uint32(10).bytes(message.signature);
        }
        if (message.criminals !== undefined) {
            exports.MessageOut_CriminalList.encode(message.criminals, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMessageOut_SignResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.signature = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.criminals = exports.MessageOut_CriminalList.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.MessageOut_SignResult.$type,
            signature: isSet(object.signature) ? Buffer.from(bytesFromBase64(object.signature)) : undefined,
            criminals: isSet(object.criminals) ? exports.MessageOut_CriminalList.fromJSON(object.criminals) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.signature !== undefined) {
            obj.signature = base64FromBytes(message.signature);
        }
        if (message.criminals !== undefined) {
            obj.criminals = exports.MessageOut_CriminalList.toJSON(message.criminals);
        }
        return obj;
    },
    create(base) {
        return exports.MessageOut_SignResult.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMessageOut_SignResult();
        message.signature = (_a = object.signature) !== null && _a !== void 0 ? _a : undefined;
        message.criminals =
            object.criminals !== undefined && object.criminals !== null
                ? exports.MessageOut_CriminalList.fromPartial(object.criminals)
                : undefined;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.MessageOut_SignResult.$type, exports.MessageOut_SignResult);
function createBaseMessageOut_CriminalList() {
    return { $type: "axelar.tss.tofnd.v1beta1.MessageOut.CriminalList", criminals: [] };
}
exports.MessageOut_CriminalList = {
    $type: "axelar.tss.tofnd.v1beta1.MessageOut.CriminalList",
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.criminals) {
            exports.MessageOut_CriminalList_Criminal.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMessageOut_CriminalList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.criminals.push(exports.MessageOut_CriminalList_Criminal.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.MessageOut_CriminalList.$type,
            criminals: gt.Array.isArray(object === null || object === void 0 ? void 0 : object.criminals)
                ? object.criminals.map((e) => exports.MessageOut_CriminalList_Criminal.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        var _a;
        const obj = {};
        if ((_a = message.criminals) === null || _a === void 0 ? void 0 : _a.length) {
            obj.criminals = message.criminals.map((e) => exports.MessageOut_CriminalList_Criminal.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.MessageOut_CriminalList.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMessageOut_CriminalList();
        message.criminals = ((_a = object.criminals) === null || _a === void 0 ? void 0 : _a.map((e) => exports.MessageOut_CriminalList_Criminal.fromPartial(e))) || [];
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.MessageOut_CriminalList.$type, exports.MessageOut_CriminalList);
function createBaseMessageOut_CriminalList_Criminal() {
    return { $type: "axelar.tss.tofnd.v1beta1.MessageOut.CriminalList.Criminal", partyUid: "", crimeType: 0 };
}
exports.MessageOut_CriminalList_Criminal = {
    $type: "axelar.tss.tofnd.v1beta1.MessageOut.CriminalList.Criminal",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.partyUid !== "") {
            writer.uint32(10).string(message.partyUid);
        }
        if (message.crimeType !== 0) {
            writer.uint32(16).int32(message.crimeType);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMessageOut_CriminalList_Criminal();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.partyUid = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.crimeType = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.MessageOut_CriminalList_Criminal.$type,
            partyUid: isSet(object.partyUid) ? gt.String(object.partyUid) : "",
            crimeType: isSet(object.crimeType)
                ? messageOut_CriminalList_Criminal_CrimeTypeFromJSON(object.crimeType)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.partyUid !== "") {
            obj.partyUid = message.partyUid;
        }
        if (message.crimeType !== 0) {
            obj.crimeType = messageOut_CriminalList_Criminal_CrimeTypeToJSON(message.crimeType);
        }
        return obj;
    },
    create(base) {
        return exports.MessageOut_CriminalList_Criminal.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMessageOut_CriminalList_Criminal();
        message.partyUid = (_a = object.partyUid) !== null && _a !== void 0 ? _a : "";
        message.crimeType = (_b = object.crimeType) !== null && _b !== void 0 ? _b : 0;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.MessageOut_CriminalList_Criminal.$type, exports.MessageOut_CriminalList_Criminal);
function createBaseTrafficIn() {
    return {
        $type: "axelar.tss.tofnd.v1beta1.TrafficIn",
        fromPartyUid: "",
        payload: Buffer.alloc(0),
        isBroadcast: false,
    };
}
exports.TrafficIn = {
    $type: "axelar.tss.tofnd.v1beta1.TrafficIn",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.fromPartyUid !== "") {
            writer.uint32(10).string(message.fromPartyUid);
        }
        if (message.payload.length !== 0) {
            writer.uint32(18).bytes(message.payload);
        }
        if (message.isBroadcast !== false) {
            writer.uint32(24).bool(message.isBroadcast);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTrafficIn();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.fromPartyUid = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.payload = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.isBroadcast = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.TrafficIn.$type,
            fromPartyUid: isSet(object.fromPartyUid) ? gt.String(object.fromPartyUid) : "",
            payload: isSet(object.payload) ? Buffer.from(bytesFromBase64(object.payload)) : Buffer.alloc(0),
            isBroadcast: isSet(object.isBroadcast) ? gt.Boolean(object.isBroadcast) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.fromPartyUid !== "") {
            obj.fromPartyUid = message.fromPartyUid;
        }
        if (message.payload.length !== 0) {
            obj.payload = base64FromBytes(message.payload);
        }
        if (message.isBroadcast !== false) {
            obj.isBroadcast = message.isBroadcast;
        }
        return obj;
    },
    create(base) {
        return exports.TrafficIn.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseTrafficIn();
        message.fromPartyUid = (_a = object.fromPartyUid) !== null && _a !== void 0 ? _a : "";
        message.payload = (_b = object.payload) !== null && _b !== void 0 ? _b : Buffer.alloc(0);
        message.isBroadcast = (_c = object.isBroadcast) !== null && _c !== void 0 ? _c : false;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.TrafficIn.$type, exports.TrafficIn);
function createBaseTrafficOut() {
    return {
        $type: "axelar.tss.tofnd.v1beta1.TrafficOut",
        toPartyUid: "",
        payload: Buffer.alloc(0),
        isBroadcast: false,
    };
}
exports.TrafficOut = {
    $type: "axelar.tss.tofnd.v1beta1.TrafficOut",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.toPartyUid !== "") {
            writer.uint32(10).string(message.toPartyUid);
        }
        if (message.payload.length !== 0) {
            writer.uint32(18).bytes(message.payload);
        }
        if (message.isBroadcast !== false) {
            writer.uint32(24).bool(message.isBroadcast);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTrafficOut();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.toPartyUid = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.payload = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.isBroadcast = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.TrafficOut.$type,
            toPartyUid: isSet(object.toPartyUid) ? gt.String(object.toPartyUid) : "",
            payload: isSet(object.payload) ? Buffer.from(bytesFromBase64(object.payload)) : Buffer.alloc(0),
            isBroadcast: isSet(object.isBroadcast) ? gt.Boolean(object.isBroadcast) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.toPartyUid !== "") {
            obj.toPartyUid = message.toPartyUid;
        }
        if (message.payload.length !== 0) {
            obj.payload = base64FromBytes(message.payload);
        }
        if (message.isBroadcast !== false) {
            obj.isBroadcast = message.isBroadcast;
        }
        return obj;
    },
    create(base) {
        return exports.TrafficOut.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseTrafficOut();
        message.toPartyUid = (_a = object.toPartyUid) !== null && _a !== void 0 ? _a : "";
        message.payload = (_b = object.payload) !== null && _b !== void 0 ? _b : Buffer.alloc(0);
        message.isBroadcast = (_c = object.isBroadcast) !== null && _c !== void 0 ? _c : false;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.TrafficOut.$type, exports.TrafficOut);
function createBaseKeygenInit() {
    return {
        $type: "axelar.tss.tofnd.v1beta1.KeygenInit",
        newKeyUid: "",
        partyUids: [],
        partyShareCounts: [],
        myPartyIndex: 0,
        threshold: 0,
    };
}
exports.KeygenInit = {
    $type: "axelar.tss.tofnd.v1beta1.KeygenInit",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.newKeyUid !== "") {
            writer.uint32(10).string(message.newKeyUid);
        }
        for (const v of message.partyUids) {
            writer.uint32(18).string(v);
        }
        writer.uint32(42).fork();
        for (const v of message.partyShareCounts) {
            writer.uint32(v);
        }
        writer.ldelim();
        if (message.myPartyIndex !== 0) {
            writer.uint32(24).uint32(message.myPartyIndex);
        }
        if (message.threshold !== 0) {
            writer.uint32(32).uint32(message.threshold);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseKeygenInit();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.newKeyUid = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.partyUids.push(reader.string());
                    continue;
                case 5:
                    if (tag === 40) {
                        message.partyShareCounts.push(reader.uint32());
                        continue;
                    }
                    if (tag === 42) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.partyShareCounts.push(reader.uint32());
                        }
                        continue;
                    }
                    break;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.myPartyIndex = reader.uint32();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.threshold = reader.uint32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.KeygenInit.$type,
            newKeyUid: isSet(object.newKeyUid) ? gt.String(object.newKeyUid) : "",
            partyUids: gt.Array.isArray(object === null || object === void 0 ? void 0 : object.partyUids) ? object.partyUids.map((e) => gt.String(e)) : [],
            partyShareCounts: gt.Array.isArray(object === null || object === void 0 ? void 0 : object.partyShareCounts)
                ? object.partyShareCounts.map((e) => gt.Number(e))
                : [],
            myPartyIndex: isSet(object.myPartyIndex) ? gt.Number(object.myPartyIndex) : 0,
            threshold: isSet(object.threshold) ? gt.Number(object.threshold) : 0,
        };
    },
    toJSON(message) {
        var _a, _b;
        const obj = {};
        if (message.newKeyUid !== "") {
            obj.newKeyUid = message.newKeyUid;
        }
        if ((_a = message.partyUids) === null || _a === void 0 ? void 0 : _a.length) {
            obj.partyUids = message.partyUids;
        }
        if ((_b = message.partyShareCounts) === null || _b === void 0 ? void 0 : _b.length) {
            obj.partyShareCounts = message.partyShareCounts.map((e) => Math.round(e));
        }
        if (message.myPartyIndex !== 0) {
            obj.myPartyIndex = Math.round(message.myPartyIndex);
        }
        if (message.threshold !== 0) {
            obj.threshold = Math.round(message.threshold);
        }
        return obj;
    },
    create(base) {
        return exports.KeygenInit.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseKeygenInit();
        message.newKeyUid = (_a = object.newKeyUid) !== null && _a !== void 0 ? _a : "";
        message.partyUids = ((_b = object.partyUids) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        message.partyShareCounts = ((_c = object.partyShareCounts) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        message.myPartyIndex = (_d = object.myPartyIndex) !== null && _d !== void 0 ? _d : 0;
        message.threshold = (_e = object.threshold) !== null && _e !== void 0 ? _e : 0;
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.KeygenInit.$type, exports.KeygenInit);
function createBaseSignInit() {
    return {
        $type: "axelar.tss.tofnd.v1beta1.SignInit",
        newSigUid: "",
        keyUid: "",
        partyUids: [],
        messageToSign: Buffer.alloc(0),
    };
}
exports.SignInit = {
    $type: "axelar.tss.tofnd.v1beta1.SignInit",
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.newSigUid !== "") {
            writer.uint32(10).string(message.newSigUid);
        }
        if (message.keyUid !== "") {
            writer.uint32(18).string(message.keyUid);
        }
        for (const v of message.partyUids) {
            writer.uint32(26).string(v);
        }
        if (message.messageToSign.length !== 0) {
            writer.uint32(34).bytes(message.messageToSign);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignInit();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.newSigUid = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.keyUid = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.partyUids.push(reader.string());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.messageToSign = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            $type: exports.SignInit.$type,
            newSigUid: isSet(object.newSigUid) ? gt.String(object.newSigUid) : "",
            keyUid: isSet(object.keyUid) ? gt.String(object.keyUid) : "",
            partyUids: gt.Array.isArray(object === null || object === void 0 ? void 0 : object.partyUids) ? object.partyUids.map((e) => gt.String(e)) : [],
            messageToSign: isSet(object.messageToSign)
                ? Buffer.from(bytesFromBase64(object.messageToSign))
                : Buffer.alloc(0),
        };
    },
    toJSON(message) {
        var _a;
        const obj = {};
        if (message.newSigUid !== "") {
            obj.newSigUid = message.newSigUid;
        }
        if (message.keyUid !== "") {
            obj.keyUid = message.keyUid;
        }
        if ((_a = message.partyUids) === null || _a === void 0 ? void 0 : _a.length) {
            obj.partyUids = message.partyUids;
        }
        if (message.messageToSign.length !== 0) {
            obj.messageToSign = base64FromBytes(message.messageToSign);
        }
        return obj;
    },
    create(base) {
        return exports.SignInit.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseSignInit();
        message.newSigUid = (_a = object.newSigUid) !== null && _a !== void 0 ? _a : "";
        message.keyUid = (_b = object.keyUid) !== null && _b !== void 0 ? _b : "";
        message.partyUids = ((_c = object.partyUids) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        message.messageToSign = (_d = object.messageToSign) !== null && _d !== void 0 ? _d : Buffer.alloc(0);
        return message;
    },
};
typeRegistry_1.messageTypeRegistry.set(exports.SignInit.$type, exports.SignInit);
const gt = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    return Uint8Array.from(gt.Buffer.from(b64, "base64"));
}
function base64FromBytes(arr) {
    return gt.Buffer.from(arr).toString("base64");
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=tofnd.js.map