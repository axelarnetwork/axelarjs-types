// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: axelar/evm/v1beta1/tx.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { messageTypeRegistry } from "../../../typeRegistry";
import { KeyType, keyTypeFromJSON, keyTypeToJSON } from "../../tss/exported/v1beta1/types";
import { Params } from "./params";
import { Asset, TokenDetails } from "./types";

export const protobufPackage = "axelar.evm.v1beta1";

export interface SetGatewayRequest {
  $type: "axelar.evm.v1beta1.SetGatewayRequest";
  chain: string;
  address: Buffer;
  sender: string;
}

export interface SetGatewayResponse {
  $type: "axelar.evm.v1beta1.SetGatewayResponse";
}

/** @deprecated */
export interface ConfirmGatewayTxRequest {
  $type: "axelar.evm.v1beta1.ConfirmGatewayTxRequest";
  chain: string;
  txId: Buffer;
  sender: string;
}

/** @deprecated */
export interface ConfirmGatewayTxResponse {
  $type: "axelar.evm.v1beta1.ConfirmGatewayTxResponse";
}

export interface ConfirmGatewayTxsRequest {
  $type: "axelar.evm.v1beta1.ConfirmGatewayTxsRequest";
  chain: string;
  txIds: Buffer[];
  sender: string;
}

export interface ConfirmGatewayTxsResponse {
  $type: "axelar.evm.v1beta1.ConfirmGatewayTxsResponse";
}

/** MsgConfirmDeposit represents an erc20 deposit confirmation message */
export interface ConfirmDepositRequest {
  $type: "axelar.evm.v1beta1.ConfirmDepositRequest";
  chain: string;
  txId: Buffer;
  /** @deprecated */
  amount: Buffer;
  burnerAddress: Buffer;
  sender: string;
}

export interface ConfirmDepositResponse {
  $type: "axelar.evm.v1beta1.ConfirmDepositResponse";
}

/** MsgConfirmToken represents a token deploy confirmation message */
export interface ConfirmTokenRequest {
  $type: "axelar.evm.v1beta1.ConfirmTokenRequest";
  chain: string;
  txId: Buffer;
  asset?: Asset | undefined;
  sender: string;
}

export interface ConfirmTokenResponse {
  $type: "axelar.evm.v1beta1.ConfirmTokenResponse";
}

export interface ConfirmTransferKeyRequest {
  $type: "axelar.evm.v1beta1.ConfirmTransferKeyRequest";
  chain: string;
  txId: Buffer;
  sender: string;
}

export interface ConfirmTransferKeyResponse {
  $type: "axelar.evm.v1beta1.ConfirmTransferKeyResponse";
}

/**
 * MsgLink represents the message that links a cross chain address to a burner
 * address
 */
export interface LinkRequest {
  $type: "axelar.evm.v1beta1.LinkRequest";
  chain: string;
  recipientAddr: string;
  asset: string;
  recipientChain: string;
  sender: string;
}

export interface LinkResponse {
  $type: "axelar.evm.v1beta1.LinkResponse";
  depositAddr: string;
}

/**
 * CreateBurnTokensRequest represents the message to create commands to burn
 * tokens with AxelarGateway
 */
export interface CreateBurnTokensRequest {
  $type: "axelar.evm.v1beta1.CreateBurnTokensRequest";
  chain: string;
  sender: string;
}

export interface CreateBurnTokensResponse {
  $type: "axelar.evm.v1beta1.CreateBurnTokensResponse";
}

/**
 * CreateDeployTokenRequest represents the message to create a deploy token
 * command for AxelarGateway
 */
export interface CreateDeployTokenRequest {
  $type: "axelar.evm.v1beta1.CreateDeployTokenRequest";
  chain: string;
  asset?: Asset | undefined;
  tokenDetails?: TokenDetails | undefined;
  address: Buffer;
  dailyMintLimit: string;
  sender: string;
}

export interface CreateDeployTokenResponse {
  $type: "axelar.evm.v1beta1.CreateDeployTokenResponse";
}

/**
 * CreatePendingTransfersRequest represents a message to trigger the creation of
 * commands handling all pending transfers
 */
export interface CreatePendingTransfersRequest {
  $type: "axelar.evm.v1beta1.CreatePendingTransfersRequest";
  chain: string;
  sender: string;
}

export interface CreatePendingTransfersResponse {
  $type: "axelar.evm.v1beta1.CreatePendingTransfersResponse";
}

/** @deprecated */
export interface CreateTransferOwnershipRequest {
  $type: "axelar.evm.v1beta1.CreateTransferOwnershipRequest";
  chain: string;
  keyId: string;
  sender: string;
}

/** @deprecated */
export interface CreateTransferOwnershipResponse {
  $type: "axelar.evm.v1beta1.CreateTransferOwnershipResponse";
}

export interface CreateTransferOperatorshipRequest {
  $type: "axelar.evm.v1beta1.CreateTransferOperatorshipRequest";
  chain: string;
  keyId: string;
  sender: string;
}

export interface CreateTransferOperatorshipResponse {
  $type: "axelar.evm.v1beta1.CreateTransferOperatorshipResponse";
}

export interface SignCommandsRequest {
  $type: "axelar.evm.v1beta1.SignCommandsRequest";
  chain: string;
  sender: string;
}

export interface SignCommandsResponse {
  $type: "axelar.evm.v1beta1.SignCommandsResponse";
  batchedCommandsId: Buffer;
  commandCount: number;
}

export interface AddChainRequest {
  $type: "axelar.evm.v1beta1.AddChainRequest";
  name: string;
  /** @deprecated */
  keyType: KeyType;
  params: Buffer;
  sender: string;
}

export interface AddChainResponse {
  $type: "axelar.evm.v1beta1.AddChainResponse";
}

export interface RetryFailedEventRequest {
  $type: "axelar.evm.v1beta1.RetryFailedEventRequest";
  chain: string;
  eventId: string;
  sender: string;
}

export interface RetryFailedEventResponse {
  $type: "axelar.evm.v1beta1.RetryFailedEventResponse";
}

export interface UpdateParamsRequest {
  $type: "axelar.evm.v1beta1.UpdateParamsRequest";
  authority: string;
  params?: Params | undefined;
}

export interface UpdateParamsResponse {
  $type: "axelar.evm.v1beta1.UpdateParamsResponse";
}

function createBaseSetGatewayRequest(): SetGatewayRequest {
  return { $type: "axelar.evm.v1beta1.SetGatewayRequest", chain: "", address: Buffer.alloc(0), sender: "" };
}

export const SetGatewayRequest = {
  $type: "axelar.evm.v1beta1.SetGatewayRequest" as const,

  encode(message: SetGatewayRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    if (message.address.length !== 0) {
      writer.uint32(26).bytes(message.address);
    }
    if (message.sender !== "") {
      writer.uint32(34).string(message.sender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetGatewayRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetGatewayRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.address = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sender = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetGatewayRequest {
    return {
      $type: SetGatewayRequest.$type,
      chain: isSet(object.chain) ? gt.String(object.chain) : "",
      address: isSet(object.address) ? Buffer.from(bytesFromBase64(object.address)) : Buffer.alloc(0),
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
    };
  },

  toJSON(message: SetGatewayRequest): unknown {
    const obj: any = {};
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetGatewayRequest>, I>>(base?: I): SetGatewayRequest {
    return SetGatewayRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetGatewayRequest>, I>>(object: I): SetGatewayRequest {
    const message = createBaseSetGatewayRequest();
    message.chain = object.chain ?? "";
    message.address = object.address ?? Buffer.alloc(0);
    message.sender = object.sender ?? "";
    return message;
  },
};

messageTypeRegistry.set(SetGatewayRequest.$type, SetGatewayRequest);

function createBaseSetGatewayResponse(): SetGatewayResponse {
  return { $type: "axelar.evm.v1beta1.SetGatewayResponse" };
}

export const SetGatewayResponse = {
  $type: "axelar.evm.v1beta1.SetGatewayResponse" as const,

  encode(_: SetGatewayResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetGatewayResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetGatewayResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SetGatewayResponse {
    return { $type: SetGatewayResponse.$type };
  },

  toJSON(_: SetGatewayResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SetGatewayResponse>, I>>(base?: I): SetGatewayResponse {
    return SetGatewayResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetGatewayResponse>, I>>(_: I): SetGatewayResponse {
    const message = createBaseSetGatewayResponse();
    return message;
  },
};

messageTypeRegistry.set(SetGatewayResponse.$type, SetGatewayResponse);

function createBaseConfirmGatewayTxRequest(): ConfirmGatewayTxRequest {
  return {
    $type: "axelar.evm.v1beta1.ConfirmGatewayTxRequest",
    chain: "",
    txId: Buffer.alloc(0),
    sender: "",
  };
}

export const ConfirmGatewayTxRequest = {
  $type: "axelar.evm.v1beta1.ConfirmGatewayTxRequest" as const,

  encode(message: ConfirmGatewayTxRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    if (message.txId.length !== 0) {
      writer.uint32(26).bytes(message.txId);
    }
    if (message.sender !== "") {
      writer.uint32(34).string(message.sender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ConfirmGatewayTxRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfirmGatewayTxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.txId = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sender = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfirmGatewayTxRequest {
    return {
      $type: ConfirmGatewayTxRequest.$type,
      chain: isSet(object.chain) ? gt.String(object.chain) : "",
      txId: isSet(object.txId) ? Buffer.from(bytesFromBase64(object.txId)) : Buffer.alloc(0),
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
    };
  },

  toJSON(message: ConfirmGatewayTxRequest): unknown {
    const obj: any = {};
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfirmGatewayTxRequest>, I>>(base?: I): ConfirmGatewayTxRequest {
    return ConfirmGatewayTxRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfirmGatewayTxRequest>, I>>(object: I): ConfirmGatewayTxRequest {
    const message = createBaseConfirmGatewayTxRequest();
    message.chain = object.chain ?? "";
    message.txId = object.txId ?? Buffer.alloc(0);
    message.sender = object.sender ?? "";
    return message;
  },
};

messageTypeRegistry.set(ConfirmGatewayTxRequest.$type, ConfirmGatewayTxRequest);

function createBaseConfirmGatewayTxResponse(): ConfirmGatewayTxResponse {
  return { $type: "axelar.evm.v1beta1.ConfirmGatewayTxResponse" };
}

export const ConfirmGatewayTxResponse = {
  $type: "axelar.evm.v1beta1.ConfirmGatewayTxResponse" as const,

  encode(_: ConfirmGatewayTxResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ConfirmGatewayTxResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfirmGatewayTxResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ConfirmGatewayTxResponse {
    return { $type: ConfirmGatewayTxResponse.$type };
  },

  toJSON(_: ConfirmGatewayTxResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfirmGatewayTxResponse>, I>>(base?: I): ConfirmGatewayTxResponse {
    return ConfirmGatewayTxResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfirmGatewayTxResponse>, I>>(_: I): ConfirmGatewayTxResponse {
    const message = createBaseConfirmGatewayTxResponse();
    return message;
  },
};

messageTypeRegistry.set(ConfirmGatewayTxResponse.$type, ConfirmGatewayTxResponse);

function createBaseConfirmGatewayTxsRequest(): ConfirmGatewayTxsRequest {
  return { $type: "axelar.evm.v1beta1.ConfirmGatewayTxsRequest", chain: "", txIds: [], sender: "" };
}

export const ConfirmGatewayTxsRequest = {
  $type: "axelar.evm.v1beta1.ConfirmGatewayTxsRequest" as const,

  encode(message: ConfirmGatewayTxsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    for (const v of message.txIds) {
      writer.uint32(26).bytes(v!);
    }
    if (message.sender !== "") {
      writer.uint32(34).string(message.sender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ConfirmGatewayTxsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfirmGatewayTxsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.txIds.push(reader.bytes() as Buffer);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sender = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfirmGatewayTxsRequest {
    return {
      $type: ConfirmGatewayTxsRequest.$type,
      chain: isSet(object.chain) ? gt.String(object.chain) : "",
      txIds: gt.Array.isArray(object?.txIds)
        ? object.txIds.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
    };
  },

  toJSON(message: ConfirmGatewayTxsRequest): unknown {
    const obj: any = {};
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.txIds?.length) {
      obj.txIds = message.txIds.map((e) => base64FromBytes(e));
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfirmGatewayTxsRequest>, I>>(base?: I): ConfirmGatewayTxsRequest {
    return ConfirmGatewayTxsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfirmGatewayTxsRequest>, I>>(
    object: I,
  ): ConfirmGatewayTxsRequest {
    const message = createBaseConfirmGatewayTxsRequest();
    message.chain = object.chain ?? "";
    message.txIds = object.txIds?.map((e) => e) || [];
    message.sender = object.sender ?? "";
    return message;
  },
};

messageTypeRegistry.set(ConfirmGatewayTxsRequest.$type, ConfirmGatewayTxsRequest);

function createBaseConfirmGatewayTxsResponse(): ConfirmGatewayTxsResponse {
  return { $type: "axelar.evm.v1beta1.ConfirmGatewayTxsResponse" };
}

export const ConfirmGatewayTxsResponse = {
  $type: "axelar.evm.v1beta1.ConfirmGatewayTxsResponse" as const,

  encode(_: ConfirmGatewayTxsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ConfirmGatewayTxsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfirmGatewayTxsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ConfirmGatewayTxsResponse {
    return { $type: ConfirmGatewayTxsResponse.$type };
  },

  toJSON(_: ConfirmGatewayTxsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfirmGatewayTxsResponse>, I>>(base?: I): ConfirmGatewayTxsResponse {
    return ConfirmGatewayTxsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfirmGatewayTxsResponse>, I>>(_: I): ConfirmGatewayTxsResponse {
    const message = createBaseConfirmGatewayTxsResponse();
    return message;
  },
};

messageTypeRegistry.set(ConfirmGatewayTxsResponse.$type, ConfirmGatewayTxsResponse);

function createBaseConfirmDepositRequest(): ConfirmDepositRequest {
  return {
    $type: "axelar.evm.v1beta1.ConfirmDepositRequest",
    chain: "",
    txId: Buffer.alloc(0),
    amount: Buffer.alloc(0),
    burnerAddress: Buffer.alloc(0),
    sender: "",
  };
}

export const ConfirmDepositRequest = {
  $type: "axelar.evm.v1beta1.ConfirmDepositRequest" as const,

  encode(message: ConfirmDepositRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    if (message.txId.length !== 0) {
      writer.uint32(26).bytes(message.txId);
    }
    if (message.amount.length !== 0) {
      writer.uint32(34).bytes(message.amount);
    }
    if (message.burnerAddress.length !== 0) {
      writer.uint32(42).bytes(message.burnerAddress);
    }
    if (message.sender !== "") {
      writer.uint32(50).string(message.sender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ConfirmDepositRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfirmDepositRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.txId = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.amount = reader.bytes() as Buffer;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.burnerAddress = reader.bytes() as Buffer;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sender = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfirmDepositRequest {
    return {
      $type: ConfirmDepositRequest.$type,
      chain: isSet(object.chain) ? gt.String(object.chain) : "",
      txId: isSet(object.txId) ? Buffer.from(bytesFromBase64(object.txId)) : Buffer.alloc(0),
      amount: isSet(object.amount) ? Buffer.from(bytesFromBase64(object.amount)) : Buffer.alloc(0),
      burnerAddress: isSet(object.burnerAddress)
        ? Buffer.from(bytesFromBase64(object.burnerAddress))
        : Buffer.alloc(0),
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
    };
  },

  toJSON(message: ConfirmDepositRequest): unknown {
    const obj: any = {};
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    if (message.burnerAddress.length !== 0) {
      obj.burnerAddress = base64FromBytes(message.burnerAddress);
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfirmDepositRequest>, I>>(base?: I): ConfirmDepositRequest {
    return ConfirmDepositRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfirmDepositRequest>, I>>(object: I): ConfirmDepositRequest {
    const message = createBaseConfirmDepositRequest();
    message.chain = object.chain ?? "";
    message.txId = object.txId ?? Buffer.alloc(0);
    message.amount = object.amount ?? Buffer.alloc(0);
    message.burnerAddress = object.burnerAddress ?? Buffer.alloc(0);
    message.sender = object.sender ?? "";
    return message;
  },
};

messageTypeRegistry.set(ConfirmDepositRequest.$type, ConfirmDepositRequest);

function createBaseConfirmDepositResponse(): ConfirmDepositResponse {
  return { $type: "axelar.evm.v1beta1.ConfirmDepositResponse" };
}

export const ConfirmDepositResponse = {
  $type: "axelar.evm.v1beta1.ConfirmDepositResponse" as const,

  encode(_: ConfirmDepositResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ConfirmDepositResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfirmDepositResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ConfirmDepositResponse {
    return { $type: ConfirmDepositResponse.$type };
  },

  toJSON(_: ConfirmDepositResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfirmDepositResponse>, I>>(base?: I): ConfirmDepositResponse {
    return ConfirmDepositResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfirmDepositResponse>, I>>(_: I): ConfirmDepositResponse {
    const message = createBaseConfirmDepositResponse();
    return message;
  },
};

messageTypeRegistry.set(ConfirmDepositResponse.$type, ConfirmDepositResponse);

function createBaseConfirmTokenRequest(): ConfirmTokenRequest {
  return {
    $type: "axelar.evm.v1beta1.ConfirmTokenRequest",
    chain: "",
    txId: Buffer.alloc(0),
    asset: undefined,
    sender: "",
  };
}

export const ConfirmTokenRequest = {
  $type: "axelar.evm.v1beta1.ConfirmTokenRequest" as const,

  encode(message: ConfirmTokenRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    if (message.txId.length !== 0) {
      writer.uint32(26).bytes(message.txId);
    }
    if (message.asset !== undefined) {
      Asset.encode(message.asset, writer.uint32(34).fork()).ldelim();
    }
    if (message.sender !== "") {
      writer.uint32(42).string(message.sender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ConfirmTokenRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfirmTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.txId = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.asset = Asset.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sender = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfirmTokenRequest {
    return {
      $type: ConfirmTokenRequest.$type,
      chain: isSet(object.chain) ? gt.String(object.chain) : "",
      txId: isSet(object.txId) ? Buffer.from(bytesFromBase64(object.txId)) : Buffer.alloc(0),
      asset: isSet(object.asset) ? Asset.fromJSON(object.asset) : undefined,
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
    };
  },

  toJSON(message: ConfirmTokenRequest): unknown {
    const obj: any = {};
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.asset !== undefined) {
      obj.asset = Asset.toJSON(message.asset);
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfirmTokenRequest>, I>>(base?: I): ConfirmTokenRequest {
    return ConfirmTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfirmTokenRequest>, I>>(object: I): ConfirmTokenRequest {
    const message = createBaseConfirmTokenRequest();
    message.chain = object.chain ?? "";
    message.txId = object.txId ?? Buffer.alloc(0);
    message.asset =
      object.asset !== undefined && object.asset !== null ? Asset.fromPartial(object.asset) : undefined;
    message.sender = object.sender ?? "";
    return message;
  },
};

messageTypeRegistry.set(ConfirmTokenRequest.$type, ConfirmTokenRequest);

function createBaseConfirmTokenResponse(): ConfirmTokenResponse {
  return { $type: "axelar.evm.v1beta1.ConfirmTokenResponse" };
}

export const ConfirmTokenResponse = {
  $type: "axelar.evm.v1beta1.ConfirmTokenResponse" as const,

  encode(_: ConfirmTokenResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ConfirmTokenResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfirmTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ConfirmTokenResponse {
    return { $type: ConfirmTokenResponse.$type };
  },

  toJSON(_: ConfirmTokenResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfirmTokenResponse>, I>>(base?: I): ConfirmTokenResponse {
    return ConfirmTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfirmTokenResponse>, I>>(_: I): ConfirmTokenResponse {
    const message = createBaseConfirmTokenResponse();
    return message;
  },
};

messageTypeRegistry.set(ConfirmTokenResponse.$type, ConfirmTokenResponse);

function createBaseConfirmTransferKeyRequest(): ConfirmTransferKeyRequest {
  return {
    $type: "axelar.evm.v1beta1.ConfirmTransferKeyRequest",
    chain: "",
    txId: Buffer.alloc(0),
    sender: "",
  };
}

export const ConfirmTransferKeyRequest = {
  $type: "axelar.evm.v1beta1.ConfirmTransferKeyRequest" as const,

  encode(message: ConfirmTransferKeyRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    if (message.txId.length !== 0) {
      writer.uint32(26).bytes(message.txId);
    }
    if (message.sender !== "") {
      writer.uint32(50).string(message.sender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ConfirmTransferKeyRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfirmTransferKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.txId = reader.bytes() as Buffer;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sender = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfirmTransferKeyRequest {
    return {
      $type: ConfirmTransferKeyRequest.$type,
      chain: isSet(object.chain) ? gt.String(object.chain) : "",
      txId: isSet(object.txId) ? Buffer.from(bytesFromBase64(object.txId)) : Buffer.alloc(0),
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
    };
  },

  toJSON(message: ConfirmTransferKeyRequest): unknown {
    const obj: any = {};
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfirmTransferKeyRequest>, I>>(base?: I): ConfirmTransferKeyRequest {
    return ConfirmTransferKeyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfirmTransferKeyRequest>, I>>(
    object: I,
  ): ConfirmTransferKeyRequest {
    const message = createBaseConfirmTransferKeyRequest();
    message.chain = object.chain ?? "";
    message.txId = object.txId ?? Buffer.alloc(0);
    message.sender = object.sender ?? "";
    return message;
  },
};

messageTypeRegistry.set(ConfirmTransferKeyRequest.$type, ConfirmTransferKeyRequest);

function createBaseConfirmTransferKeyResponse(): ConfirmTransferKeyResponse {
  return { $type: "axelar.evm.v1beta1.ConfirmTransferKeyResponse" };
}

export const ConfirmTransferKeyResponse = {
  $type: "axelar.evm.v1beta1.ConfirmTransferKeyResponse" as const,

  encode(_: ConfirmTransferKeyResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ConfirmTransferKeyResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfirmTransferKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ConfirmTransferKeyResponse {
    return { $type: ConfirmTransferKeyResponse.$type };
  },

  toJSON(_: ConfirmTransferKeyResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfirmTransferKeyResponse>, I>>(base?: I): ConfirmTransferKeyResponse {
    return ConfirmTransferKeyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfirmTransferKeyResponse>, I>>(_: I): ConfirmTransferKeyResponse {
    const message = createBaseConfirmTransferKeyResponse();
    return message;
  },
};

messageTypeRegistry.set(ConfirmTransferKeyResponse.$type, ConfirmTransferKeyResponse);

function createBaseLinkRequest(): LinkRequest {
  return {
    $type: "axelar.evm.v1beta1.LinkRequest",
    chain: "",
    recipientAddr: "",
    asset: "",
    recipientChain: "",
    sender: "",
  };
}

export const LinkRequest = {
  $type: "axelar.evm.v1beta1.LinkRequest" as const,

  encode(message: LinkRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    if (message.recipientAddr !== "") {
      writer.uint32(26).string(message.recipientAddr);
    }
    if (message.asset !== "") {
      writer.uint32(34).string(message.asset);
    }
    if (message.recipientChain !== "") {
      writer.uint32(42).string(message.recipientChain);
    }
    if (message.sender !== "") {
      writer.uint32(50).string(message.sender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LinkRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.recipientAddr = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.asset = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.recipientChain = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sender = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LinkRequest {
    return {
      $type: LinkRequest.$type,
      chain: isSet(object.chain) ? gt.String(object.chain) : "",
      recipientAddr: isSet(object.recipientAddr) ? gt.String(object.recipientAddr) : "",
      asset: isSet(object.asset) ? gt.String(object.asset) : "",
      recipientChain: isSet(object.recipientChain) ? gt.String(object.recipientChain) : "",
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
    };
  },

  toJSON(message: LinkRequest): unknown {
    const obj: any = {};
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.recipientAddr !== "") {
      obj.recipientAddr = message.recipientAddr;
    }
    if (message.asset !== "") {
      obj.asset = message.asset;
    }
    if (message.recipientChain !== "") {
      obj.recipientChain = message.recipientChain;
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LinkRequest>, I>>(base?: I): LinkRequest {
    return LinkRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkRequest>, I>>(object: I): LinkRequest {
    const message = createBaseLinkRequest();
    message.chain = object.chain ?? "";
    message.recipientAddr = object.recipientAddr ?? "";
    message.asset = object.asset ?? "";
    message.recipientChain = object.recipientChain ?? "";
    message.sender = object.sender ?? "";
    return message;
  },
};

messageTypeRegistry.set(LinkRequest.$type, LinkRequest);

function createBaseLinkResponse(): LinkResponse {
  return { $type: "axelar.evm.v1beta1.LinkResponse", depositAddr: "" };
}

export const LinkResponse = {
  $type: "axelar.evm.v1beta1.LinkResponse" as const,

  encode(message: LinkResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.depositAddr !== "") {
      writer.uint32(10).string(message.depositAddr);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LinkResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.depositAddr = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LinkResponse {
    return {
      $type: LinkResponse.$type,
      depositAddr: isSet(object.depositAddr) ? gt.String(object.depositAddr) : "",
    };
  },

  toJSON(message: LinkResponse): unknown {
    const obj: any = {};
    if (message.depositAddr !== "") {
      obj.depositAddr = message.depositAddr;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LinkResponse>, I>>(base?: I): LinkResponse {
    return LinkResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkResponse>, I>>(object: I): LinkResponse {
    const message = createBaseLinkResponse();
    message.depositAddr = object.depositAddr ?? "";
    return message;
  },
};

messageTypeRegistry.set(LinkResponse.$type, LinkResponse);

function createBaseCreateBurnTokensRequest(): CreateBurnTokensRequest {
  return { $type: "axelar.evm.v1beta1.CreateBurnTokensRequest", chain: "", sender: "" };
}

export const CreateBurnTokensRequest = {
  $type: "axelar.evm.v1beta1.CreateBurnTokensRequest" as const,

  encode(message: CreateBurnTokensRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    if (message.sender !== "") {
      writer.uint32(26).string(message.sender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateBurnTokensRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBurnTokensRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sender = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBurnTokensRequest {
    return {
      $type: CreateBurnTokensRequest.$type,
      chain: isSet(object.chain) ? gt.String(object.chain) : "",
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
    };
  },

  toJSON(message: CreateBurnTokensRequest): unknown {
    const obj: any = {};
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateBurnTokensRequest>, I>>(base?: I): CreateBurnTokensRequest {
    return CreateBurnTokensRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateBurnTokensRequest>, I>>(object: I): CreateBurnTokensRequest {
    const message = createBaseCreateBurnTokensRequest();
    message.chain = object.chain ?? "";
    message.sender = object.sender ?? "";
    return message;
  },
};

messageTypeRegistry.set(CreateBurnTokensRequest.$type, CreateBurnTokensRequest);

function createBaseCreateBurnTokensResponse(): CreateBurnTokensResponse {
  return { $type: "axelar.evm.v1beta1.CreateBurnTokensResponse" };
}

export const CreateBurnTokensResponse = {
  $type: "axelar.evm.v1beta1.CreateBurnTokensResponse" as const,

  encode(_: CreateBurnTokensResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateBurnTokensResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBurnTokensResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CreateBurnTokensResponse {
    return { $type: CreateBurnTokensResponse.$type };
  },

  toJSON(_: CreateBurnTokensResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateBurnTokensResponse>, I>>(base?: I): CreateBurnTokensResponse {
    return CreateBurnTokensResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateBurnTokensResponse>, I>>(_: I): CreateBurnTokensResponse {
    const message = createBaseCreateBurnTokensResponse();
    return message;
  },
};

messageTypeRegistry.set(CreateBurnTokensResponse.$type, CreateBurnTokensResponse);

function createBaseCreateDeployTokenRequest(): CreateDeployTokenRequest {
  return {
    $type: "axelar.evm.v1beta1.CreateDeployTokenRequest",
    chain: "",
    asset: undefined,
    tokenDetails: undefined,
    address: Buffer.alloc(0),
    dailyMintLimit: "",
    sender: "",
  };
}

export const CreateDeployTokenRequest = {
  $type: "axelar.evm.v1beta1.CreateDeployTokenRequest" as const,

  encode(message: CreateDeployTokenRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    if (message.asset !== undefined) {
      Asset.encode(message.asset, writer.uint32(26).fork()).ldelim();
    }
    if (message.tokenDetails !== undefined) {
      TokenDetails.encode(message.tokenDetails, writer.uint32(34).fork()).ldelim();
    }
    if (message.address.length !== 0) {
      writer.uint32(50).bytes(message.address);
    }
    if (message.dailyMintLimit !== "") {
      writer.uint32(58).string(message.dailyMintLimit);
    }
    if (message.sender !== "") {
      writer.uint32(66).string(message.sender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateDeployTokenRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateDeployTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.asset = Asset.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.tokenDetails = TokenDetails.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.address = reader.bytes() as Buffer;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.dailyMintLimit = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.sender = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateDeployTokenRequest {
    return {
      $type: CreateDeployTokenRequest.$type,
      chain: isSet(object.chain) ? gt.String(object.chain) : "",
      asset: isSet(object.asset) ? Asset.fromJSON(object.asset) : undefined,
      tokenDetails: isSet(object.tokenDetails) ? TokenDetails.fromJSON(object.tokenDetails) : undefined,
      address: isSet(object.address) ? Buffer.from(bytesFromBase64(object.address)) : Buffer.alloc(0),
      dailyMintLimit: isSet(object.dailyMintLimit) ? gt.String(object.dailyMintLimit) : "",
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
    };
  },

  toJSON(message: CreateDeployTokenRequest): unknown {
    const obj: any = {};
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.asset !== undefined) {
      obj.asset = Asset.toJSON(message.asset);
    }
    if (message.tokenDetails !== undefined) {
      obj.tokenDetails = TokenDetails.toJSON(message.tokenDetails);
    }
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    if (message.dailyMintLimit !== "") {
      obj.dailyMintLimit = message.dailyMintLimit;
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateDeployTokenRequest>, I>>(base?: I): CreateDeployTokenRequest {
    return CreateDeployTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateDeployTokenRequest>, I>>(
    object: I,
  ): CreateDeployTokenRequest {
    const message = createBaseCreateDeployTokenRequest();
    message.chain = object.chain ?? "";
    message.asset =
      object.asset !== undefined && object.asset !== null ? Asset.fromPartial(object.asset) : undefined;
    message.tokenDetails =
      object.tokenDetails !== undefined && object.tokenDetails !== null
        ? TokenDetails.fromPartial(object.tokenDetails)
        : undefined;
    message.address = object.address ?? Buffer.alloc(0);
    message.dailyMintLimit = object.dailyMintLimit ?? "";
    message.sender = object.sender ?? "";
    return message;
  },
};

messageTypeRegistry.set(CreateDeployTokenRequest.$type, CreateDeployTokenRequest);

function createBaseCreateDeployTokenResponse(): CreateDeployTokenResponse {
  return { $type: "axelar.evm.v1beta1.CreateDeployTokenResponse" };
}

export const CreateDeployTokenResponse = {
  $type: "axelar.evm.v1beta1.CreateDeployTokenResponse" as const,

  encode(_: CreateDeployTokenResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateDeployTokenResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateDeployTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CreateDeployTokenResponse {
    return { $type: CreateDeployTokenResponse.$type };
  },

  toJSON(_: CreateDeployTokenResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateDeployTokenResponse>, I>>(base?: I): CreateDeployTokenResponse {
    return CreateDeployTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateDeployTokenResponse>, I>>(_: I): CreateDeployTokenResponse {
    const message = createBaseCreateDeployTokenResponse();
    return message;
  },
};

messageTypeRegistry.set(CreateDeployTokenResponse.$type, CreateDeployTokenResponse);

function createBaseCreatePendingTransfersRequest(): CreatePendingTransfersRequest {
  return { $type: "axelar.evm.v1beta1.CreatePendingTransfersRequest", chain: "", sender: "" };
}

export const CreatePendingTransfersRequest = {
  $type: "axelar.evm.v1beta1.CreatePendingTransfersRequest" as const,

  encode(message: CreatePendingTransfersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    if (message.sender !== "") {
      writer.uint32(26).string(message.sender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreatePendingTransfersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePendingTransfersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sender = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePendingTransfersRequest {
    return {
      $type: CreatePendingTransfersRequest.$type,
      chain: isSet(object.chain) ? gt.String(object.chain) : "",
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
    };
  },

  toJSON(message: CreatePendingTransfersRequest): unknown {
    const obj: any = {};
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePendingTransfersRequest>, I>>(
    base?: I,
  ): CreatePendingTransfersRequest {
    return CreatePendingTransfersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePendingTransfersRequest>, I>>(
    object: I,
  ): CreatePendingTransfersRequest {
    const message = createBaseCreatePendingTransfersRequest();
    message.chain = object.chain ?? "";
    message.sender = object.sender ?? "";
    return message;
  },
};

messageTypeRegistry.set(CreatePendingTransfersRequest.$type, CreatePendingTransfersRequest);

function createBaseCreatePendingTransfersResponse(): CreatePendingTransfersResponse {
  return { $type: "axelar.evm.v1beta1.CreatePendingTransfersResponse" };
}

export const CreatePendingTransfersResponse = {
  $type: "axelar.evm.v1beta1.CreatePendingTransfersResponse" as const,

  encode(_: CreatePendingTransfersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreatePendingTransfersResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePendingTransfersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CreatePendingTransfersResponse {
    return { $type: CreatePendingTransfersResponse.$type };
  },

  toJSON(_: CreatePendingTransfersResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePendingTransfersResponse>, I>>(
    base?: I,
  ): CreatePendingTransfersResponse {
    return CreatePendingTransfersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePendingTransfersResponse>, I>>(
    _: I,
  ): CreatePendingTransfersResponse {
    const message = createBaseCreatePendingTransfersResponse();
    return message;
  },
};

messageTypeRegistry.set(CreatePendingTransfersResponse.$type, CreatePendingTransfersResponse);

function createBaseCreateTransferOwnershipRequest(): CreateTransferOwnershipRequest {
  return { $type: "axelar.evm.v1beta1.CreateTransferOwnershipRequest", chain: "", keyId: "", sender: "" };
}

export const CreateTransferOwnershipRequest = {
  $type: "axelar.evm.v1beta1.CreateTransferOwnershipRequest" as const,

  encode(message: CreateTransferOwnershipRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    if (message.keyId !== "") {
      writer.uint32(26).string(message.keyId);
    }
    if (message.sender !== "") {
      writer.uint32(34).string(message.sender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateTransferOwnershipRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTransferOwnershipRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.keyId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sender = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTransferOwnershipRequest {
    return {
      $type: CreateTransferOwnershipRequest.$type,
      chain: isSet(object.chain) ? gt.String(object.chain) : "",
      keyId: isSet(object.keyId) ? gt.String(object.keyId) : "",
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
    };
  },

  toJSON(message: CreateTransferOwnershipRequest): unknown {
    const obj: any = {};
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.keyId !== "") {
      obj.keyId = message.keyId;
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateTransferOwnershipRequest>, I>>(
    base?: I,
  ): CreateTransferOwnershipRequest {
    return CreateTransferOwnershipRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateTransferOwnershipRequest>, I>>(
    object: I,
  ): CreateTransferOwnershipRequest {
    const message = createBaseCreateTransferOwnershipRequest();
    message.chain = object.chain ?? "";
    message.keyId = object.keyId ?? "";
    message.sender = object.sender ?? "";
    return message;
  },
};

messageTypeRegistry.set(CreateTransferOwnershipRequest.$type, CreateTransferOwnershipRequest);

function createBaseCreateTransferOwnershipResponse(): CreateTransferOwnershipResponse {
  return { $type: "axelar.evm.v1beta1.CreateTransferOwnershipResponse" };
}

export const CreateTransferOwnershipResponse = {
  $type: "axelar.evm.v1beta1.CreateTransferOwnershipResponse" as const,

  encode(_: CreateTransferOwnershipResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateTransferOwnershipResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTransferOwnershipResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CreateTransferOwnershipResponse {
    return { $type: CreateTransferOwnershipResponse.$type };
  },

  toJSON(_: CreateTransferOwnershipResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateTransferOwnershipResponse>, I>>(
    base?: I,
  ): CreateTransferOwnershipResponse {
    return CreateTransferOwnershipResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateTransferOwnershipResponse>, I>>(
    _: I,
  ): CreateTransferOwnershipResponse {
    const message = createBaseCreateTransferOwnershipResponse();
    return message;
  },
};

messageTypeRegistry.set(CreateTransferOwnershipResponse.$type, CreateTransferOwnershipResponse);

function createBaseCreateTransferOperatorshipRequest(): CreateTransferOperatorshipRequest {
  return { $type: "axelar.evm.v1beta1.CreateTransferOperatorshipRequest", chain: "", keyId: "", sender: "" };
}

export const CreateTransferOperatorshipRequest = {
  $type: "axelar.evm.v1beta1.CreateTransferOperatorshipRequest" as const,

  encode(message: CreateTransferOperatorshipRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    if (message.keyId !== "") {
      writer.uint32(26).string(message.keyId);
    }
    if (message.sender !== "") {
      writer.uint32(34).string(message.sender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateTransferOperatorshipRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTransferOperatorshipRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.keyId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sender = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTransferOperatorshipRequest {
    return {
      $type: CreateTransferOperatorshipRequest.$type,
      chain: isSet(object.chain) ? gt.String(object.chain) : "",
      keyId: isSet(object.keyId) ? gt.String(object.keyId) : "",
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
    };
  },

  toJSON(message: CreateTransferOperatorshipRequest): unknown {
    const obj: any = {};
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.keyId !== "") {
      obj.keyId = message.keyId;
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateTransferOperatorshipRequest>, I>>(
    base?: I,
  ): CreateTransferOperatorshipRequest {
    return CreateTransferOperatorshipRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateTransferOperatorshipRequest>, I>>(
    object: I,
  ): CreateTransferOperatorshipRequest {
    const message = createBaseCreateTransferOperatorshipRequest();
    message.chain = object.chain ?? "";
    message.keyId = object.keyId ?? "";
    message.sender = object.sender ?? "";
    return message;
  },
};

messageTypeRegistry.set(CreateTransferOperatorshipRequest.$type, CreateTransferOperatorshipRequest);

function createBaseCreateTransferOperatorshipResponse(): CreateTransferOperatorshipResponse {
  return { $type: "axelar.evm.v1beta1.CreateTransferOperatorshipResponse" };
}

export const CreateTransferOperatorshipResponse = {
  $type: "axelar.evm.v1beta1.CreateTransferOperatorshipResponse" as const,

  encode(_: CreateTransferOperatorshipResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateTransferOperatorshipResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTransferOperatorshipResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CreateTransferOperatorshipResponse {
    return { $type: CreateTransferOperatorshipResponse.$type };
  },

  toJSON(_: CreateTransferOperatorshipResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateTransferOperatorshipResponse>, I>>(
    base?: I,
  ): CreateTransferOperatorshipResponse {
    return CreateTransferOperatorshipResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateTransferOperatorshipResponse>, I>>(
    _: I,
  ): CreateTransferOperatorshipResponse {
    const message = createBaseCreateTransferOperatorshipResponse();
    return message;
  },
};

messageTypeRegistry.set(CreateTransferOperatorshipResponse.$type, CreateTransferOperatorshipResponse);

function createBaseSignCommandsRequest(): SignCommandsRequest {
  return { $type: "axelar.evm.v1beta1.SignCommandsRequest", chain: "", sender: "" };
}

export const SignCommandsRequest = {
  $type: "axelar.evm.v1beta1.SignCommandsRequest" as const,

  encode(message: SignCommandsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    if (message.sender !== "") {
      writer.uint32(26).string(message.sender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SignCommandsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignCommandsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sender = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignCommandsRequest {
    return {
      $type: SignCommandsRequest.$type,
      chain: isSet(object.chain) ? gt.String(object.chain) : "",
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
    };
  },

  toJSON(message: SignCommandsRequest): unknown {
    const obj: any = {};
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignCommandsRequest>, I>>(base?: I): SignCommandsRequest {
    return SignCommandsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignCommandsRequest>, I>>(object: I): SignCommandsRequest {
    const message = createBaseSignCommandsRequest();
    message.chain = object.chain ?? "";
    message.sender = object.sender ?? "";
    return message;
  },
};

messageTypeRegistry.set(SignCommandsRequest.$type, SignCommandsRequest);

function createBaseSignCommandsResponse(): SignCommandsResponse {
  return {
    $type: "axelar.evm.v1beta1.SignCommandsResponse",
    batchedCommandsId: Buffer.alloc(0),
    commandCount: 0,
  };
}

export const SignCommandsResponse = {
  $type: "axelar.evm.v1beta1.SignCommandsResponse" as const,

  encode(message: SignCommandsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.batchedCommandsId.length !== 0) {
      writer.uint32(10).bytes(message.batchedCommandsId);
    }
    if (message.commandCount !== 0) {
      writer.uint32(16).uint32(message.commandCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SignCommandsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignCommandsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.batchedCommandsId = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.commandCount = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignCommandsResponse {
    return {
      $type: SignCommandsResponse.$type,
      batchedCommandsId: isSet(object.batchedCommandsId)
        ? Buffer.from(bytesFromBase64(object.batchedCommandsId))
        : Buffer.alloc(0),
      commandCount: isSet(object.commandCount) ? gt.Number(object.commandCount) : 0,
    };
  },

  toJSON(message: SignCommandsResponse): unknown {
    const obj: any = {};
    if (message.batchedCommandsId.length !== 0) {
      obj.batchedCommandsId = base64FromBytes(message.batchedCommandsId);
    }
    if (message.commandCount !== 0) {
      obj.commandCount = Math.round(message.commandCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignCommandsResponse>, I>>(base?: I): SignCommandsResponse {
    return SignCommandsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignCommandsResponse>, I>>(object: I): SignCommandsResponse {
    const message = createBaseSignCommandsResponse();
    message.batchedCommandsId = object.batchedCommandsId ?? Buffer.alloc(0);
    message.commandCount = object.commandCount ?? 0;
    return message;
  },
};

messageTypeRegistry.set(SignCommandsResponse.$type, SignCommandsResponse);

function createBaseAddChainRequest(): AddChainRequest {
  return {
    $type: "axelar.evm.v1beta1.AddChainRequest",
    name: "",
    keyType: 0,
    params: Buffer.alloc(0),
    sender: "",
  };
}

export const AddChainRequest = {
  $type: "axelar.evm.v1beta1.AddChainRequest" as const,

  encode(message: AddChainRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.keyType !== 0) {
      writer.uint32(32).int32(message.keyType);
    }
    if (message.params.length !== 0) {
      writer.uint32(42).bytes(message.params);
    }
    if (message.sender !== "") {
      writer.uint32(50).string(message.sender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddChainRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddChainRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.keyType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.params = reader.bytes() as Buffer;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sender = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddChainRequest {
    return {
      $type: AddChainRequest.$type,
      name: isSet(object.name) ? gt.String(object.name) : "",
      keyType: isSet(object.keyType) ? keyTypeFromJSON(object.keyType) : 0,
      params: isSet(object.params) ? Buffer.from(bytesFromBase64(object.params)) : Buffer.alloc(0),
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
    };
  },

  toJSON(message: AddChainRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.keyType !== 0) {
      obj.keyType = keyTypeToJSON(message.keyType);
    }
    if (message.params.length !== 0) {
      obj.params = base64FromBytes(message.params);
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddChainRequest>, I>>(base?: I): AddChainRequest {
    return AddChainRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddChainRequest>, I>>(object: I): AddChainRequest {
    const message = createBaseAddChainRequest();
    message.name = object.name ?? "";
    message.keyType = object.keyType ?? 0;
    message.params = object.params ?? Buffer.alloc(0);
    message.sender = object.sender ?? "";
    return message;
  },
};

messageTypeRegistry.set(AddChainRequest.$type, AddChainRequest);

function createBaseAddChainResponse(): AddChainResponse {
  return { $type: "axelar.evm.v1beta1.AddChainResponse" };
}

export const AddChainResponse = {
  $type: "axelar.evm.v1beta1.AddChainResponse" as const,

  encode(_: AddChainResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddChainResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddChainResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AddChainResponse {
    return { $type: AddChainResponse.$type };
  },

  toJSON(_: AddChainResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AddChainResponse>, I>>(base?: I): AddChainResponse {
    return AddChainResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddChainResponse>, I>>(_: I): AddChainResponse {
    const message = createBaseAddChainResponse();
    return message;
  },
};

messageTypeRegistry.set(AddChainResponse.$type, AddChainResponse);

function createBaseRetryFailedEventRequest(): RetryFailedEventRequest {
  return { $type: "axelar.evm.v1beta1.RetryFailedEventRequest", chain: "", eventId: "", sender: "" };
}

export const RetryFailedEventRequest = {
  $type: "axelar.evm.v1beta1.RetryFailedEventRequest" as const,

  encode(message: RetryFailedEventRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    if (message.eventId !== "") {
      writer.uint32(26).string(message.eventId);
    }
    if (message.sender !== "") {
      writer.uint32(34).string(message.sender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RetryFailedEventRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryFailedEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.eventId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sender = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryFailedEventRequest {
    return {
      $type: RetryFailedEventRequest.$type,
      chain: isSet(object.chain) ? gt.String(object.chain) : "",
      eventId: isSet(object.eventId) ? gt.String(object.eventId) : "",
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
    };
  },

  toJSON(message: RetryFailedEventRequest): unknown {
    const obj: any = {};
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryFailedEventRequest>, I>>(base?: I): RetryFailedEventRequest {
    return RetryFailedEventRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryFailedEventRequest>, I>>(object: I): RetryFailedEventRequest {
    const message = createBaseRetryFailedEventRequest();
    message.chain = object.chain ?? "";
    message.eventId = object.eventId ?? "";
    message.sender = object.sender ?? "";
    return message;
  },
};

messageTypeRegistry.set(RetryFailedEventRequest.$type, RetryFailedEventRequest);

function createBaseRetryFailedEventResponse(): RetryFailedEventResponse {
  return { $type: "axelar.evm.v1beta1.RetryFailedEventResponse" };
}

export const RetryFailedEventResponse = {
  $type: "axelar.evm.v1beta1.RetryFailedEventResponse" as const,

  encode(_: RetryFailedEventResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RetryFailedEventResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryFailedEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RetryFailedEventResponse {
    return { $type: RetryFailedEventResponse.$type };
  },

  toJSON(_: RetryFailedEventResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryFailedEventResponse>, I>>(base?: I): RetryFailedEventResponse {
    return RetryFailedEventResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryFailedEventResponse>, I>>(_: I): RetryFailedEventResponse {
    const message = createBaseRetryFailedEventResponse();
    return message;
  },
};

messageTypeRegistry.set(RetryFailedEventResponse.$type, RetryFailedEventResponse);

function createBaseUpdateParamsRequest(): UpdateParamsRequest {
  return { $type: "axelar.evm.v1beta1.UpdateParamsRequest", authority: "", params: undefined };
}

export const UpdateParamsRequest = {
  $type: "axelar.evm.v1beta1.UpdateParamsRequest" as const,

  encode(message: UpdateParamsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateParamsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateParamsRequest {
    return {
      $type: UpdateParamsRequest.$type,
      authority: isSet(object.authority) ? gt.String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: UpdateParamsRequest): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateParamsRequest>, I>>(base?: I): UpdateParamsRequest {
    return UpdateParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateParamsRequest>, I>>(object: I): UpdateParamsRequest {
    const message = createBaseUpdateParamsRequest();
    message.authority = object.authority ?? "";
    message.params =
      object.params !== undefined && object.params !== null ? Params.fromPartial(object.params) : undefined;
    return message;
  },
};

messageTypeRegistry.set(UpdateParamsRequest.$type, UpdateParamsRequest);

function createBaseUpdateParamsResponse(): UpdateParamsResponse {
  return { $type: "axelar.evm.v1beta1.UpdateParamsResponse" };
}

export const UpdateParamsResponse = {
  $type: "axelar.evm.v1beta1.UpdateParamsResponse" as const,

  encode(_: UpdateParamsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateParamsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpdateParamsResponse {
    return { $type: UpdateParamsResponse.$type };
  },

  toJSON(_: UpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateParamsResponse>, I>>(base?: I): UpdateParamsResponse {
    return UpdateParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateParamsResponse>, I>>(_: I): UpdateParamsResponse {
    const message = createBaseUpdateParamsResponse();
    return message;
  },
};

messageTypeRegistry.set(UpdateParamsResponse.$type, UpdateParamsResponse);

declare const self: any | undefined;
declare const window: any | undefined;
declare const global: any | undefined;
const gt: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(gt.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return gt.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Long
  ? string | number | Long
  : T extends globalThis.Array<infer U>
  ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends {}
  ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
