// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: axelar/evm/v1beta1/types.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Any } from "../../../google/protobuf/any";
import { messageTypeRegistry } from "../../../typeRegistry";

export const protobufPackage = "axelar.evm.v1beta1";

export enum Status {
  /**
   * STATUS_UNSPECIFIED - these enum values are used for bitwise operations, therefore they need to
   * be powers of 2
   */
  STATUS_UNSPECIFIED = 0,
  STATUS_INITIALIZED = 1,
  STATUS_PENDING = 2,
  STATUS_CONFIRMED = 4,
  UNRECOGNIZED = -1,
}

export function statusFromJSON(object: any): Status {
  switch (object) {
    case 0:
    case "STATUS_UNSPECIFIED":
      return Status.STATUS_UNSPECIFIED;
    case 1:
    case "STATUS_INITIALIZED":
      return Status.STATUS_INITIALIZED;
    case 2:
    case "STATUS_PENDING":
      return Status.STATUS_PENDING;
    case 4:
    case "STATUS_CONFIRMED":
      return Status.STATUS_CONFIRMED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Status.UNRECOGNIZED;
  }
}

export function statusToJSON(object: Status): string {
  switch (object) {
    case Status.STATUS_UNSPECIFIED:
      return "STATUS_UNSPECIFIED";
    case Status.STATUS_INITIALIZED:
      return "STATUS_INITIALIZED";
    case Status.STATUS_PENDING:
      return "STATUS_PENDING";
    case Status.STATUS_CONFIRMED:
      return "STATUS_CONFIRMED";
    case Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CommandType {
  COMMAND_TYPE_UNSPECIFIED = 0,
  COMMAND_TYPE_MINT_TOKEN = 1,
  COMMAND_TYPE_DEPLOY_TOKEN = 2,
  COMMAND_TYPE_BURN_TOKEN = 3,
  COMMAND_TYPE_TRANSFER_OPERATORSHIP = 4,
  COMMAND_TYPE_APPROVE_CONTRACT_CALL_WITH_MINT = 5,
  COMMAND_TYPE_APPROVE_CONTRACT_CALL = 6,
  UNRECOGNIZED = -1,
}

export function commandTypeFromJSON(object: any): CommandType {
  switch (object) {
    case 0:
    case "COMMAND_TYPE_UNSPECIFIED":
      return CommandType.COMMAND_TYPE_UNSPECIFIED;
    case 1:
    case "COMMAND_TYPE_MINT_TOKEN":
      return CommandType.COMMAND_TYPE_MINT_TOKEN;
    case 2:
    case "COMMAND_TYPE_DEPLOY_TOKEN":
      return CommandType.COMMAND_TYPE_DEPLOY_TOKEN;
    case 3:
    case "COMMAND_TYPE_BURN_TOKEN":
      return CommandType.COMMAND_TYPE_BURN_TOKEN;
    case 4:
    case "COMMAND_TYPE_TRANSFER_OPERATORSHIP":
      return CommandType.COMMAND_TYPE_TRANSFER_OPERATORSHIP;
    case 5:
    case "COMMAND_TYPE_APPROVE_CONTRACT_CALL_WITH_MINT":
      return CommandType.COMMAND_TYPE_APPROVE_CONTRACT_CALL_WITH_MINT;
    case 6:
    case "COMMAND_TYPE_APPROVE_CONTRACT_CALL":
      return CommandType.COMMAND_TYPE_APPROVE_CONTRACT_CALL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CommandType.UNRECOGNIZED;
  }
}

export function commandTypeToJSON(object: CommandType): string {
  switch (object) {
    case CommandType.COMMAND_TYPE_UNSPECIFIED:
      return "COMMAND_TYPE_UNSPECIFIED";
    case CommandType.COMMAND_TYPE_MINT_TOKEN:
      return "COMMAND_TYPE_MINT_TOKEN";
    case CommandType.COMMAND_TYPE_DEPLOY_TOKEN:
      return "COMMAND_TYPE_DEPLOY_TOKEN";
    case CommandType.COMMAND_TYPE_BURN_TOKEN:
      return "COMMAND_TYPE_BURN_TOKEN";
    case CommandType.COMMAND_TYPE_TRANSFER_OPERATORSHIP:
      return "COMMAND_TYPE_TRANSFER_OPERATORSHIP";
    case CommandType.COMMAND_TYPE_APPROVE_CONTRACT_CALL_WITH_MINT:
      return "COMMAND_TYPE_APPROVE_CONTRACT_CALL_WITH_MINT";
    case CommandType.COMMAND_TYPE_APPROVE_CONTRACT_CALL:
      return "COMMAND_TYPE_APPROVE_CONTRACT_CALL";
    case CommandType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum BatchedCommandsStatus {
  BATCHED_COMMANDS_STATUS_UNSPECIFIED = 0,
  BATCHED_COMMANDS_STATUS_SIGNING = 1,
  BATCHED_COMMANDS_STATUS_ABORTED = 2,
  BATCHED_COMMANDS_STATUS_SIGNED = 3,
  UNRECOGNIZED = -1,
}

export function batchedCommandsStatusFromJSON(object: any): BatchedCommandsStatus {
  switch (object) {
    case 0:
    case "BATCHED_COMMANDS_STATUS_UNSPECIFIED":
      return BatchedCommandsStatus.BATCHED_COMMANDS_STATUS_UNSPECIFIED;
    case 1:
    case "BATCHED_COMMANDS_STATUS_SIGNING":
      return BatchedCommandsStatus.BATCHED_COMMANDS_STATUS_SIGNING;
    case 2:
    case "BATCHED_COMMANDS_STATUS_ABORTED":
      return BatchedCommandsStatus.BATCHED_COMMANDS_STATUS_ABORTED;
    case 3:
    case "BATCHED_COMMANDS_STATUS_SIGNED":
      return BatchedCommandsStatus.BATCHED_COMMANDS_STATUS_SIGNED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BatchedCommandsStatus.UNRECOGNIZED;
  }
}

export function batchedCommandsStatusToJSON(object: BatchedCommandsStatus): string {
  switch (object) {
    case BatchedCommandsStatus.BATCHED_COMMANDS_STATUS_UNSPECIFIED:
      return "BATCHED_COMMANDS_STATUS_UNSPECIFIED";
    case BatchedCommandsStatus.BATCHED_COMMANDS_STATUS_SIGNING:
      return "BATCHED_COMMANDS_STATUS_SIGNING";
    case BatchedCommandsStatus.BATCHED_COMMANDS_STATUS_ABORTED:
      return "BATCHED_COMMANDS_STATUS_ABORTED";
    case BatchedCommandsStatus.BATCHED_COMMANDS_STATUS_SIGNED:
      return "BATCHED_COMMANDS_STATUS_SIGNED";
    case BatchedCommandsStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SigType {
  SIG_TYPE_UNSPECIFIED = 0,
  SIG_TYPE_TX = 1,
  SIG_TYPE_COMMAND = 2,
  UNRECOGNIZED = -1,
}

export function sigTypeFromJSON(object: any): SigType {
  switch (object) {
    case 0:
    case "SIG_TYPE_UNSPECIFIED":
      return SigType.SIG_TYPE_UNSPECIFIED;
    case 1:
    case "SIG_TYPE_TX":
      return SigType.SIG_TYPE_TX;
    case 2:
    case "SIG_TYPE_COMMAND":
      return SigType.SIG_TYPE_COMMAND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SigType.UNRECOGNIZED;
  }
}

export function sigTypeToJSON(object: SigType): string {
  switch (object) {
    case SigType.SIG_TYPE_UNSPECIFIED:
      return "SIG_TYPE_UNSPECIFIED";
    case SigType.SIG_TYPE_TX:
      return "SIG_TYPE_TX";
    case SigType.SIG_TYPE_COMMAND:
      return "SIG_TYPE_COMMAND";
    case SigType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * DEPRECATED: Removed in v0.20, reinstated in v1.3 for backward compatibility.
 * This enum must remain to allow decoding of historical transactions.
 * DO NOT use in new code.
 *
 * @deprecated
 */
export enum TransferKeyType {
  TRANSFER_KEY_TYPE_UNSPECIFIED = 0,
  TRANSFER_KEY_TYPE_OWNERSHIP = 1,
  TRANSFER_KEY_TYPE_OPERATORSHIP = 2,
  UNRECOGNIZED = -1,
}

export function transferKeyTypeFromJSON(object: any): TransferKeyType {
  switch (object) {
    case 0:
    case "TRANSFER_KEY_TYPE_UNSPECIFIED":
      return TransferKeyType.TRANSFER_KEY_TYPE_UNSPECIFIED;
    case 1:
    case "TRANSFER_KEY_TYPE_OWNERSHIP":
      return TransferKeyType.TRANSFER_KEY_TYPE_OWNERSHIP;
    case 2:
    case "TRANSFER_KEY_TYPE_OPERATORSHIP":
      return TransferKeyType.TRANSFER_KEY_TYPE_OPERATORSHIP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransferKeyType.UNRECOGNIZED;
  }
}

export function transferKeyTypeToJSON(object: TransferKeyType): string {
  switch (object) {
    case TransferKeyType.TRANSFER_KEY_TYPE_UNSPECIFIED:
      return "TRANSFER_KEY_TYPE_UNSPECIFIED";
    case TransferKeyType.TRANSFER_KEY_TYPE_OWNERSHIP:
      return "TRANSFER_KEY_TYPE_OWNERSHIP";
    case TransferKeyType.TRANSFER_KEY_TYPE_OPERATORSHIP:
      return "TRANSFER_KEY_TYPE_OPERATORSHIP";
    case TransferKeyType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum DepositStatus {
  DEPOSIT_STATUS_UNSPECIFIED = 0,
  DEPOSIT_STATUS_PENDING = 1,
  DEPOSIT_STATUS_CONFIRMED = 2,
  DEPOSIT_STATUS_BURNED = 3,
  UNRECOGNIZED = -1,
}

export function depositStatusFromJSON(object: any): DepositStatus {
  switch (object) {
    case 0:
    case "DEPOSIT_STATUS_UNSPECIFIED":
      return DepositStatus.DEPOSIT_STATUS_UNSPECIFIED;
    case 1:
    case "DEPOSIT_STATUS_PENDING":
      return DepositStatus.DEPOSIT_STATUS_PENDING;
    case 2:
    case "DEPOSIT_STATUS_CONFIRMED":
      return DepositStatus.DEPOSIT_STATUS_CONFIRMED;
    case 3:
    case "DEPOSIT_STATUS_BURNED":
      return DepositStatus.DEPOSIT_STATUS_BURNED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DepositStatus.UNRECOGNIZED;
  }
}

export function depositStatusToJSON(object: DepositStatus): string {
  switch (object) {
    case DepositStatus.DEPOSIT_STATUS_UNSPECIFIED:
      return "DEPOSIT_STATUS_UNSPECIFIED";
    case DepositStatus.DEPOSIT_STATUS_PENDING:
      return "DEPOSIT_STATUS_PENDING";
    case DepositStatus.DEPOSIT_STATUS_CONFIRMED:
      return "DEPOSIT_STATUS_CONFIRMED";
    case DepositStatus.DEPOSIT_STATUS_BURNED:
      return "DEPOSIT_STATUS_BURNED";
    case DepositStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface VoteEvents {
  $type: "axelar.evm.v1beta1.VoteEvents";
  chain: string;
  events: Event[];
}

export interface Event {
  $type: "axelar.evm.v1beta1.Event";
  chain: string;
  txId: Buffer;
  index: Long;
  status: Event_Status;
  tokenSent?: EventTokenSent | undefined;
  contractCall?: EventContractCall | undefined;
  contractCallWithToken?: EventContractCallWithToken | undefined;
  transfer?: EventTransfer | undefined;
  tokenDeployed?: EventTokenDeployed | undefined;
  /** @deprecated */
  multisigOwnershipTransferred?: EventMultisigOwnershipTransferred | undefined;
  multisigOperatorshipTransferred?: EventMultisigOperatorshipTransferred | undefined;
}

export enum Event_Status {
  STATUS_UNSPECIFIED = 0,
  STATUS_CONFIRMED = 1,
  STATUS_COMPLETED = 2,
  STATUS_FAILED = 3,
  UNRECOGNIZED = -1,
}

export function event_StatusFromJSON(object: any): Event_Status {
  switch (object) {
    case 0:
    case "STATUS_UNSPECIFIED":
      return Event_Status.STATUS_UNSPECIFIED;
    case 1:
    case "STATUS_CONFIRMED":
      return Event_Status.STATUS_CONFIRMED;
    case 2:
    case "STATUS_COMPLETED":
      return Event_Status.STATUS_COMPLETED;
    case 3:
    case "STATUS_FAILED":
      return Event_Status.STATUS_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Event_Status.UNRECOGNIZED;
  }
}

export function event_StatusToJSON(object: Event_Status): string {
  switch (object) {
    case Event_Status.STATUS_UNSPECIFIED:
      return "STATUS_UNSPECIFIED";
    case Event_Status.STATUS_CONFIRMED:
      return "STATUS_CONFIRMED";
    case Event_Status.STATUS_COMPLETED:
      return "STATUS_COMPLETED";
    case Event_Status.STATUS_FAILED:
      return "STATUS_FAILED";
    case Event_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface EventTokenSent {
  $type: "axelar.evm.v1beta1.EventTokenSent";
  sender: Buffer;
  destinationChain: string;
  destinationAddress: string;
  symbol: string;
  amount: Buffer;
}

export interface EventContractCall {
  $type: "axelar.evm.v1beta1.EventContractCall";
  sender: Buffer;
  destinationChain: string;
  contractAddress: string;
  payloadHash: Buffer;
}

export interface EventContractCallWithToken {
  $type: "axelar.evm.v1beta1.EventContractCallWithToken";
  sender: Buffer;
  destinationChain: string;
  contractAddress: string;
  payloadHash: Buffer;
  symbol: string;
  amount: Buffer;
}

export interface EventTransfer {
  $type: "axelar.evm.v1beta1.EventTransfer";
  to: Buffer;
  amount: Buffer;
}

export interface EventTokenDeployed {
  $type: "axelar.evm.v1beta1.EventTokenDeployed";
  symbol: string;
  tokenAddress: Buffer;
}

/** @deprecated */
export interface EventMultisigOwnershipTransferred {
  $type: "axelar.evm.v1beta1.EventMultisigOwnershipTransferred";
  preOwners: Buffer[];
  prevThreshold: Buffer;
  newOwners: Buffer[];
  newThreshold: Buffer;
}

export interface EventMultisigOperatorshipTransferred {
  $type: "axelar.evm.v1beta1.EventMultisigOperatorshipTransferred";
  newOperators: Buffer[];
  newThreshold: Buffer;
  newWeights: Buffer[];
}

/** NetworkInfo describes information about a network */
export interface NetworkInfo {
  $type: "axelar.evm.v1beta1.NetworkInfo";
  name: string;
  id: Buffer;
}

/**
 * BurnerInfo describes information required to burn token at an burner address
 * that is deposited by an user
 */
export interface BurnerInfo {
  $type: "axelar.evm.v1beta1.BurnerInfo";
  burnerAddress: Buffer;
  tokenAddress: Buffer;
  destinationChain: string;
  symbol: string;
  asset: string;
  salt: Buffer;
}

/** ERC20Deposit contains information for an ERC20 deposit */
export interface ERC20Deposit {
  $type: "axelar.evm.v1beta1.ERC20Deposit";
  txId: Buffer;
  amount: Buffer;
  asset: string;
  destinationChain: string;
  burnerAddress: Buffer;
  logIndex: Long;
}

/** ERC20TokenMetadata describes information about an ERC20 token */
export interface ERC20TokenMetadata {
  $type: "axelar.evm.v1beta1.ERC20TokenMetadata";
  asset: string;
  chainId: Buffer;
  details?: TokenDetails | undefined;
  tokenAddress: string;
  txHash: string;
  status: Status;
  isExternal: boolean;
  burnerCode: Buffer;
}

export interface TransactionMetadata {
  $type: "axelar.evm.v1beta1.TransactionMetadata";
  rawTx: Buffer;
  pubKey: Buffer;
}

export interface Command {
  $type: "axelar.evm.v1beta1.Command";
  id: Buffer;
  /** @deprecated */
  command: string;
  params: Buffer;
  keyId: string;
  maxGasCost: number;
  type: CommandType;
}

export interface CommandBatchMetadata {
  $type: "axelar.evm.v1beta1.CommandBatchMetadata";
  id: Buffer;
  commandIds: Buffer[];
  data: Buffer;
  sigHash: Buffer;
  status: BatchedCommandsStatus;
  keyId: string;
  prevBatchedCommandsId: Buffer;
  signature?: Any | undefined;
}

/**
 * SigMetadata stores necessary information for external apps to map signature
 * results to evm relay transaction types
 */
export interface SigMetadata {
  $type: "axelar.evm.v1beta1.SigMetadata";
  type: SigType;
  chain: string;
  commandBatchId: Buffer;
}

/** TransferKey contains information for a transfer operatorship */
export interface TransferKey {
  $type: "axelar.evm.v1beta1.TransferKey";
  txId: Buffer;
  nextKeyId: string;
}

export interface Asset {
  $type: "axelar.evm.v1beta1.Asset";
  chain: string;
  name: string;
}

export interface TokenDetails {
  $type: "axelar.evm.v1beta1.TokenDetails";
  tokenName: string;
  symbol: string;
  decimals: number;
  capacity: Buffer;
}

export interface Gateway {
  $type: "axelar.evm.v1beta1.Gateway";
  address: Buffer;
}

export interface PollMetadata {
  $type: "axelar.evm.v1beta1.PollMetadata";
  chain: string;
  txId: Buffer;
}

function createBaseVoteEvents(): VoteEvents {
  return { $type: "axelar.evm.v1beta1.VoteEvents", chain: "", events: [] };
}

export const VoteEvents = {
  $type: "axelar.evm.v1beta1.VoteEvents" as const,

  encode(message: VoteEvents, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chain !== "") {
      writer.uint32(10).string(message.chain);
    }
    for (const v of message.events) {
      Event.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VoteEvents {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVoteEvents();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.events.push(Event.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VoteEvents {
    return {
      $type: VoteEvents.$type,
      chain: isSet(object.chain) ? gt.String(object.chain) : "",
      events: gt.Array.isArray(object?.events) ? object.events.map((e: any) => Event.fromJSON(e)) : [],
    };
  },

  toJSON(message: VoteEvents): unknown {
    const obj: any = {};
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.events?.length) {
      obj.events = message.events.map((e) => Event.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VoteEvents>, I>>(base?: I): VoteEvents {
    return VoteEvents.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VoteEvents>, I>>(object: I): VoteEvents {
    const message = createBaseVoteEvents();
    message.chain = object.chain ?? "";
    message.events = object.events?.map((e) => Event.fromPartial(e)) || [];
    return message;
  },
};

messageTypeRegistry.set(VoteEvents.$type, VoteEvents);

function createBaseEvent(): Event {
  return {
    $type: "axelar.evm.v1beta1.Event",
    chain: "",
    txId: Buffer.alloc(0),
    index: Long.UZERO,
    status: 0,
    tokenSent: undefined,
    contractCall: undefined,
    contractCallWithToken: undefined,
    transfer: undefined,
    tokenDeployed: undefined,
    multisigOwnershipTransferred: undefined,
    multisigOperatorshipTransferred: undefined,
  };
}

export const Event = {
  $type: "axelar.evm.v1beta1.Event" as const,

  encode(message: Event, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chain !== "") {
      writer.uint32(10).string(message.chain);
    }
    if (message.txId.length !== 0) {
      writer.uint32(18).bytes(message.txId);
    }
    if (!message.index.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.index);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.tokenSent !== undefined) {
      EventTokenSent.encode(message.tokenSent, writer.uint32(42).fork()).ldelim();
    }
    if (message.contractCall !== undefined) {
      EventContractCall.encode(message.contractCall, writer.uint32(50).fork()).ldelim();
    }
    if (message.contractCallWithToken !== undefined) {
      EventContractCallWithToken.encode(message.contractCallWithToken, writer.uint32(58).fork()).ldelim();
    }
    if (message.transfer !== undefined) {
      EventTransfer.encode(message.transfer, writer.uint32(66).fork()).ldelim();
    }
    if (message.tokenDeployed !== undefined) {
      EventTokenDeployed.encode(message.tokenDeployed, writer.uint32(74).fork()).ldelim();
    }
    if (message.multisigOwnershipTransferred !== undefined) {
      EventMultisigOwnershipTransferred.encode(
        message.multisigOwnershipTransferred,
        writer.uint32(82).fork(),
      ).ldelim();
    }
    if (message.multisigOperatorshipTransferred !== undefined) {
      EventMultisigOperatorshipTransferred.encode(
        message.multisigOperatorshipTransferred,
        writer.uint32(90).fork(),
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Event {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.txId = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.index = reader.uint64() as Long;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.tokenSent = EventTokenSent.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.contractCall = EventContractCall.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.contractCallWithToken = EventContractCallWithToken.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.transfer = EventTransfer.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.tokenDeployed = EventTokenDeployed.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.multisigOwnershipTransferred = EventMultisigOwnershipTransferred.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.multisigOperatorshipTransferred = EventMultisigOperatorshipTransferred.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Event {
    return {
      $type: Event.$type,
      chain: isSet(object.chain) ? gt.String(object.chain) : "",
      txId: isSet(object.txId) ? Buffer.from(bytesFromBase64(object.txId)) : Buffer.alloc(0),
      index: isSet(object.index) ? Long.fromValue(object.index) : Long.UZERO,
      status: isSet(object.status) ? event_StatusFromJSON(object.status) : 0,
      tokenSent: isSet(object.tokenSent) ? EventTokenSent.fromJSON(object.tokenSent) : undefined,
      contractCall: isSet(object.contractCall) ? EventContractCall.fromJSON(object.contractCall) : undefined,
      contractCallWithToken: isSet(object.contractCallWithToken)
        ? EventContractCallWithToken.fromJSON(object.contractCallWithToken)
        : undefined,
      transfer: isSet(object.transfer) ? EventTransfer.fromJSON(object.transfer) : undefined,
      tokenDeployed: isSet(object.tokenDeployed)
        ? EventTokenDeployed.fromJSON(object.tokenDeployed)
        : undefined,
      multisigOwnershipTransferred: isSet(object.multisigOwnershipTransferred)
        ? EventMultisigOwnershipTransferred.fromJSON(object.multisigOwnershipTransferred)
        : undefined,
      multisigOperatorshipTransferred: isSet(object.multisigOperatorshipTransferred)
        ? EventMultisigOperatorshipTransferred.fromJSON(object.multisigOperatorshipTransferred)
        : undefined,
    };
  },

  toJSON(message: Event): unknown {
    const obj: any = {};
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (!message.index.equals(Long.UZERO)) {
      obj.index = (message.index || Long.UZERO).toString();
    }
    if (message.status !== 0) {
      obj.status = event_StatusToJSON(message.status);
    }
    if (message.tokenSent !== undefined) {
      obj.tokenSent = EventTokenSent.toJSON(message.tokenSent);
    }
    if (message.contractCall !== undefined) {
      obj.contractCall = EventContractCall.toJSON(message.contractCall);
    }
    if (message.contractCallWithToken !== undefined) {
      obj.contractCallWithToken = EventContractCallWithToken.toJSON(message.contractCallWithToken);
    }
    if (message.transfer !== undefined) {
      obj.transfer = EventTransfer.toJSON(message.transfer);
    }
    if (message.tokenDeployed !== undefined) {
      obj.tokenDeployed = EventTokenDeployed.toJSON(message.tokenDeployed);
    }
    if (message.multisigOwnershipTransferred !== undefined) {
      obj.multisigOwnershipTransferred = EventMultisigOwnershipTransferred.toJSON(
        message.multisigOwnershipTransferred,
      );
    }
    if (message.multisigOperatorshipTransferred !== undefined) {
      obj.multisigOperatorshipTransferred = EventMultisigOperatorshipTransferred.toJSON(
        message.multisigOperatorshipTransferred,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Event>, I>>(base?: I): Event {
    return Event.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Event>, I>>(object: I): Event {
    const message = createBaseEvent();
    message.chain = object.chain ?? "";
    message.txId = object.txId ?? Buffer.alloc(0);
    message.index =
      object.index !== undefined && object.index !== null ? Long.fromValue(object.index) : Long.UZERO;
    message.status = object.status ?? 0;
    message.tokenSent =
      object.tokenSent !== undefined && object.tokenSent !== null
        ? EventTokenSent.fromPartial(object.tokenSent)
        : undefined;
    message.contractCall =
      object.contractCall !== undefined && object.contractCall !== null
        ? EventContractCall.fromPartial(object.contractCall)
        : undefined;
    message.contractCallWithToken =
      object.contractCallWithToken !== undefined && object.contractCallWithToken !== null
        ? EventContractCallWithToken.fromPartial(object.contractCallWithToken)
        : undefined;
    message.transfer =
      object.transfer !== undefined && object.transfer !== null
        ? EventTransfer.fromPartial(object.transfer)
        : undefined;
    message.tokenDeployed =
      object.tokenDeployed !== undefined && object.tokenDeployed !== null
        ? EventTokenDeployed.fromPartial(object.tokenDeployed)
        : undefined;
    message.multisigOwnershipTransferred =
      object.multisigOwnershipTransferred !== undefined && object.multisigOwnershipTransferred !== null
        ? EventMultisigOwnershipTransferred.fromPartial(object.multisigOwnershipTransferred)
        : undefined;
    message.multisigOperatorshipTransferred =
      object.multisigOperatorshipTransferred !== undefined && object.multisigOperatorshipTransferred !== null
        ? EventMultisigOperatorshipTransferred.fromPartial(object.multisigOperatorshipTransferred)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(Event.$type, Event);

function createBaseEventTokenSent(): EventTokenSent {
  return {
    $type: "axelar.evm.v1beta1.EventTokenSent",
    sender: Buffer.alloc(0),
    destinationChain: "",
    destinationAddress: "",
    symbol: "",
    amount: Buffer.alloc(0),
  };
}

export const EventTokenSent = {
  $type: "axelar.evm.v1beta1.EventTokenSent" as const,

  encode(message: EventTokenSent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender.length !== 0) {
      writer.uint32(10).bytes(message.sender);
    }
    if (message.destinationChain !== "") {
      writer.uint32(18).string(message.destinationChain);
    }
    if (message.destinationAddress !== "") {
      writer.uint32(26).string(message.destinationAddress);
    }
    if (message.symbol !== "") {
      writer.uint32(34).string(message.symbol);
    }
    if (message.amount.length !== 0) {
      writer.uint32(42).bytes(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventTokenSent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventTokenSent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.destinationChain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.destinationAddress = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.amount = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventTokenSent {
    return {
      $type: EventTokenSent.$type,
      sender: isSet(object.sender) ? Buffer.from(bytesFromBase64(object.sender)) : Buffer.alloc(0),
      destinationChain: isSet(object.destinationChain) ? gt.String(object.destinationChain) : "",
      destinationAddress: isSet(object.destinationAddress) ? gt.String(object.destinationAddress) : "",
      symbol: isSet(object.symbol) ? gt.String(object.symbol) : "",
      amount: isSet(object.amount) ? Buffer.from(bytesFromBase64(object.amount)) : Buffer.alloc(0),
    };
  },

  toJSON(message: EventTokenSent): unknown {
    const obj: any = {};
    if (message.sender.length !== 0) {
      obj.sender = base64FromBytes(message.sender);
    }
    if (message.destinationChain !== "") {
      obj.destinationChain = message.destinationChain;
    }
    if (message.destinationAddress !== "") {
      obj.destinationAddress = message.destinationAddress;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventTokenSent>, I>>(base?: I): EventTokenSent {
    return EventTokenSent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventTokenSent>, I>>(object: I): EventTokenSent {
    const message = createBaseEventTokenSent();
    message.sender = object.sender ?? Buffer.alloc(0);
    message.destinationChain = object.destinationChain ?? "";
    message.destinationAddress = object.destinationAddress ?? "";
    message.symbol = object.symbol ?? "";
    message.amount = object.amount ?? Buffer.alloc(0);
    return message;
  },
};

messageTypeRegistry.set(EventTokenSent.$type, EventTokenSent);

function createBaseEventContractCall(): EventContractCall {
  return {
    $type: "axelar.evm.v1beta1.EventContractCall",
    sender: Buffer.alloc(0),
    destinationChain: "",
    contractAddress: "",
    payloadHash: Buffer.alloc(0),
  };
}

export const EventContractCall = {
  $type: "axelar.evm.v1beta1.EventContractCall" as const,

  encode(message: EventContractCall, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender.length !== 0) {
      writer.uint32(10).bytes(message.sender);
    }
    if (message.destinationChain !== "") {
      writer.uint32(18).string(message.destinationChain);
    }
    if (message.contractAddress !== "") {
      writer.uint32(26).string(message.contractAddress);
    }
    if (message.payloadHash.length !== 0) {
      writer.uint32(34).bytes(message.payloadHash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventContractCall {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventContractCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.destinationChain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.payloadHash = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventContractCall {
    return {
      $type: EventContractCall.$type,
      sender: isSet(object.sender) ? Buffer.from(bytesFromBase64(object.sender)) : Buffer.alloc(0),
      destinationChain: isSet(object.destinationChain) ? gt.String(object.destinationChain) : "",
      contractAddress: isSet(object.contractAddress) ? gt.String(object.contractAddress) : "",
      payloadHash: isSet(object.payloadHash)
        ? Buffer.from(bytesFromBase64(object.payloadHash))
        : Buffer.alloc(0),
    };
  },

  toJSON(message: EventContractCall): unknown {
    const obj: any = {};
    if (message.sender.length !== 0) {
      obj.sender = base64FromBytes(message.sender);
    }
    if (message.destinationChain !== "") {
      obj.destinationChain = message.destinationChain;
    }
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.payloadHash.length !== 0) {
      obj.payloadHash = base64FromBytes(message.payloadHash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventContractCall>, I>>(base?: I): EventContractCall {
    return EventContractCall.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventContractCall>, I>>(object: I): EventContractCall {
    const message = createBaseEventContractCall();
    message.sender = object.sender ?? Buffer.alloc(0);
    message.destinationChain = object.destinationChain ?? "";
    message.contractAddress = object.contractAddress ?? "";
    message.payloadHash = object.payloadHash ?? Buffer.alloc(0);
    return message;
  },
};

messageTypeRegistry.set(EventContractCall.$type, EventContractCall);

function createBaseEventContractCallWithToken(): EventContractCallWithToken {
  return {
    $type: "axelar.evm.v1beta1.EventContractCallWithToken",
    sender: Buffer.alloc(0),
    destinationChain: "",
    contractAddress: "",
    payloadHash: Buffer.alloc(0),
    symbol: "",
    amount: Buffer.alloc(0),
  };
}

export const EventContractCallWithToken = {
  $type: "axelar.evm.v1beta1.EventContractCallWithToken" as const,

  encode(message: EventContractCallWithToken, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender.length !== 0) {
      writer.uint32(10).bytes(message.sender);
    }
    if (message.destinationChain !== "") {
      writer.uint32(18).string(message.destinationChain);
    }
    if (message.contractAddress !== "") {
      writer.uint32(26).string(message.contractAddress);
    }
    if (message.payloadHash.length !== 0) {
      writer.uint32(34).bytes(message.payloadHash);
    }
    if (message.symbol !== "") {
      writer.uint32(42).string(message.symbol);
    }
    if (message.amount.length !== 0) {
      writer.uint32(50).bytes(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventContractCallWithToken {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventContractCallWithToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.destinationChain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.payloadHash = reader.bytes() as Buffer;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.amount = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventContractCallWithToken {
    return {
      $type: EventContractCallWithToken.$type,
      sender: isSet(object.sender) ? Buffer.from(bytesFromBase64(object.sender)) : Buffer.alloc(0),
      destinationChain: isSet(object.destinationChain) ? gt.String(object.destinationChain) : "",
      contractAddress: isSet(object.contractAddress) ? gt.String(object.contractAddress) : "",
      payloadHash: isSet(object.payloadHash)
        ? Buffer.from(bytesFromBase64(object.payloadHash))
        : Buffer.alloc(0),
      symbol: isSet(object.symbol) ? gt.String(object.symbol) : "",
      amount: isSet(object.amount) ? Buffer.from(bytesFromBase64(object.amount)) : Buffer.alloc(0),
    };
  },

  toJSON(message: EventContractCallWithToken): unknown {
    const obj: any = {};
    if (message.sender.length !== 0) {
      obj.sender = base64FromBytes(message.sender);
    }
    if (message.destinationChain !== "") {
      obj.destinationChain = message.destinationChain;
    }
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.payloadHash.length !== 0) {
      obj.payloadHash = base64FromBytes(message.payloadHash);
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventContractCallWithToken>, I>>(base?: I): EventContractCallWithToken {
    return EventContractCallWithToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventContractCallWithToken>, I>>(
    object: I,
  ): EventContractCallWithToken {
    const message = createBaseEventContractCallWithToken();
    message.sender = object.sender ?? Buffer.alloc(0);
    message.destinationChain = object.destinationChain ?? "";
    message.contractAddress = object.contractAddress ?? "";
    message.payloadHash = object.payloadHash ?? Buffer.alloc(0);
    message.symbol = object.symbol ?? "";
    message.amount = object.amount ?? Buffer.alloc(0);
    return message;
  },
};

messageTypeRegistry.set(EventContractCallWithToken.$type, EventContractCallWithToken);

function createBaseEventTransfer(): EventTransfer {
  return { $type: "axelar.evm.v1beta1.EventTransfer", to: Buffer.alloc(0), amount: Buffer.alloc(0) };
}

export const EventTransfer = {
  $type: "axelar.evm.v1beta1.EventTransfer" as const,

  encode(message: EventTransfer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.to.length !== 0) {
      writer.uint32(10).bytes(message.to);
    }
    if (message.amount.length !== 0) {
      writer.uint32(18).bytes(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventTransfer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.to = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventTransfer {
    return {
      $type: EventTransfer.$type,
      to: isSet(object.to) ? Buffer.from(bytesFromBase64(object.to)) : Buffer.alloc(0),
      amount: isSet(object.amount) ? Buffer.from(bytesFromBase64(object.amount)) : Buffer.alloc(0),
    };
  },

  toJSON(message: EventTransfer): unknown {
    const obj: any = {};
    if (message.to.length !== 0) {
      obj.to = base64FromBytes(message.to);
    }
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventTransfer>, I>>(base?: I): EventTransfer {
    return EventTransfer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventTransfer>, I>>(object: I): EventTransfer {
    const message = createBaseEventTransfer();
    message.to = object.to ?? Buffer.alloc(0);
    message.amount = object.amount ?? Buffer.alloc(0);
    return message;
  },
};

messageTypeRegistry.set(EventTransfer.$type, EventTransfer);

function createBaseEventTokenDeployed(): EventTokenDeployed {
  return { $type: "axelar.evm.v1beta1.EventTokenDeployed", symbol: "", tokenAddress: Buffer.alloc(0) };
}

export const EventTokenDeployed = {
  $type: "axelar.evm.v1beta1.EventTokenDeployed" as const,

  encode(message: EventTokenDeployed, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.symbol !== "") {
      writer.uint32(10).string(message.symbol);
    }
    if (message.tokenAddress.length !== 0) {
      writer.uint32(18).bytes(message.tokenAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventTokenDeployed {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventTokenDeployed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tokenAddress = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventTokenDeployed {
    return {
      $type: EventTokenDeployed.$type,
      symbol: isSet(object.symbol) ? gt.String(object.symbol) : "",
      tokenAddress: isSet(object.tokenAddress)
        ? Buffer.from(bytesFromBase64(object.tokenAddress))
        : Buffer.alloc(0),
    };
  },

  toJSON(message: EventTokenDeployed): unknown {
    const obj: any = {};
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.tokenAddress.length !== 0) {
      obj.tokenAddress = base64FromBytes(message.tokenAddress);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventTokenDeployed>, I>>(base?: I): EventTokenDeployed {
    return EventTokenDeployed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventTokenDeployed>, I>>(object: I): EventTokenDeployed {
    const message = createBaseEventTokenDeployed();
    message.symbol = object.symbol ?? "";
    message.tokenAddress = object.tokenAddress ?? Buffer.alloc(0);
    return message;
  },
};

messageTypeRegistry.set(EventTokenDeployed.$type, EventTokenDeployed);

function createBaseEventMultisigOwnershipTransferred(): EventMultisigOwnershipTransferred {
  return {
    $type: "axelar.evm.v1beta1.EventMultisigOwnershipTransferred",
    preOwners: [],
    prevThreshold: Buffer.alloc(0),
    newOwners: [],
    newThreshold: Buffer.alloc(0),
  };
}

export const EventMultisigOwnershipTransferred = {
  $type: "axelar.evm.v1beta1.EventMultisigOwnershipTransferred" as const,

  encode(message: EventMultisigOwnershipTransferred, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.preOwners) {
      writer.uint32(10).bytes(v!);
    }
    if (message.prevThreshold.length !== 0) {
      writer.uint32(18).bytes(message.prevThreshold);
    }
    for (const v of message.newOwners) {
      writer.uint32(26).bytes(v!);
    }
    if (message.newThreshold.length !== 0) {
      writer.uint32(34).bytes(message.newThreshold);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventMultisigOwnershipTransferred {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMultisigOwnershipTransferred();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.preOwners.push(reader.bytes() as Buffer);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.prevThreshold = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.newOwners.push(reader.bytes() as Buffer);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.newThreshold = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMultisigOwnershipTransferred {
    return {
      $type: EventMultisigOwnershipTransferred.$type,
      preOwners: gt.Array.isArray(object?.preOwners)
        ? object.preOwners.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
      prevThreshold: isSet(object.prevThreshold)
        ? Buffer.from(bytesFromBase64(object.prevThreshold))
        : Buffer.alloc(0),
      newOwners: gt.Array.isArray(object?.newOwners)
        ? object.newOwners.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
      newThreshold: isSet(object.newThreshold)
        ? Buffer.from(bytesFromBase64(object.newThreshold))
        : Buffer.alloc(0),
    };
  },

  toJSON(message: EventMultisigOwnershipTransferred): unknown {
    const obj: any = {};
    if (message.preOwners?.length) {
      obj.preOwners = message.preOwners.map((e) => base64FromBytes(e));
    }
    if (message.prevThreshold.length !== 0) {
      obj.prevThreshold = base64FromBytes(message.prevThreshold);
    }
    if (message.newOwners?.length) {
      obj.newOwners = message.newOwners.map((e) => base64FromBytes(e));
    }
    if (message.newThreshold.length !== 0) {
      obj.newThreshold = base64FromBytes(message.newThreshold);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMultisigOwnershipTransferred>, I>>(
    base?: I,
  ): EventMultisigOwnershipTransferred {
    return EventMultisigOwnershipTransferred.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMultisigOwnershipTransferred>, I>>(
    object: I,
  ): EventMultisigOwnershipTransferred {
    const message = createBaseEventMultisigOwnershipTransferred();
    message.preOwners = object.preOwners?.map((e) => e) || [];
    message.prevThreshold = object.prevThreshold ?? Buffer.alloc(0);
    message.newOwners = object.newOwners?.map((e) => e) || [];
    message.newThreshold = object.newThreshold ?? Buffer.alloc(0);
    return message;
  },
};

messageTypeRegistry.set(EventMultisigOwnershipTransferred.$type, EventMultisigOwnershipTransferred);

function createBaseEventMultisigOperatorshipTransferred(): EventMultisigOperatorshipTransferred {
  return {
    $type: "axelar.evm.v1beta1.EventMultisigOperatorshipTransferred",
    newOperators: [],
    newThreshold: Buffer.alloc(0),
    newWeights: [],
  };
}

export const EventMultisigOperatorshipTransferred = {
  $type: "axelar.evm.v1beta1.EventMultisigOperatorshipTransferred" as const,

  encode(
    message: EventMultisigOperatorshipTransferred,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.newOperators) {
      writer.uint32(26).bytes(v!);
    }
    if (message.newThreshold.length !== 0) {
      writer.uint32(34).bytes(message.newThreshold);
    }
    for (const v of message.newWeights) {
      writer.uint32(42).bytes(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventMultisigOperatorshipTransferred {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMultisigOperatorshipTransferred();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.newOperators.push(reader.bytes() as Buffer);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.newThreshold = reader.bytes() as Buffer;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.newWeights.push(reader.bytes() as Buffer);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMultisigOperatorshipTransferred {
    return {
      $type: EventMultisigOperatorshipTransferred.$type,
      newOperators: gt.Array.isArray(object?.newOperators)
        ? object.newOperators.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
      newThreshold: isSet(object.newThreshold)
        ? Buffer.from(bytesFromBase64(object.newThreshold))
        : Buffer.alloc(0),
      newWeights: gt.Array.isArray(object?.newWeights)
        ? object.newWeights.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
    };
  },

  toJSON(message: EventMultisigOperatorshipTransferred): unknown {
    const obj: any = {};
    if (message.newOperators?.length) {
      obj.newOperators = message.newOperators.map((e) => base64FromBytes(e));
    }
    if (message.newThreshold.length !== 0) {
      obj.newThreshold = base64FromBytes(message.newThreshold);
    }
    if (message.newWeights?.length) {
      obj.newWeights = message.newWeights.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMultisigOperatorshipTransferred>, I>>(
    base?: I,
  ): EventMultisigOperatorshipTransferred {
    return EventMultisigOperatorshipTransferred.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMultisigOperatorshipTransferred>, I>>(
    object: I,
  ): EventMultisigOperatorshipTransferred {
    const message = createBaseEventMultisigOperatorshipTransferred();
    message.newOperators = object.newOperators?.map((e) => e) || [];
    message.newThreshold = object.newThreshold ?? Buffer.alloc(0);
    message.newWeights = object.newWeights?.map((e) => e) || [];
    return message;
  },
};

messageTypeRegistry.set(EventMultisigOperatorshipTransferred.$type, EventMultisigOperatorshipTransferred);

function createBaseNetworkInfo(): NetworkInfo {
  return { $type: "axelar.evm.v1beta1.NetworkInfo", name: "", id: Buffer.alloc(0) };
}

export const NetworkInfo = {
  $type: "axelar.evm.v1beta1.NetworkInfo" as const,

  encode(message: NetworkInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id.length !== 0) {
      writer.uint32(18).bytes(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NetworkInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkInfo {
    return {
      $type: NetworkInfo.$type,
      name: isSet(object.name) ? gt.String(object.name) : "",
      id: isSet(object.id) ? Buffer.from(bytesFromBase64(object.id)) : Buffer.alloc(0),
    };
  },

  toJSON(message: NetworkInfo): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NetworkInfo>, I>>(base?: I): NetworkInfo {
    return NetworkInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NetworkInfo>, I>>(object: I): NetworkInfo {
    const message = createBaseNetworkInfo();
    message.name = object.name ?? "";
    message.id = object.id ?? Buffer.alloc(0);
    return message;
  },
};

messageTypeRegistry.set(NetworkInfo.$type, NetworkInfo);

function createBaseBurnerInfo(): BurnerInfo {
  return {
    $type: "axelar.evm.v1beta1.BurnerInfo",
    burnerAddress: Buffer.alloc(0),
    tokenAddress: Buffer.alloc(0),
    destinationChain: "",
    symbol: "",
    asset: "",
    salt: Buffer.alloc(0),
  };
}

export const BurnerInfo = {
  $type: "axelar.evm.v1beta1.BurnerInfo" as const,

  encode(message: BurnerInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.burnerAddress.length !== 0) {
      writer.uint32(10).bytes(message.burnerAddress);
    }
    if (message.tokenAddress.length !== 0) {
      writer.uint32(18).bytes(message.tokenAddress);
    }
    if (message.destinationChain !== "") {
      writer.uint32(26).string(message.destinationChain);
    }
    if (message.symbol !== "") {
      writer.uint32(34).string(message.symbol);
    }
    if (message.asset !== "") {
      writer.uint32(42).string(message.asset);
    }
    if (message.salt.length !== 0) {
      writer.uint32(50).bytes(message.salt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BurnerInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBurnerInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.burnerAddress = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tokenAddress = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.destinationChain = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.asset = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.salt = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BurnerInfo {
    return {
      $type: BurnerInfo.$type,
      burnerAddress: isSet(object.burnerAddress)
        ? Buffer.from(bytesFromBase64(object.burnerAddress))
        : Buffer.alloc(0),
      tokenAddress: isSet(object.tokenAddress)
        ? Buffer.from(bytesFromBase64(object.tokenAddress))
        : Buffer.alloc(0),
      destinationChain: isSet(object.destinationChain) ? gt.String(object.destinationChain) : "",
      symbol: isSet(object.symbol) ? gt.String(object.symbol) : "",
      asset: isSet(object.asset) ? gt.String(object.asset) : "",
      salt: isSet(object.salt) ? Buffer.from(bytesFromBase64(object.salt)) : Buffer.alloc(0),
    };
  },

  toJSON(message: BurnerInfo): unknown {
    const obj: any = {};
    if (message.burnerAddress.length !== 0) {
      obj.burnerAddress = base64FromBytes(message.burnerAddress);
    }
    if (message.tokenAddress.length !== 0) {
      obj.tokenAddress = base64FromBytes(message.tokenAddress);
    }
    if (message.destinationChain !== "") {
      obj.destinationChain = message.destinationChain;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.asset !== "") {
      obj.asset = message.asset;
    }
    if (message.salt.length !== 0) {
      obj.salt = base64FromBytes(message.salt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BurnerInfo>, I>>(base?: I): BurnerInfo {
    return BurnerInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BurnerInfo>, I>>(object: I): BurnerInfo {
    const message = createBaseBurnerInfo();
    message.burnerAddress = object.burnerAddress ?? Buffer.alloc(0);
    message.tokenAddress = object.tokenAddress ?? Buffer.alloc(0);
    message.destinationChain = object.destinationChain ?? "";
    message.symbol = object.symbol ?? "";
    message.asset = object.asset ?? "";
    message.salt = object.salt ?? Buffer.alloc(0);
    return message;
  },
};

messageTypeRegistry.set(BurnerInfo.$type, BurnerInfo);

function createBaseERC20Deposit(): ERC20Deposit {
  return {
    $type: "axelar.evm.v1beta1.ERC20Deposit",
    txId: Buffer.alloc(0),
    amount: Buffer.alloc(0),
    asset: "",
    destinationChain: "",
    burnerAddress: Buffer.alloc(0),
    logIndex: Long.UZERO,
  };
}

export const ERC20Deposit = {
  $type: "axelar.evm.v1beta1.ERC20Deposit" as const,

  encode(message: ERC20Deposit, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.txId.length !== 0) {
      writer.uint32(10).bytes(message.txId);
    }
    if (message.amount.length !== 0) {
      writer.uint32(18).bytes(message.amount);
    }
    if (message.asset !== "") {
      writer.uint32(26).string(message.asset);
    }
    if (message.destinationChain !== "") {
      writer.uint32(34).string(message.destinationChain);
    }
    if (message.burnerAddress.length !== 0) {
      writer.uint32(42).bytes(message.burnerAddress);
    }
    if (!message.logIndex.equals(Long.UZERO)) {
      writer.uint32(48).uint64(message.logIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ERC20Deposit {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseERC20Deposit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txId = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.asset = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.destinationChain = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.burnerAddress = reader.bytes() as Buffer;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.logIndex = reader.uint64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ERC20Deposit {
    return {
      $type: ERC20Deposit.$type,
      txId: isSet(object.txId) ? Buffer.from(bytesFromBase64(object.txId)) : Buffer.alloc(0),
      amount: isSet(object.amount) ? Buffer.from(bytesFromBase64(object.amount)) : Buffer.alloc(0),
      asset: isSet(object.asset) ? gt.String(object.asset) : "",
      destinationChain: isSet(object.destinationChain) ? gt.String(object.destinationChain) : "",
      burnerAddress: isSet(object.burnerAddress)
        ? Buffer.from(bytesFromBase64(object.burnerAddress))
        : Buffer.alloc(0),
      logIndex: isSet(object.logIndex) ? Long.fromValue(object.logIndex) : Long.UZERO,
    };
  },

  toJSON(message: ERC20Deposit): unknown {
    const obj: any = {};
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    if (message.asset !== "") {
      obj.asset = message.asset;
    }
    if (message.destinationChain !== "") {
      obj.destinationChain = message.destinationChain;
    }
    if (message.burnerAddress.length !== 0) {
      obj.burnerAddress = base64FromBytes(message.burnerAddress);
    }
    if (!message.logIndex.equals(Long.UZERO)) {
      obj.logIndex = (message.logIndex || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ERC20Deposit>, I>>(base?: I): ERC20Deposit {
    return ERC20Deposit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ERC20Deposit>, I>>(object: I): ERC20Deposit {
    const message = createBaseERC20Deposit();
    message.txId = object.txId ?? Buffer.alloc(0);
    message.amount = object.amount ?? Buffer.alloc(0);
    message.asset = object.asset ?? "";
    message.destinationChain = object.destinationChain ?? "";
    message.burnerAddress = object.burnerAddress ?? Buffer.alloc(0);
    message.logIndex =
      object.logIndex !== undefined && object.logIndex !== null
        ? Long.fromValue(object.logIndex)
        : Long.UZERO;
    return message;
  },
};

messageTypeRegistry.set(ERC20Deposit.$type, ERC20Deposit);

function createBaseERC20TokenMetadata(): ERC20TokenMetadata {
  return {
    $type: "axelar.evm.v1beta1.ERC20TokenMetadata",
    asset: "",
    chainId: Buffer.alloc(0),
    details: undefined,
    tokenAddress: "",
    txHash: "",
    status: 0,
    isExternal: false,
    burnerCode: Buffer.alloc(0),
  };
}

export const ERC20TokenMetadata = {
  $type: "axelar.evm.v1beta1.ERC20TokenMetadata" as const,

  encode(message: ERC20TokenMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.asset !== "") {
      writer.uint32(10).string(message.asset);
    }
    if (message.chainId.length !== 0) {
      writer.uint32(18).bytes(message.chainId);
    }
    if (message.details !== undefined) {
      TokenDetails.encode(message.details, writer.uint32(26).fork()).ldelim();
    }
    if (message.tokenAddress !== "") {
      writer.uint32(34).string(message.tokenAddress);
    }
    if (message.txHash !== "") {
      writer.uint32(42).string(message.txHash);
    }
    if (message.status !== 0) {
      writer.uint32(56).int32(message.status);
    }
    if (message.isExternal !== false) {
      writer.uint32(64).bool(message.isExternal);
    }
    if (message.burnerCode.length !== 0) {
      writer.uint32(74).bytes(message.burnerCode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ERC20TokenMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseERC20TokenMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.asset = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.details = TokenDetails.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.tokenAddress = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.txHash = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.isExternal = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.burnerCode = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ERC20TokenMetadata {
    return {
      $type: ERC20TokenMetadata.$type,
      asset: isSet(object.asset) ? gt.String(object.asset) : "",
      chainId: isSet(object.chainId) ? Buffer.from(bytesFromBase64(object.chainId)) : Buffer.alloc(0),
      details: isSet(object.details) ? TokenDetails.fromJSON(object.details) : undefined,
      tokenAddress: isSet(object.tokenAddress) ? gt.String(object.tokenAddress) : "",
      txHash: isSet(object.txHash) ? gt.String(object.txHash) : "",
      status: isSet(object.status) ? statusFromJSON(object.status) : 0,
      isExternal: isSet(object.isExternal) ? gt.Boolean(object.isExternal) : false,
      burnerCode: isSet(object.burnerCode)
        ? Buffer.from(bytesFromBase64(object.burnerCode))
        : Buffer.alloc(0),
    };
  },

  toJSON(message: ERC20TokenMetadata): unknown {
    const obj: any = {};
    if (message.asset !== "") {
      obj.asset = message.asset;
    }
    if (message.chainId.length !== 0) {
      obj.chainId = base64FromBytes(message.chainId);
    }
    if (message.details !== undefined) {
      obj.details = TokenDetails.toJSON(message.details);
    }
    if (message.tokenAddress !== "") {
      obj.tokenAddress = message.tokenAddress;
    }
    if (message.txHash !== "") {
      obj.txHash = message.txHash;
    }
    if (message.status !== 0) {
      obj.status = statusToJSON(message.status);
    }
    if (message.isExternal !== false) {
      obj.isExternal = message.isExternal;
    }
    if (message.burnerCode.length !== 0) {
      obj.burnerCode = base64FromBytes(message.burnerCode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ERC20TokenMetadata>, I>>(base?: I): ERC20TokenMetadata {
    return ERC20TokenMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ERC20TokenMetadata>, I>>(object: I): ERC20TokenMetadata {
    const message = createBaseERC20TokenMetadata();
    message.asset = object.asset ?? "";
    message.chainId = object.chainId ?? Buffer.alloc(0);
    message.details =
      object.details !== undefined && object.details !== null
        ? TokenDetails.fromPartial(object.details)
        : undefined;
    message.tokenAddress = object.tokenAddress ?? "";
    message.txHash = object.txHash ?? "";
    message.status = object.status ?? 0;
    message.isExternal = object.isExternal ?? false;
    message.burnerCode = object.burnerCode ?? Buffer.alloc(0);
    return message;
  },
};

messageTypeRegistry.set(ERC20TokenMetadata.$type, ERC20TokenMetadata);

function createBaseTransactionMetadata(): TransactionMetadata {
  return { $type: "axelar.evm.v1beta1.TransactionMetadata", rawTx: Buffer.alloc(0), pubKey: Buffer.alloc(0) };
}

export const TransactionMetadata = {
  $type: "axelar.evm.v1beta1.TransactionMetadata" as const,

  encode(message: TransactionMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rawTx.length !== 0) {
      writer.uint32(10).bytes(message.rawTx);
    }
    if (message.pubKey.length !== 0) {
      writer.uint32(18).bytes(message.pubKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rawTx = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pubKey = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionMetadata {
    return {
      $type: TransactionMetadata.$type,
      rawTx: isSet(object.rawTx) ? Buffer.from(bytesFromBase64(object.rawTx)) : Buffer.alloc(0),
      pubKey: isSet(object.pubKey) ? Buffer.from(bytesFromBase64(object.pubKey)) : Buffer.alloc(0),
    };
  },

  toJSON(message: TransactionMetadata): unknown {
    const obj: any = {};
    if (message.rawTx.length !== 0) {
      obj.rawTx = base64FromBytes(message.rawTx);
    }
    if (message.pubKey.length !== 0) {
      obj.pubKey = base64FromBytes(message.pubKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionMetadata>, I>>(base?: I): TransactionMetadata {
    return TransactionMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionMetadata>, I>>(object: I): TransactionMetadata {
    const message = createBaseTransactionMetadata();
    message.rawTx = object.rawTx ?? Buffer.alloc(0);
    message.pubKey = object.pubKey ?? Buffer.alloc(0);
    return message;
  },
};

messageTypeRegistry.set(TransactionMetadata.$type, TransactionMetadata);

function createBaseCommand(): Command {
  return {
    $type: "axelar.evm.v1beta1.Command",
    id: Buffer.alloc(0),
    command: "",
    params: Buffer.alloc(0),
    keyId: "",
    maxGasCost: 0,
    type: 0,
  };
}

export const Command = {
  $type: "axelar.evm.v1beta1.Command" as const,

  encode(message: Command, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    if (message.command !== "") {
      writer.uint32(18).string(message.command);
    }
    if (message.params.length !== 0) {
      writer.uint32(26).bytes(message.params);
    }
    if (message.keyId !== "") {
      writer.uint32(34).string(message.keyId);
    }
    if (message.maxGasCost !== 0) {
      writer.uint32(40).uint32(message.maxGasCost);
    }
    if (message.type !== 0) {
      writer.uint32(48).int32(message.type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Command {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.command = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.params = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.keyId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.maxGasCost = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Command {
    return {
      $type: Command.$type,
      id: isSet(object.id) ? Buffer.from(bytesFromBase64(object.id)) : Buffer.alloc(0),
      command: isSet(object.command) ? gt.String(object.command) : "",
      params: isSet(object.params) ? Buffer.from(bytesFromBase64(object.params)) : Buffer.alloc(0),
      keyId: isSet(object.keyId) ? gt.String(object.keyId) : "",
      maxGasCost: isSet(object.maxGasCost) ? gt.Number(object.maxGasCost) : 0,
      type: isSet(object.type) ? commandTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: Command): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.command !== "") {
      obj.command = message.command;
    }
    if (message.params.length !== 0) {
      obj.params = base64FromBytes(message.params);
    }
    if (message.keyId !== "") {
      obj.keyId = message.keyId;
    }
    if (message.maxGasCost !== 0) {
      obj.maxGasCost = Math.round(message.maxGasCost);
    }
    if (message.type !== 0) {
      obj.type = commandTypeToJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Command>, I>>(base?: I): Command {
    return Command.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Command>, I>>(object: I): Command {
    const message = createBaseCommand();
    message.id = object.id ?? Buffer.alloc(0);
    message.command = object.command ?? "";
    message.params = object.params ?? Buffer.alloc(0);
    message.keyId = object.keyId ?? "";
    message.maxGasCost = object.maxGasCost ?? 0;
    message.type = object.type ?? 0;
    return message;
  },
};

messageTypeRegistry.set(Command.$type, Command);

function createBaseCommandBatchMetadata(): CommandBatchMetadata {
  return {
    $type: "axelar.evm.v1beta1.CommandBatchMetadata",
    id: Buffer.alloc(0),
    commandIds: [],
    data: Buffer.alloc(0),
    sigHash: Buffer.alloc(0),
    status: 0,
    keyId: "",
    prevBatchedCommandsId: Buffer.alloc(0),
    signature: undefined,
  };
}

export const CommandBatchMetadata = {
  $type: "axelar.evm.v1beta1.CommandBatchMetadata" as const,

  encode(message: CommandBatchMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    for (const v of message.commandIds) {
      writer.uint32(18).bytes(v!);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    if (message.sigHash.length !== 0) {
      writer.uint32(34).bytes(message.sigHash);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.keyId !== "") {
      writer.uint32(50).string(message.keyId);
    }
    if (message.prevBatchedCommandsId.length !== 0) {
      writer.uint32(58).bytes(message.prevBatchedCommandsId);
    }
    if (message.signature !== undefined) {
      Any.encode(message.signature, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CommandBatchMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandBatchMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.commandIds.push(reader.bytes() as Buffer);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.data = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sigHash = reader.bytes() as Buffer;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.keyId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.prevBatchedCommandsId = reader.bytes() as Buffer;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.signature = Any.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandBatchMetadata {
    return {
      $type: CommandBatchMetadata.$type,
      id: isSet(object.id) ? Buffer.from(bytesFromBase64(object.id)) : Buffer.alloc(0),
      commandIds: gt.Array.isArray(object?.commandIds)
        ? object.commandIds.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
      sigHash: isSet(object.sigHash) ? Buffer.from(bytesFromBase64(object.sigHash)) : Buffer.alloc(0),
      status: isSet(object.status) ? batchedCommandsStatusFromJSON(object.status) : 0,
      keyId: isSet(object.keyId) ? gt.String(object.keyId) : "",
      prevBatchedCommandsId: isSet(object.prevBatchedCommandsId)
        ? Buffer.from(bytesFromBase64(object.prevBatchedCommandsId))
        : Buffer.alloc(0),
      signature: isSet(object.signature) ? Any.fromJSON(object.signature) : undefined,
    };
  },

  toJSON(message: CommandBatchMetadata): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.commandIds?.length) {
      obj.commandIds = message.commandIds.map((e) => base64FromBytes(e));
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.sigHash.length !== 0) {
      obj.sigHash = base64FromBytes(message.sigHash);
    }
    if (message.status !== 0) {
      obj.status = batchedCommandsStatusToJSON(message.status);
    }
    if (message.keyId !== "") {
      obj.keyId = message.keyId;
    }
    if (message.prevBatchedCommandsId.length !== 0) {
      obj.prevBatchedCommandsId = base64FromBytes(message.prevBatchedCommandsId);
    }
    if (message.signature !== undefined) {
      obj.signature = Any.toJSON(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommandBatchMetadata>, I>>(base?: I): CommandBatchMetadata {
    return CommandBatchMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommandBatchMetadata>, I>>(object: I): CommandBatchMetadata {
    const message = createBaseCommandBatchMetadata();
    message.id = object.id ?? Buffer.alloc(0);
    message.commandIds = object.commandIds?.map((e) => e) || [];
    message.data = object.data ?? Buffer.alloc(0);
    message.sigHash = object.sigHash ?? Buffer.alloc(0);
    message.status = object.status ?? 0;
    message.keyId = object.keyId ?? "";
    message.prevBatchedCommandsId = object.prevBatchedCommandsId ?? Buffer.alloc(0);
    message.signature =
      object.signature !== undefined && object.signature !== null
        ? Any.fromPartial(object.signature)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(CommandBatchMetadata.$type, CommandBatchMetadata);

function createBaseSigMetadata(): SigMetadata {
  return { $type: "axelar.evm.v1beta1.SigMetadata", type: 0, chain: "", commandBatchId: Buffer.alloc(0) };
}

export const SigMetadata = {
  $type: "axelar.evm.v1beta1.SigMetadata" as const,

  encode(message: SigMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    if (message.commandBatchId.length !== 0) {
      writer.uint32(26).bytes(message.commandBatchId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SigMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.commandBatchId = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigMetadata {
    return {
      $type: SigMetadata.$type,
      type: isSet(object.type) ? sigTypeFromJSON(object.type) : 0,
      chain: isSet(object.chain) ? gt.String(object.chain) : "",
      commandBatchId: isSet(object.commandBatchId)
        ? Buffer.from(bytesFromBase64(object.commandBatchId))
        : Buffer.alloc(0),
    };
  },

  toJSON(message: SigMetadata): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = sigTypeToJSON(message.type);
    }
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.commandBatchId.length !== 0) {
      obj.commandBatchId = base64FromBytes(message.commandBatchId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SigMetadata>, I>>(base?: I): SigMetadata {
    return SigMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SigMetadata>, I>>(object: I): SigMetadata {
    const message = createBaseSigMetadata();
    message.type = object.type ?? 0;
    message.chain = object.chain ?? "";
    message.commandBatchId = object.commandBatchId ?? Buffer.alloc(0);
    return message;
  },
};

messageTypeRegistry.set(SigMetadata.$type, SigMetadata);

function createBaseTransferKey(): TransferKey {
  return { $type: "axelar.evm.v1beta1.TransferKey", txId: Buffer.alloc(0), nextKeyId: "" };
}

export const TransferKey = {
  $type: "axelar.evm.v1beta1.TransferKey" as const,

  encode(message: TransferKey, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.txId.length !== 0) {
      writer.uint32(10).bytes(message.txId);
    }
    if (message.nextKeyId !== "") {
      writer.uint32(26).string(message.nextKeyId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransferKey {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txId = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nextKeyId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferKey {
    return {
      $type: TransferKey.$type,
      txId: isSet(object.txId) ? Buffer.from(bytesFromBase64(object.txId)) : Buffer.alloc(0),
      nextKeyId: isSet(object.nextKeyId) ? gt.String(object.nextKeyId) : "",
    };
  },

  toJSON(message: TransferKey): unknown {
    const obj: any = {};
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.nextKeyId !== "") {
      obj.nextKeyId = message.nextKeyId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransferKey>, I>>(base?: I): TransferKey {
    return TransferKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransferKey>, I>>(object: I): TransferKey {
    const message = createBaseTransferKey();
    message.txId = object.txId ?? Buffer.alloc(0);
    message.nextKeyId = object.nextKeyId ?? "";
    return message;
  },
};

messageTypeRegistry.set(TransferKey.$type, TransferKey);

function createBaseAsset(): Asset {
  return { $type: "axelar.evm.v1beta1.Asset", chain: "", name: "" };
}

export const Asset = {
  $type: "axelar.evm.v1beta1.Asset" as const,

  encode(message: Asset, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chain !== "") {
      writer.uint32(10).string(message.chain);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Asset {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Asset {
    return {
      $type: Asset.$type,
      chain: isSet(object.chain) ? gt.String(object.chain) : "",
      name: isSet(object.name) ? gt.String(object.name) : "",
    };
  },

  toJSON(message: Asset): unknown {
    const obj: any = {};
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Asset>, I>>(base?: I): Asset {
    return Asset.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Asset>, I>>(object: I): Asset {
    const message = createBaseAsset();
    message.chain = object.chain ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

messageTypeRegistry.set(Asset.$type, Asset);

function createBaseTokenDetails(): TokenDetails {
  return {
    $type: "axelar.evm.v1beta1.TokenDetails",
    tokenName: "",
    symbol: "",
    decimals: 0,
    capacity: Buffer.alloc(0),
  };
}

export const TokenDetails = {
  $type: "axelar.evm.v1beta1.TokenDetails" as const,

  encode(message: TokenDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tokenName !== "") {
      writer.uint32(10).string(message.tokenName);
    }
    if (message.symbol !== "") {
      writer.uint32(18).string(message.symbol);
    }
    if (message.decimals !== 0) {
      writer.uint32(24).uint32(message.decimals);
    }
    if (message.capacity.length !== 0) {
      writer.uint32(34).bytes(message.capacity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TokenDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tokenName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.decimals = reader.uint32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.capacity = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenDetails {
    return {
      $type: TokenDetails.$type,
      tokenName: isSet(object.tokenName) ? gt.String(object.tokenName) : "",
      symbol: isSet(object.symbol) ? gt.String(object.symbol) : "",
      decimals: isSet(object.decimals) ? gt.Number(object.decimals) : 0,
      capacity: isSet(object.capacity) ? Buffer.from(bytesFromBase64(object.capacity)) : Buffer.alloc(0),
    };
  },

  toJSON(message: TokenDetails): unknown {
    const obj: any = {};
    if (message.tokenName !== "") {
      obj.tokenName = message.tokenName;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    if (message.capacity.length !== 0) {
      obj.capacity = base64FromBytes(message.capacity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenDetails>, I>>(base?: I): TokenDetails {
    return TokenDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenDetails>, I>>(object: I): TokenDetails {
    const message = createBaseTokenDetails();
    message.tokenName = object.tokenName ?? "";
    message.symbol = object.symbol ?? "";
    message.decimals = object.decimals ?? 0;
    message.capacity = object.capacity ?? Buffer.alloc(0);
    return message;
  },
};

messageTypeRegistry.set(TokenDetails.$type, TokenDetails);

function createBaseGateway(): Gateway {
  return { $type: "axelar.evm.v1beta1.Gateway", address: Buffer.alloc(0) };
}

export const Gateway = {
  $type: "axelar.evm.v1beta1.Gateway" as const,

  encode(message: Gateway, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Gateway {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGateway();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Gateway {
    return {
      $type: Gateway.$type,
      address: isSet(object.address) ? Buffer.from(bytesFromBase64(object.address)) : Buffer.alloc(0),
    };
  },

  toJSON(message: Gateway): unknown {
    const obj: any = {};
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Gateway>, I>>(base?: I): Gateway {
    return Gateway.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Gateway>, I>>(object: I): Gateway {
    const message = createBaseGateway();
    message.address = object.address ?? Buffer.alloc(0);
    return message;
  },
};

messageTypeRegistry.set(Gateway.$type, Gateway);

function createBasePollMetadata(): PollMetadata {
  return { $type: "axelar.evm.v1beta1.PollMetadata", chain: "", txId: Buffer.alloc(0) };
}

export const PollMetadata = {
  $type: "axelar.evm.v1beta1.PollMetadata" as const,

  encode(message: PollMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chain !== "") {
      writer.uint32(10).string(message.chain);
    }
    if (message.txId.length !== 0) {
      writer.uint32(18).bytes(message.txId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PollMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePollMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.txId = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PollMetadata {
    return {
      $type: PollMetadata.$type,
      chain: isSet(object.chain) ? gt.String(object.chain) : "",
      txId: isSet(object.txId) ? Buffer.from(bytesFromBase64(object.txId)) : Buffer.alloc(0),
    };
  },

  toJSON(message: PollMetadata): unknown {
    const obj: any = {};
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PollMetadata>, I>>(base?: I): PollMetadata {
    return PollMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PollMetadata>, I>>(object: I): PollMetadata {
    const message = createBasePollMetadata();
    message.chain = object.chain ?? "";
    message.txId = object.txId ?? Buffer.alloc(0);
    return message;
  },
};

messageTypeRegistry.set(PollMetadata.$type, PollMetadata);

declare const self: any | undefined;
declare const window: any | undefined;
declare const global: any | undefined;
const gt: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(gt.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return gt.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Long
  ? string | number | Long
  : T extends globalThis.Array<infer U>
  ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends {}
  ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
