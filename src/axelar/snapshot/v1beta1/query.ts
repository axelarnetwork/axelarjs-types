// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: axelar/snapshot/v1beta1/query.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { messageTypeRegistry } from "../../../typeRegistry";
import { Params } from "./params";

export const protobufPackage = "axelar.snapshot.v1beta1";

export interface QueryValidatorsResponse {
  $type: "axelar.snapshot.v1beta1.QueryValidatorsResponse";
  validators: QueryValidatorsResponse_Validator[];
}

export interface QueryValidatorsResponse_TssIllegibilityInfo {
  $type: "axelar.snapshot.v1beta1.QueryValidatorsResponse.TssIllegibilityInfo";
  tombstoned: boolean;
  jailed: boolean;
  missedTooManyBlocks: boolean;
  noProxyRegistered: boolean;
  tssSuspended: boolean;
  proxyInsuficientFunds: boolean;
  staleTssHeartbeat: boolean;
}

export interface QueryValidatorsResponse_Validator {
  $type: "axelar.snapshot.v1beta1.QueryValidatorsResponse.Validator";
  operatorAddress: string;
  moniker: string;
  tssIllegibilityInfo?: QueryValidatorsResponse_TssIllegibilityInfo | undefined;
}

/** ParamsRequest represents a message that queries the params */
export interface ParamsRequest {
  $type: "axelar.snapshot.v1beta1.ParamsRequest";
}

export interface ParamsResponse {
  $type: "axelar.snapshot.v1beta1.ParamsResponse";
  params?: Params | undefined;
}

/**
 * OperatorByProxyRequest retrieves the operator address associated with a given
 * proxy address
 */
export interface OperatorByProxyRequest {
  $type: "axelar.snapshot.v1beta1.OperatorByProxyRequest";
  proxyAddress: string;
}

export interface OperatorByProxyResponse {
  $type: "axelar.snapshot.v1beta1.OperatorByProxyResponse";
  operatorAddress: string;
}

/**
 * ProxyByOperatorRequest retrieves the proxy address associated with a given
 * operator address
 */
export interface ProxyByOperatorRequest {
  $type: "axelar.snapshot.v1beta1.ProxyByOperatorRequest";
  operatorAddress: string;
}

export interface ProxyByOperatorResponse {
  $type: "axelar.snapshot.v1beta1.ProxyByOperatorResponse";
  proxyAddress: string;
  status: ProxyByOperatorResponse_Status;
}

export enum ProxyByOperatorResponse_Status {
  STATUS_UNSPECIFIED = 0,
  STATUS_ACTIVE = 1,
  STATUS_INACTIVE = 2,
  UNRECOGNIZED = -1,
}

export function proxyByOperatorResponse_StatusFromJSON(object: any): ProxyByOperatorResponse_Status {
  switch (object) {
    case 0:
    case "STATUS_UNSPECIFIED":
      return ProxyByOperatorResponse_Status.STATUS_UNSPECIFIED;
    case 1:
    case "STATUS_ACTIVE":
      return ProxyByOperatorResponse_Status.STATUS_ACTIVE;
    case 2:
    case "STATUS_INACTIVE":
      return ProxyByOperatorResponse_Status.STATUS_INACTIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProxyByOperatorResponse_Status.UNRECOGNIZED;
  }
}

export function proxyByOperatorResponse_StatusToJSON(object: ProxyByOperatorResponse_Status): string {
  switch (object) {
    case ProxyByOperatorResponse_Status.STATUS_UNSPECIFIED:
      return "STATUS_UNSPECIFIED";
    case ProxyByOperatorResponse_Status.STATUS_ACTIVE:
      return "STATUS_ACTIVE";
    case ProxyByOperatorResponse_Status.STATUS_INACTIVE:
      return "STATUS_INACTIVE";
    case ProxyByOperatorResponse_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseQueryValidatorsResponse(): QueryValidatorsResponse {
  return { $type: "axelar.snapshot.v1beta1.QueryValidatorsResponse", validators: [] };
}

export const QueryValidatorsResponse = {
  $type: "axelar.snapshot.v1beta1.QueryValidatorsResponse" as const,

  encode(message: QueryValidatorsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.validators) {
      QueryValidatorsResponse_Validator.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryValidatorsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryValidatorsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.validators.push(QueryValidatorsResponse_Validator.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryValidatorsResponse {
    return {
      $type: QueryValidatorsResponse.$type,
      validators: gt.Array.isArray(object?.validators)
        ? object.validators.map((e: any) => QueryValidatorsResponse_Validator.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryValidatorsResponse): unknown {
    const obj: any = {};
    if (message.validators?.length) {
      obj.validators = message.validators.map((e) => QueryValidatorsResponse_Validator.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryValidatorsResponse>, I>>(base?: I): QueryValidatorsResponse {
    return QueryValidatorsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryValidatorsResponse>, I>>(object: I): QueryValidatorsResponse {
    const message = createBaseQueryValidatorsResponse();
    message.validators =
      object.validators?.map((e) => QueryValidatorsResponse_Validator.fromPartial(e)) || [];
    return message;
  },
};

messageTypeRegistry.set(QueryValidatorsResponse.$type, QueryValidatorsResponse);

function createBaseQueryValidatorsResponse_TssIllegibilityInfo(): QueryValidatorsResponse_TssIllegibilityInfo {
  return {
    $type: "axelar.snapshot.v1beta1.QueryValidatorsResponse.TssIllegibilityInfo",
    tombstoned: false,
    jailed: false,
    missedTooManyBlocks: false,
    noProxyRegistered: false,
    tssSuspended: false,
    proxyInsuficientFunds: false,
    staleTssHeartbeat: false,
  };
}

export const QueryValidatorsResponse_TssIllegibilityInfo = {
  $type: "axelar.snapshot.v1beta1.QueryValidatorsResponse.TssIllegibilityInfo" as const,

  encode(
    message: QueryValidatorsResponse_TssIllegibilityInfo,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.tombstoned !== false) {
      writer.uint32(8).bool(message.tombstoned);
    }
    if (message.jailed !== false) {
      writer.uint32(16).bool(message.jailed);
    }
    if (message.missedTooManyBlocks !== false) {
      writer.uint32(24).bool(message.missedTooManyBlocks);
    }
    if (message.noProxyRegistered !== false) {
      writer.uint32(32).bool(message.noProxyRegistered);
    }
    if (message.tssSuspended !== false) {
      writer.uint32(40).bool(message.tssSuspended);
    }
    if (message.proxyInsuficientFunds !== false) {
      writer.uint32(48).bool(message.proxyInsuficientFunds);
    }
    if (message.staleTssHeartbeat !== false) {
      writer.uint32(56).bool(message.staleTssHeartbeat);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryValidatorsResponse_TssIllegibilityInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryValidatorsResponse_TssIllegibilityInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tombstoned = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.jailed = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.missedTooManyBlocks = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.noProxyRegistered = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.tssSuspended = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.proxyInsuficientFunds = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.staleTssHeartbeat = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryValidatorsResponse_TssIllegibilityInfo {
    return {
      $type: QueryValidatorsResponse_TssIllegibilityInfo.$type,
      tombstoned: isSet(object.tombstoned) ? gt.Boolean(object.tombstoned) : false,
      jailed: isSet(object.jailed) ? gt.Boolean(object.jailed) : false,
      missedTooManyBlocks: isSet(object.missedTooManyBlocks) ? gt.Boolean(object.missedTooManyBlocks) : false,
      noProxyRegistered: isSet(object.noProxyRegistered) ? gt.Boolean(object.noProxyRegistered) : false,
      tssSuspended: isSet(object.tssSuspended) ? gt.Boolean(object.tssSuspended) : false,
      proxyInsuficientFunds: isSet(object.proxyInsuficientFunds)
        ? gt.Boolean(object.proxyInsuficientFunds)
        : false,
      staleTssHeartbeat: isSet(object.staleTssHeartbeat) ? gt.Boolean(object.staleTssHeartbeat) : false,
    };
  },

  toJSON(message: QueryValidatorsResponse_TssIllegibilityInfo): unknown {
    const obj: any = {};
    if (message.tombstoned !== false) {
      obj.tombstoned = message.tombstoned;
    }
    if (message.jailed !== false) {
      obj.jailed = message.jailed;
    }
    if (message.missedTooManyBlocks !== false) {
      obj.missedTooManyBlocks = message.missedTooManyBlocks;
    }
    if (message.noProxyRegistered !== false) {
      obj.noProxyRegistered = message.noProxyRegistered;
    }
    if (message.tssSuspended !== false) {
      obj.tssSuspended = message.tssSuspended;
    }
    if (message.proxyInsuficientFunds !== false) {
      obj.proxyInsuficientFunds = message.proxyInsuficientFunds;
    }
    if (message.staleTssHeartbeat !== false) {
      obj.staleTssHeartbeat = message.staleTssHeartbeat;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryValidatorsResponse_TssIllegibilityInfo>, I>>(
    base?: I,
  ): QueryValidatorsResponse_TssIllegibilityInfo {
    return QueryValidatorsResponse_TssIllegibilityInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryValidatorsResponse_TssIllegibilityInfo>, I>>(
    object: I,
  ): QueryValidatorsResponse_TssIllegibilityInfo {
    const message = createBaseQueryValidatorsResponse_TssIllegibilityInfo();
    message.tombstoned = object.tombstoned ?? false;
    message.jailed = object.jailed ?? false;
    message.missedTooManyBlocks = object.missedTooManyBlocks ?? false;
    message.noProxyRegistered = object.noProxyRegistered ?? false;
    message.tssSuspended = object.tssSuspended ?? false;
    message.proxyInsuficientFunds = object.proxyInsuficientFunds ?? false;
    message.staleTssHeartbeat = object.staleTssHeartbeat ?? false;
    return message;
  },
};

messageTypeRegistry.set(
  QueryValidatorsResponse_TssIllegibilityInfo.$type,
  QueryValidatorsResponse_TssIllegibilityInfo,
);

function createBaseQueryValidatorsResponse_Validator(): QueryValidatorsResponse_Validator {
  return {
    $type: "axelar.snapshot.v1beta1.QueryValidatorsResponse.Validator",
    operatorAddress: "",
    moniker: "",
    tssIllegibilityInfo: undefined,
  };
}

export const QueryValidatorsResponse_Validator = {
  $type: "axelar.snapshot.v1beta1.QueryValidatorsResponse.Validator" as const,

  encode(message: QueryValidatorsResponse_Validator, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operatorAddress !== "") {
      writer.uint32(10).string(message.operatorAddress);
    }
    if (message.moniker !== "") {
      writer.uint32(18).string(message.moniker);
    }
    if (message.tssIllegibilityInfo !== undefined) {
      QueryValidatorsResponse_TssIllegibilityInfo.encode(
        message.tssIllegibilityInfo,
        writer.uint32(26).fork(),
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryValidatorsResponse_Validator {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryValidatorsResponse_Validator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operatorAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.moniker = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tssIllegibilityInfo = QueryValidatorsResponse_TssIllegibilityInfo.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryValidatorsResponse_Validator {
    return {
      $type: QueryValidatorsResponse_Validator.$type,
      operatorAddress: isSet(object.operatorAddress) ? gt.String(object.operatorAddress) : "",
      moniker: isSet(object.moniker) ? gt.String(object.moniker) : "",
      tssIllegibilityInfo: isSet(object.tssIllegibilityInfo)
        ? QueryValidatorsResponse_TssIllegibilityInfo.fromJSON(object.tssIllegibilityInfo)
        : undefined,
    };
  },

  toJSON(message: QueryValidatorsResponse_Validator): unknown {
    const obj: any = {};
    if (message.operatorAddress !== "") {
      obj.operatorAddress = message.operatorAddress;
    }
    if (message.moniker !== "") {
      obj.moniker = message.moniker;
    }
    if (message.tssIllegibilityInfo !== undefined) {
      obj.tssIllegibilityInfo = QueryValidatorsResponse_TssIllegibilityInfo.toJSON(
        message.tssIllegibilityInfo,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryValidatorsResponse_Validator>, I>>(
    base?: I,
  ): QueryValidatorsResponse_Validator {
    return QueryValidatorsResponse_Validator.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryValidatorsResponse_Validator>, I>>(
    object: I,
  ): QueryValidatorsResponse_Validator {
    const message = createBaseQueryValidatorsResponse_Validator();
    message.operatorAddress = object.operatorAddress ?? "";
    message.moniker = object.moniker ?? "";
    message.tssIllegibilityInfo =
      object.tssIllegibilityInfo !== undefined && object.tssIllegibilityInfo !== null
        ? QueryValidatorsResponse_TssIllegibilityInfo.fromPartial(object.tssIllegibilityInfo)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(QueryValidatorsResponse_Validator.$type, QueryValidatorsResponse_Validator);

function createBaseParamsRequest(): ParamsRequest {
  return { $type: "axelar.snapshot.v1beta1.ParamsRequest" };
}

export const ParamsRequest = {
  $type: "axelar.snapshot.v1beta1.ParamsRequest" as const,

  encode(_: ParamsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ParamsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ParamsRequest {
    return { $type: ParamsRequest.$type };
  },

  toJSON(_: ParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ParamsRequest>, I>>(base?: I): ParamsRequest {
    return ParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParamsRequest>, I>>(_: I): ParamsRequest {
    const message = createBaseParamsRequest();
    return message;
  },
};

messageTypeRegistry.set(ParamsRequest.$type, ParamsRequest);

function createBaseParamsResponse(): ParamsResponse {
  return { $type: "axelar.snapshot.v1beta1.ParamsResponse", params: undefined };
}

export const ParamsResponse = {
  $type: "axelar.snapshot.v1beta1.ParamsResponse" as const,

  encode(message: ParamsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ParamsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParamsResponse {
    return {
      $type: ParamsResponse.$type,
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: ParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParamsResponse>, I>>(base?: I): ParamsResponse {
    return ParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParamsResponse>, I>>(object: I): ParamsResponse {
    const message = createBaseParamsResponse();
    message.params =
      object.params !== undefined && object.params !== null ? Params.fromPartial(object.params) : undefined;
    return message;
  },
};

messageTypeRegistry.set(ParamsResponse.$type, ParamsResponse);

function createBaseOperatorByProxyRequest(): OperatorByProxyRequest {
  return { $type: "axelar.snapshot.v1beta1.OperatorByProxyRequest", proxyAddress: "" };
}

export const OperatorByProxyRequest = {
  $type: "axelar.snapshot.v1beta1.OperatorByProxyRequest" as const,

  encode(message: OperatorByProxyRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.proxyAddress !== "") {
      writer.uint32(10).string(message.proxyAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OperatorByProxyRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperatorByProxyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.proxyAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperatorByProxyRequest {
    return {
      $type: OperatorByProxyRequest.$type,
      proxyAddress: isSet(object.proxyAddress) ? gt.String(object.proxyAddress) : "",
    };
  },

  toJSON(message: OperatorByProxyRequest): unknown {
    const obj: any = {};
    if (message.proxyAddress !== "") {
      obj.proxyAddress = message.proxyAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperatorByProxyRequest>, I>>(base?: I): OperatorByProxyRequest {
    return OperatorByProxyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperatorByProxyRequest>, I>>(object: I): OperatorByProxyRequest {
    const message = createBaseOperatorByProxyRequest();
    message.proxyAddress = object.proxyAddress ?? "";
    return message;
  },
};

messageTypeRegistry.set(OperatorByProxyRequest.$type, OperatorByProxyRequest);

function createBaseOperatorByProxyResponse(): OperatorByProxyResponse {
  return { $type: "axelar.snapshot.v1beta1.OperatorByProxyResponse", operatorAddress: "" };
}

export const OperatorByProxyResponse = {
  $type: "axelar.snapshot.v1beta1.OperatorByProxyResponse" as const,

  encode(message: OperatorByProxyResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operatorAddress !== "") {
      writer.uint32(10).string(message.operatorAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OperatorByProxyResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperatorByProxyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operatorAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperatorByProxyResponse {
    return {
      $type: OperatorByProxyResponse.$type,
      operatorAddress: isSet(object.operatorAddress) ? gt.String(object.operatorAddress) : "",
    };
  },

  toJSON(message: OperatorByProxyResponse): unknown {
    const obj: any = {};
    if (message.operatorAddress !== "") {
      obj.operatorAddress = message.operatorAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperatorByProxyResponse>, I>>(base?: I): OperatorByProxyResponse {
    return OperatorByProxyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperatorByProxyResponse>, I>>(object: I): OperatorByProxyResponse {
    const message = createBaseOperatorByProxyResponse();
    message.operatorAddress = object.operatorAddress ?? "";
    return message;
  },
};

messageTypeRegistry.set(OperatorByProxyResponse.$type, OperatorByProxyResponse);

function createBaseProxyByOperatorRequest(): ProxyByOperatorRequest {
  return { $type: "axelar.snapshot.v1beta1.ProxyByOperatorRequest", operatorAddress: "" };
}

export const ProxyByOperatorRequest = {
  $type: "axelar.snapshot.v1beta1.ProxyByOperatorRequest" as const,

  encode(message: ProxyByOperatorRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operatorAddress !== "") {
      writer.uint32(10).string(message.operatorAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProxyByOperatorRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProxyByOperatorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operatorAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProxyByOperatorRequest {
    return {
      $type: ProxyByOperatorRequest.$type,
      operatorAddress: isSet(object.operatorAddress) ? gt.String(object.operatorAddress) : "",
    };
  },

  toJSON(message: ProxyByOperatorRequest): unknown {
    const obj: any = {};
    if (message.operatorAddress !== "") {
      obj.operatorAddress = message.operatorAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProxyByOperatorRequest>, I>>(base?: I): ProxyByOperatorRequest {
    return ProxyByOperatorRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProxyByOperatorRequest>, I>>(object: I): ProxyByOperatorRequest {
    const message = createBaseProxyByOperatorRequest();
    message.operatorAddress = object.operatorAddress ?? "";
    return message;
  },
};

messageTypeRegistry.set(ProxyByOperatorRequest.$type, ProxyByOperatorRequest);

function createBaseProxyByOperatorResponse(): ProxyByOperatorResponse {
  return { $type: "axelar.snapshot.v1beta1.ProxyByOperatorResponse", proxyAddress: "", status: 0 };
}

export const ProxyByOperatorResponse = {
  $type: "axelar.snapshot.v1beta1.ProxyByOperatorResponse" as const,

  encode(message: ProxyByOperatorResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.proxyAddress !== "") {
      writer.uint32(10).string(message.proxyAddress);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProxyByOperatorResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProxyByOperatorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.proxyAddress = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProxyByOperatorResponse {
    return {
      $type: ProxyByOperatorResponse.$type,
      proxyAddress: isSet(object.proxyAddress) ? gt.String(object.proxyAddress) : "",
      status: isSet(object.status) ? proxyByOperatorResponse_StatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: ProxyByOperatorResponse): unknown {
    const obj: any = {};
    if (message.proxyAddress !== "") {
      obj.proxyAddress = message.proxyAddress;
    }
    if (message.status !== 0) {
      obj.status = proxyByOperatorResponse_StatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProxyByOperatorResponse>, I>>(base?: I): ProxyByOperatorResponse {
    return ProxyByOperatorResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProxyByOperatorResponse>, I>>(object: I): ProxyByOperatorResponse {
    const message = createBaseProxyByOperatorResponse();
    message.proxyAddress = object.proxyAddress ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

messageTypeRegistry.set(ProxyByOperatorResponse.$type, ProxyByOperatorResponse);

declare const self: any | undefined;
declare const window: any | undefined;
declare const global: any | undefined;
const gt: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Long
  ? string | number | Long
  : T extends globalThis.Array<infer U>
  ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends {}
  ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
