// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.31.1
// source: axelar/tss/v1beta1/tx.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { messageTypeRegistry } from "../../../typeRegistry";
import { PollKey } from "../../vote/exported/v1beta1/types";
import { KeyRole, keyRoleFromJSON, keyRoleToJSON, SigKeyPair } from "../exported/v1beta1/types";
import { MessageOut_KeygenResult, MessageOut_SignResult, TrafficOut } from "../tofnd/v1beta1/tofnd";
import { Params } from "./params";
import { KeyInfo } from "./types";

export const protobufPackage = "axelar.tss.v1beta1";

/** StartKeygenRequest indicate the start of keygen */
export interface StartKeygenRequest {
  $type: "axelar.tss.v1beta1.StartKeygenRequest";
  sender: string;
  keyInfo?: KeyInfo | undefined;
}

export interface StartKeygenResponse {
  $type: "axelar.tss.v1beta1.StartKeygenResponse";
}

export interface RotateKeyRequest {
  $type: "axelar.tss.v1beta1.RotateKeyRequest";
  /**
   * DEPRECATED: This field is deprecated but must remain to ensure backward
   * compatibility. Removing this field would break decoding of historical
   * transactions. DO NOT use in new code.
   *
   * @deprecated
   */
  senderDeprecated: Buffer;
  chain: string;
  keyRole: KeyRole;
  keyId: string;
  sender: string;
}

export interface RotateKeyResponse {
  $type: "axelar.tss.v1beta1.RotateKeyResponse";
}

/** ProcessKeygenTrafficRequest protocol message */
export interface ProcessKeygenTrafficRequest {
  $type: "axelar.tss.v1beta1.ProcessKeygenTrafficRequest";
  /**
   * DEPRECATED: This field is deprecated but must remain to ensure backward
   * compatibility. Removing this field would break decoding of historical
   * transactions. DO NOT use in new code.
   *
   * @deprecated
   */
  senderDeprecated: Buffer;
  sessionId: string;
  payload?: TrafficOut | undefined;
  sender: string;
}

export interface ProcessKeygenTrafficResponse {
  $type: "axelar.tss.v1beta1.ProcessKeygenTrafficResponse";
}

/** ProcessSignTrafficRequest protocol message */
export interface ProcessSignTrafficRequest {
  $type: "axelar.tss.v1beta1.ProcessSignTrafficRequest";
  /**
   * DEPRECATED: This field is deprecated but must remain to ensure backward
   * compatibility. Removing this field would break decoding of historical
   * transactions. DO NOT use in new code.
   *
   * @deprecated
   */
  senderDeprecated: Buffer;
  sessionId: string;
  payload?: TrafficOut | undefined;
  sender: string;
}

export interface ProcessSignTrafficResponse {
  $type: "axelar.tss.v1beta1.ProcessSignTrafficResponse";
}

/** VotePubKeyRequest represents the message to vote on a public key */
export interface VotePubKeyRequest {
  $type: "axelar.tss.v1beta1.VotePubKeyRequest";
  /**
   * DEPRECATED: This field is deprecated but must remain to ensure backward
   * compatibility. Removing this field would break decoding of historical
   * transactions. DO NOT use in new code.
   *
   * @deprecated
   */
  senderDeprecated: Buffer;
  pollKey?: PollKey | undefined;
  result?: MessageOut_KeygenResult | undefined;
  sender: string;
}

export interface VotePubKeyResponse {
  $type: "axelar.tss.v1beta1.VotePubKeyResponse";
  log: string;
}

/** VoteSigRequest represents a message to vote for a signature */
export interface VoteSigRequest {
  $type: "axelar.tss.v1beta1.VoteSigRequest";
  /**
   * DEPRECATED: This field is deprecated but must remain to ensure backward
   * compatibility. Removing this field would break decoding of historical
   * transactions. DO NOT use in new code.
   *
   * @deprecated
   */
  senderDeprecated: Buffer;
  pollKey?: PollKey | undefined;
  result?: MessageOut_SignResult | undefined;
  sender: string;
}

export interface VoteSigResponse {
  $type: "axelar.tss.v1beta1.VoteSigResponse";
  log: string;
}

export interface HeartBeatRequest {
  $type: "axelar.tss.v1beta1.HeartBeatRequest";
  /**
   * DEPRECATED: This field is deprecated but must remain to ensure backward
   * compatibility. Removing this field would break decoding of historical
   * transactions. DO NOT use in new code.
   *
   * @deprecated
   */
  senderDeprecated: Buffer;
  /**
   * Deprecated: this field will be removed in the next release
   *
   * @deprecated
   */
  keyIds: string[];
  sender: string;
}

export interface HeartBeatResponse {
  $type: "axelar.tss.v1beta1.HeartBeatResponse";
}

export interface RegisterExternalKeysRequest {
  $type: "axelar.tss.v1beta1.RegisterExternalKeysRequest";
  /**
   * DEPRECATED: This field is deprecated but must remain to ensure backward
   * compatibility. Removing this field would break decoding of historical
   * transactions. DO NOT use in new code.
   *
   * @deprecated
   */
  senderDeprecated: Buffer;
  chain: string;
  externalKeys: RegisterExternalKeysRequest_ExternalKey[];
  sender: string;
}

export interface RegisterExternalKeysRequest_ExternalKey {
  $type: "axelar.tss.v1beta1.RegisterExternalKeysRequest.ExternalKey";
  id: string;
  pubKey: Buffer;
}

export interface RegisterExternalKeysResponse {
  $type: "axelar.tss.v1beta1.RegisterExternalKeysResponse";
}

export interface SubmitMultisigPubKeysRequest {
  $type: "axelar.tss.v1beta1.SubmitMultisigPubKeysRequest";
  /**
   * DEPRECATED: This field is deprecated but must remain to ensure backward
   * compatibility. Removing this field would break decoding of historical
   * transactions. DO NOT use in new code.
   *
   * @deprecated
   */
  senderDeprecated: Buffer;
  keyId: string;
  sigKeyPairs: SigKeyPair[];
  sender: string;
}

export interface SubmitMultisigPubKeysResponse {
  $type: "axelar.tss.v1beta1.SubmitMultisigPubKeysResponse";
}

export interface SubmitMultisigSignaturesRequest {
  $type: "axelar.tss.v1beta1.SubmitMultisigSignaturesRequest";
  /**
   * DEPRECATED: This field is deprecated but must remain to ensure backward
   * compatibility. Removing this field would break decoding of historical
   * transactions. DO NOT use in new code.
   *
   * @deprecated
   */
  senderDeprecated: Buffer;
  sigId: string;
  signatures: Buffer[];
  sender: string;
}

export interface SubmitMultisigSignaturesResponse {
  $type: "axelar.tss.v1beta1.SubmitMultisigSignaturesResponse";
}

export interface UpdateParamsRequest {
  $type: "axelar.tss.v1beta1.UpdateParamsRequest";
  authority: string;
  params?: Params | undefined;
}

export interface UpdateParamsResponse {
  $type: "axelar.tss.v1beta1.UpdateParamsResponse";
}

function createBaseStartKeygenRequest(): StartKeygenRequest {
  return { $type: "axelar.tss.v1beta1.StartKeygenRequest", sender: "", keyInfo: undefined };
}

export const StartKeygenRequest = {
  $type: "axelar.tss.v1beta1.StartKeygenRequest" as const,

  encode(message: StartKeygenRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.keyInfo !== undefined) {
      KeyInfo.encode(message.keyInfo, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StartKeygenRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartKeygenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.keyInfo = KeyInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartKeygenRequest {
    return {
      $type: StartKeygenRequest.$type,
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
      keyInfo: isSet(object.keyInfo) ? KeyInfo.fromJSON(object.keyInfo) : undefined,
    };
  },

  toJSON(message: StartKeygenRequest): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.keyInfo !== undefined) {
      obj.keyInfo = KeyInfo.toJSON(message.keyInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StartKeygenRequest>, I>>(base?: I): StartKeygenRequest {
    return StartKeygenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StartKeygenRequest>, I>>(object: I): StartKeygenRequest {
    const message = createBaseStartKeygenRequest();
    message.sender = object.sender ?? "";
    message.keyInfo =
      object.keyInfo !== undefined && object.keyInfo !== null
        ? KeyInfo.fromPartial(object.keyInfo)
        : undefined;
    return message;
  },
};

messageTypeRegistry.set(StartKeygenRequest.$type, StartKeygenRequest);

function createBaseStartKeygenResponse(): StartKeygenResponse {
  return { $type: "axelar.tss.v1beta1.StartKeygenResponse" };
}

export const StartKeygenResponse = {
  $type: "axelar.tss.v1beta1.StartKeygenResponse" as const,

  encode(_: StartKeygenResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StartKeygenResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartKeygenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): StartKeygenResponse {
    return { $type: StartKeygenResponse.$type };
  },

  toJSON(_: StartKeygenResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<StartKeygenResponse>, I>>(base?: I): StartKeygenResponse {
    return StartKeygenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StartKeygenResponse>, I>>(_: I): StartKeygenResponse {
    const message = createBaseStartKeygenResponse();
    return message;
  },
};

messageTypeRegistry.set(StartKeygenResponse.$type, StartKeygenResponse);

function createBaseRotateKeyRequest(): RotateKeyRequest {
  return {
    $type: "axelar.tss.v1beta1.RotateKeyRequest",
    senderDeprecated: Buffer.alloc(0),
    chain: "",
    keyRole: 0,
    keyId: "",
    sender: "",
  };
}

export const RotateKeyRequest = {
  $type: "axelar.tss.v1beta1.RotateKeyRequest" as const,

  encode(message: RotateKeyRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.senderDeprecated.length !== 0) {
      writer.uint32(10).bytes(message.senderDeprecated);
    }
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    if (message.keyRole !== 0) {
      writer.uint32(24).int32(message.keyRole);
    }
    if (message.keyId !== "") {
      writer.uint32(34).string(message.keyId);
    }
    if (message.sender !== "") {
      writer.uint32(42).string(message.sender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RotateKeyRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRotateKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.senderDeprecated = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.keyRole = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.keyId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sender = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RotateKeyRequest {
    return {
      $type: RotateKeyRequest.$type,
      senderDeprecated: isSet(object.senderDeprecated)
        ? Buffer.from(bytesFromBase64(object.senderDeprecated))
        : Buffer.alloc(0),
      chain: isSet(object.chain) ? gt.String(object.chain) : "",
      keyRole: isSet(object.keyRole) ? keyRoleFromJSON(object.keyRole) : 0,
      keyId: isSet(object.keyId) ? gt.String(object.keyId) : "",
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
    };
  },

  toJSON(message: RotateKeyRequest): unknown {
    const obj: any = {};
    if (message.senderDeprecated.length !== 0) {
      obj.senderDeprecated = base64FromBytes(message.senderDeprecated);
    }
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.keyRole !== 0) {
      obj.keyRole = keyRoleToJSON(message.keyRole);
    }
    if (message.keyId !== "") {
      obj.keyId = message.keyId;
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RotateKeyRequest>, I>>(base?: I): RotateKeyRequest {
    return RotateKeyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RotateKeyRequest>, I>>(object: I): RotateKeyRequest {
    const message = createBaseRotateKeyRequest();
    message.senderDeprecated = object.senderDeprecated ?? Buffer.alloc(0);
    message.chain = object.chain ?? "";
    message.keyRole = object.keyRole ?? 0;
    message.keyId = object.keyId ?? "";
    message.sender = object.sender ?? "";
    return message;
  },
};

messageTypeRegistry.set(RotateKeyRequest.$type, RotateKeyRequest);

function createBaseRotateKeyResponse(): RotateKeyResponse {
  return { $type: "axelar.tss.v1beta1.RotateKeyResponse" };
}

export const RotateKeyResponse = {
  $type: "axelar.tss.v1beta1.RotateKeyResponse" as const,

  encode(_: RotateKeyResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RotateKeyResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRotateKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RotateKeyResponse {
    return { $type: RotateKeyResponse.$type };
  },

  toJSON(_: RotateKeyResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RotateKeyResponse>, I>>(base?: I): RotateKeyResponse {
    return RotateKeyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RotateKeyResponse>, I>>(_: I): RotateKeyResponse {
    const message = createBaseRotateKeyResponse();
    return message;
  },
};

messageTypeRegistry.set(RotateKeyResponse.$type, RotateKeyResponse);

function createBaseProcessKeygenTrafficRequest(): ProcessKeygenTrafficRequest {
  return {
    $type: "axelar.tss.v1beta1.ProcessKeygenTrafficRequest",
    senderDeprecated: Buffer.alloc(0),
    sessionId: "",
    payload: undefined,
    sender: "",
  };
}

export const ProcessKeygenTrafficRequest = {
  $type: "axelar.tss.v1beta1.ProcessKeygenTrafficRequest" as const,

  encode(message: ProcessKeygenTrafficRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.senderDeprecated.length !== 0) {
      writer.uint32(10).bytes(message.senderDeprecated);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.payload !== undefined) {
      TrafficOut.encode(message.payload, writer.uint32(26).fork()).ldelim();
    }
    if (message.sender !== "") {
      writer.uint32(34).string(message.sender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProcessKeygenTrafficRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessKeygenTrafficRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.senderDeprecated = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.payload = TrafficOut.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sender = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessKeygenTrafficRequest {
    return {
      $type: ProcessKeygenTrafficRequest.$type,
      senderDeprecated: isSet(object.senderDeprecated)
        ? Buffer.from(bytesFromBase64(object.senderDeprecated))
        : Buffer.alloc(0),
      sessionId: isSet(object.sessionId) ? gt.String(object.sessionId) : "",
      payload: isSet(object.payload) ? TrafficOut.fromJSON(object.payload) : undefined,
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
    };
  },

  toJSON(message: ProcessKeygenTrafficRequest): unknown {
    const obj: any = {};
    if (message.senderDeprecated.length !== 0) {
      obj.senderDeprecated = base64FromBytes(message.senderDeprecated);
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.payload !== undefined) {
      obj.payload = TrafficOut.toJSON(message.payload);
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessKeygenTrafficRequest>, I>>(
    base?: I,
  ): ProcessKeygenTrafficRequest {
    return ProcessKeygenTrafficRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessKeygenTrafficRequest>, I>>(
    object: I,
  ): ProcessKeygenTrafficRequest {
    const message = createBaseProcessKeygenTrafficRequest();
    message.senderDeprecated = object.senderDeprecated ?? Buffer.alloc(0);
    message.sessionId = object.sessionId ?? "";
    message.payload =
      object.payload !== undefined && object.payload !== null
        ? TrafficOut.fromPartial(object.payload)
        : undefined;
    message.sender = object.sender ?? "";
    return message;
  },
};

messageTypeRegistry.set(ProcessKeygenTrafficRequest.$type, ProcessKeygenTrafficRequest);

function createBaseProcessKeygenTrafficResponse(): ProcessKeygenTrafficResponse {
  return { $type: "axelar.tss.v1beta1.ProcessKeygenTrafficResponse" };
}

export const ProcessKeygenTrafficResponse = {
  $type: "axelar.tss.v1beta1.ProcessKeygenTrafficResponse" as const,

  encode(_: ProcessKeygenTrafficResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProcessKeygenTrafficResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessKeygenTrafficResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ProcessKeygenTrafficResponse {
    return { $type: ProcessKeygenTrafficResponse.$type };
  },

  toJSON(_: ProcessKeygenTrafficResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessKeygenTrafficResponse>, I>>(
    base?: I,
  ): ProcessKeygenTrafficResponse {
    return ProcessKeygenTrafficResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessKeygenTrafficResponse>, I>>(
    _: I,
  ): ProcessKeygenTrafficResponse {
    const message = createBaseProcessKeygenTrafficResponse();
    return message;
  },
};

messageTypeRegistry.set(ProcessKeygenTrafficResponse.$type, ProcessKeygenTrafficResponse);

function createBaseProcessSignTrafficRequest(): ProcessSignTrafficRequest {
  return {
    $type: "axelar.tss.v1beta1.ProcessSignTrafficRequest",
    senderDeprecated: Buffer.alloc(0),
    sessionId: "",
    payload: undefined,
    sender: "",
  };
}

export const ProcessSignTrafficRequest = {
  $type: "axelar.tss.v1beta1.ProcessSignTrafficRequest" as const,

  encode(message: ProcessSignTrafficRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.senderDeprecated.length !== 0) {
      writer.uint32(10).bytes(message.senderDeprecated);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.payload !== undefined) {
      TrafficOut.encode(message.payload, writer.uint32(26).fork()).ldelim();
    }
    if (message.sender !== "") {
      writer.uint32(34).string(message.sender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProcessSignTrafficRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessSignTrafficRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.senderDeprecated = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.payload = TrafficOut.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sender = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessSignTrafficRequest {
    return {
      $type: ProcessSignTrafficRequest.$type,
      senderDeprecated: isSet(object.senderDeprecated)
        ? Buffer.from(bytesFromBase64(object.senderDeprecated))
        : Buffer.alloc(0),
      sessionId: isSet(object.sessionId) ? gt.String(object.sessionId) : "",
      payload: isSet(object.payload) ? TrafficOut.fromJSON(object.payload) : undefined,
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
    };
  },

  toJSON(message: ProcessSignTrafficRequest): unknown {
    const obj: any = {};
    if (message.senderDeprecated.length !== 0) {
      obj.senderDeprecated = base64FromBytes(message.senderDeprecated);
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.payload !== undefined) {
      obj.payload = TrafficOut.toJSON(message.payload);
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessSignTrafficRequest>, I>>(base?: I): ProcessSignTrafficRequest {
    return ProcessSignTrafficRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessSignTrafficRequest>, I>>(
    object: I,
  ): ProcessSignTrafficRequest {
    const message = createBaseProcessSignTrafficRequest();
    message.senderDeprecated = object.senderDeprecated ?? Buffer.alloc(0);
    message.sessionId = object.sessionId ?? "";
    message.payload =
      object.payload !== undefined && object.payload !== null
        ? TrafficOut.fromPartial(object.payload)
        : undefined;
    message.sender = object.sender ?? "";
    return message;
  },
};

messageTypeRegistry.set(ProcessSignTrafficRequest.$type, ProcessSignTrafficRequest);

function createBaseProcessSignTrafficResponse(): ProcessSignTrafficResponse {
  return { $type: "axelar.tss.v1beta1.ProcessSignTrafficResponse" };
}

export const ProcessSignTrafficResponse = {
  $type: "axelar.tss.v1beta1.ProcessSignTrafficResponse" as const,

  encode(_: ProcessSignTrafficResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProcessSignTrafficResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessSignTrafficResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ProcessSignTrafficResponse {
    return { $type: ProcessSignTrafficResponse.$type };
  },

  toJSON(_: ProcessSignTrafficResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessSignTrafficResponse>, I>>(base?: I): ProcessSignTrafficResponse {
    return ProcessSignTrafficResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessSignTrafficResponse>, I>>(_: I): ProcessSignTrafficResponse {
    const message = createBaseProcessSignTrafficResponse();
    return message;
  },
};

messageTypeRegistry.set(ProcessSignTrafficResponse.$type, ProcessSignTrafficResponse);

function createBaseVotePubKeyRequest(): VotePubKeyRequest {
  return {
    $type: "axelar.tss.v1beta1.VotePubKeyRequest",
    senderDeprecated: Buffer.alloc(0),
    pollKey: undefined,
    result: undefined,
    sender: "",
  };
}

export const VotePubKeyRequest = {
  $type: "axelar.tss.v1beta1.VotePubKeyRequest" as const,

  encode(message: VotePubKeyRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.senderDeprecated.length !== 0) {
      writer.uint32(10).bytes(message.senderDeprecated);
    }
    if (message.pollKey !== undefined) {
      PollKey.encode(message.pollKey, writer.uint32(18).fork()).ldelim();
    }
    if (message.result !== undefined) {
      MessageOut_KeygenResult.encode(message.result, writer.uint32(26).fork()).ldelim();
    }
    if (message.sender !== "") {
      writer.uint32(34).string(message.sender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VotePubKeyRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVotePubKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.senderDeprecated = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pollKey = PollKey.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.result = MessageOut_KeygenResult.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sender = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VotePubKeyRequest {
    return {
      $type: VotePubKeyRequest.$type,
      senderDeprecated: isSet(object.senderDeprecated)
        ? Buffer.from(bytesFromBase64(object.senderDeprecated))
        : Buffer.alloc(0),
      pollKey: isSet(object.pollKey) ? PollKey.fromJSON(object.pollKey) : undefined,
      result: isSet(object.result) ? MessageOut_KeygenResult.fromJSON(object.result) : undefined,
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
    };
  },

  toJSON(message: VotePubKeyRequest): unknown {
    const obj: any = {};
    if (message.senderDeprecated.length !== 0) {
      obj.senderDeprecated = base64FromBytes(message.senderDeprecated);
    }
    if (message.pollKey !== undefined) {
      obj.pollKey = PollKey.toJSON(message.pollKey);
    }
    if (message.result !== undefined) {
      obj.result = MessageOut_KeygenResult.toJSON(message.result);
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VotePubKeyRequest>, I>>(base?: I): VotePubKeyRequest {
    return VotePubKeyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VotePubKeyRequest>, I>>(object: I): VotePubKeyRequest {
    const message = createBaseVotePubKeyRequest();
    message.senderDeprecated = object.senderDeprecated ?? Buffer.alloc(0);
    message.pollKey =
      object.pollKey !== undefined && object.pollKey !== null
        ? PollKey.fromPartial(object.pollKey)
        : undefined;
    message.result =
      object.result !== undefined && object.result !== null
        ? MessageOut_KeygenResult.fromPartial(object.result)
        : undefined;
    message.sender = object.sender ?? "";
    return message;
  },
};

messageTypeRegistry.set(VotePubKeyRequest.$type, VotePubKeyRequest);

function createBaseVotePubKeyResponse(): VotePubKeyResponse {
  return { $type: "axelar.tss.v1beta1.VotePubKeyResponse", log: "" };
}

export const VotePubKeyResponse = {
  $type: "axelar.tss.v1beta1.VotePubKeyResponse" as const,

  encode(message: VotePubKeyResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.log !== "") {
      writer.uint32(10).string(message.log);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VotePubKeyResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVotePubKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.log = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VotePubKeyResponse {
    return { $type: VotePubKeyResponse.$type, log: isSet(object.log) ? gt.String(object.log) : "" };
  },

  toJSON(message: VotePubKeyResponse): unknown {
    const obj: any = {};
    if (message.log !== "") {
      obj.log = message.log;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VotePubKeyResponse>, I>>(base?: I): VotePubKeyResponse {
    return VotePubKeyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VotePubKeyResponse>, I>>(object: I): VotePubKeyResponse {
    const message = createBaseVotePubKeyResponse();
    message.log = object.log ?? "";
    return message;
  },
};

messageTypeRegistry.set(VotePubKeyResponse.$type, VotePubKeyResponse);

function createBaseVoteSigRequest(): VoteSigRequest {
  return {
    $type: "axelar.tss.v1beta1.VoteSigRequest",
    senderDeprecated: Buffer.alloc(0),
    pollKey: undefined,
    result: undefined,
    sender: "",
  };
}

export const VoteSigRequest = {
  $type: "axelar.tss.v1beta1.VoteSigRequest" as const,

  encode(message: VoteSigRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.senderDeprecated.length !== 0) {
      writer.uint32(10).bytes(message.senderDeprecated);
    }
    if (message.pollKey !== undefined) {
      PollKey.encode(message.pollKey, writer.uint32(18).fork()).ldelim();
    }
    if (message.result !== undefined) {
      MessageOut_SignResult.encode(message.result, writer.uint32(26).fork()).ldelim();
    }
    if (message.sender !== "") {
      writer.uint32(34).string(message.sender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VoteSigRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVoteSigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.senderDeprecated = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pollKey = PollKey.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.result = MessageOut_SignResult.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sender = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VoteSigRequest {
    return {
      $type: VoteSigRequest.$type,
      senderDeprecated: isSet(object.senderDeprecated)
        ? Buffer.from(bytesFromBase64(object.senderDeprecated))
        : Buffer.alloc(0),
      pollKey: isSet(object.pollKey) ? PollKey.fromJSON(object.pollKey) : undefined,
      result: isSet(object.result) ? MessageOut_SignResult.fromJSON(object.result) : undefined,
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
    };
  },

  toJSON(message: VoteSigRequest): unknown {
    const obj: any = {};
    if (message.senderDeprecated.length !== 0) {
      obj.senderDeprecated = base64FromBytes(message.senderDeprecated);
    }
    if (message.pollKey !== undefined) {
      obj.pollKey = PollKey.toJSON(message.pollKey);
    }
    if (message.result !== undefined) {
      obj.result = MessageOut_SignResult.toJSON(message.result);
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VoteSigRequest>, I>>(base?: I): VoteSigRequest {
    return VoteSigRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VoteSigRequest>, I>>(object: I): VoteSigRequest {
    const message = createBaseVoteSigRequest();
    message.senderDeprecated = object.senderDeprecated ?? Buffer.alloc(0);
    message.pollKey =
      object.pollKey !== undefined && object.pollKey !== null
        ? PollKey.fromPartial(object.pollKey)
        : undefined;
    message.result =
      object.result !== undefined && object.result !== null
        ? MessageOut_SignResult.fromPartial(object.result)
        : undefined;
    message.sender = object.sender ?? "";
    return message;
  },
};

messageTypeRegistry.set(VoteSigRequest.$type, VoteSigRequest);

function createBaseVoteSigResponse(): VoteSigResponse {
  return { $type: "axelar.tss.v1beta1.VoteSigResponse", log: "" };
}

export const VoteSigResponse = {
  $type: "axelar.tss.v1beta1.VoteSigResponse" as const,

  encode(message: VoteSigResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.log !== "") {
      writer.uint32(10).string(message.log);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VoteSigResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVoteSigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.log = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VoteSigResponse {
    return { $type: VoteSigResponse.$type, log: isSet(object.log) ? gt.String(object.log) : "" };
  },

  toJSON(message: VoteSigResponse): unknown {
    const obj: any = {};
    if (message.log !== "") {
      obj.log = message.log;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VoteSigResponse>, I>>(base?: I): VoteSigResponse {
    return VoteSigResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VoteSigResponse>, I>>(object: I): VoteSigResponse {
    const message = createBaseVoteSigResponse();
    message.log = object.log ?? "";
    return message;
  },
};

messageTypeRegistry.set(VoteSigResponse.$type, VoteSigResponse);

function createBaseHeartBeatRequest(): HeartBeatRequest {
  return {
    $type: "axelar.tss.v1beta1.HeartBeatRequest",
    senderDeprecated: Buffer.alloc(0),
    keyIds: [],
    sender: "",
  };
}

export const HeartBeatRequest = {
  $type: "axelar.tss.v1beta1.HeartBeatRequest" as const,

  encode(message: HeartBeatRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.senderDeprecated.length !== 0) {
      writer.uint32(10).bytes(message.senderDeprecated);
    }
    for (const v of message.keyIds) {
      writer.uint32(18).string(v!);
    }
    if (message.sender !== "") {
      writer.uint32(26).string(message.sender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HeartBeatRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartBeatRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.senderDeprecated = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.keyIds.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sender = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeartBeatRequest {
    return {
      $type: HeartBeatRequest.$type,
      senderDeprecated: isSet(object.senderDeprecated)
        ? Buffer.from(bytesFromBase64(object.senderDeprecated))
        : Buffer.alloc(0),
      keyIds: gt.Array.isArray(object?.keyIds) ? object.keyIds.map((e: any) => gt.String(e)) : [],
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
    };
  },

  toJSON(message: HeartBeatRequest): unknown {
    const obj: any = {};
    if (message.senderDeprecated.length !== 0) {
      obj.senderDeprecated = base64FromBytes(message.senderDeprecated);
    }
    if (message.keyIds?.length) {
      obj.keyIds = message.keyIds;
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeartBeatRequest>, I>>(base?: I): HeartBeatRequest {
    return HeartBeatRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeartBeatRequest>, I>>(object: I): HeartBeatRequest {
    const message = createBaseHeartBeatRequest();
    message.senderDeprecated = object.senderDeprecated ?? Buffer.alloc(0);
    message.keyIds = object.keyIds?.map((e) => e) || [];
    message.sender = object.sender ?? "";
    return message;
  },
};

messageTypeRegistry.set(HeartBeatRequest.$type, HeartBeatRequest);

function createBaseHeartBeatResponse(): HeartBeatResponse {
  return { $type: "axelar.tss.v1beta1.HeartBeatResponse" };
}

export const HeartBeatResponse = {
  $type: "axelar.tss.v1beta1.HeartBeatResponse" as const,

  encode(_: HeartBeatResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HeartBeatResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartBeatResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): HeartBeatResponse {
    return { $type: HeartBeatResponse.$type };
  },

  toJSON(_: HeartBeatResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<HeartBeatResponse>, I>>(base?: I): HeartBeatResponse {
    return HeartBeatResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeartBeatResponse>, I>>(_: I): HeartBeatResponse {
    const message = createBaseHeartBeatResponse();
    return message;
  },
};

messageTypeRegistry.set(HeartBeatResponse.$type, HeartBeatResponse);

function createBaseRegisterExternalKeysRequest(): RegisterExternalKeysRequest {
  return {
    $type: "axelar.tss.v1beta1.RegisterExternalKeysRequest",
    senderDeprecated: Buffer.alloc(0),
    chain: "",
    externalKeys: [],
    sender: "",
  };
}

export const RegisterExternalKeysRequest = {
  $type: "axelar.tss.v1beta1.RegisterExternalKeysRequest" as const,

  encode(message: RegisterExternalKeysRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.senderDeprecated.length !== 0) {
      writer.uint32(10).bytes(message.senderDeprecated);
    }
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    for (const v of message.externalKeys) {
      RegisterExternalKeysRequest_ExternalKey.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.sender !== "") {
      writer.uint32(34).string(message.sender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RegisterExternalKeysRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterExternalKeysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.senderDeprecated = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.externalKeys.push(RegisterExternalKeysRequest_ExternalKey.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sender = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterExternalKeysRequest {
    return {
      $type: RegisterExternalKeysRequest.$type,
      senderDeprecated: isSet(object.senderDeprecated)
        ? Buffer.from(bytesFromBase64(object.senderDeprecated))
        : Buffer.alloc(0),
      chain: isSet(object.chain) ? gt.String(object.chain) : "",
      externalKeys: gt.Array.isArray(object?.externalKeys)
        ? object.externalKeys.map((e: any) => RegisterExternalKeysRequest_ExternalKey.fromJSON(e))
        : [],
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
    };
  },

  toJSON(message: RegisterExternalKeysRequest): unknown {
    const obj: any = {};
    if (message.senderDeprecated.length !== 0) {
      obj.senderDeprecated = base64FromBytes(message.senderDeprecated);
    }
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.externalKeys?.length) {
      obj.externalKeys = message.externalKeys.map((e) => RegisterExternalKeysRequest_ExternalKey.toJSON(e));
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterExternalKeysRequest>, I>>(
    base?: I,
  ): RegisterExternalKeysRequest {
    return RegisterExternalKeysRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterExternalKeysRequest>, I>>(
    object: I,
  ): RegisterExternalKeysRequest {
    const message = createBaseRegisterExternalKeysRequest();
    message.senderDeprecated = object.senderDeprecated ?? Buffer.alloc(0);
    message.chain = object.chain ?? "";
    message.externalKeys =
      object.externalKeys?.map((e) => RegisterExternalKeysRequest_ExternalKey.fromPartial(e)) || [];
    message.sender = object.sender ?? "";
    return message;
  },
};

messageTypeRegistry.set(RegisterExternalKeysRequest.$type, RegisterExternalKeysRequest);

function createBaseRegisterExternalKeysRequest_ExternalKey(): RegisterExternalKeysRequest_ExternalKey {
  return {
    $type: "axelar.tss.v1beta1.RegisterExternalKeysRequest.ExternalKey",
    id: "",
    pubKey: Buffer.alloc(0),
  };
}

export const RegisterExternalKeysRequest_ExternalKey = {
  $type: "axelar.tss.v1beta1.RegisterExternalKeysRequest.ExternalKey" as const,

  encode(
    message: RegisterExternalKeysRequest_ExternalKey,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.pubKey.length !== 0) {
      writer.uint32(18).bytes(message.pubKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RegisterExternalKeysRequest_ExternalKey {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterExternalKeysRequest_ExternalKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pubKey = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterExternalKeysRequest_ExternalKey {
    return {
      $type: RegisterExternalKeysRequest_ExternalKey.$type,
      id: isSet(object.id) ? gt.String(object.id) : "",
      pubKey: isSet(object.pubKey) ? Buffer.from(bytesFromBase64(object.pubKey)) : Buffer.alloc(0),
    };
  },

  toJSON(message: RegisterExternalKeysRequest_ExternalKey): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.pubKey.length !== 0) {
      obj.pubKey = base64FromBytes(message.pubKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterExternalKeysRequest_ExternalKey>, I>>(
    base?: I,
  ): RegisterExternalKeysRequest_ExternalKey {
    return RegisterExternalKeysRequest_ExternalKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterExternalKeysRequest_ExternalKey>, I>>(
    object: I,
  ): RegisterExternalKeysRequest_ExternalKey {
    const message = createBaseRegisterExternalKeysRequest_ExternalKey();
    message.id = object.id ?? "";
    message.pubKey = object.pubKey ?? Buffer.alloc(0);
    return message;
  },
};

messageTypeRegistry.set(
  RegisterExternalKeysRequest_ExternalKey.$type,
  RegisterExternalKeysRequest_ExternalKey,
);

function createBaseRegisterExternalKeysResponse(): RegisterExternalKeysResponse {
  return { $type: "axelar.tss.v1beta1.RegisterExternalKeysResponse" };
}

export const RegisterExternalKeysResponse = {
  $type: "axelar.tss.v1beta1.RegisterExternalKeysResponse" as const,

  encode(_: RegisterExternalKeysResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RegisterExternalKeysResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterExternalKeysResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RegisterExternalKeysResponse {
    return { $type: RegisterExternalKeysResponse.$type };
  },

  toJSON(_: RegisterExternalKeysResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterExternalKeysResponse>, I>>(
    base?: I,
  ): RegisterExternalKeysResponse {
    return RegisterExternalKeysResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterExternalKeysResponse>, I>>(
    _: I,
  ): RegisterExternalKeysResponse {
    const message = createBaseRegisterExternalKeysResponse();
    return message;
  },
};

messageTypeRegistry.set(RegisterExternalKeysResponse.$type, RegisterExternalKeysResponse);

function createBaseSubmitMultisigPubKeysRequest(): SubmitMultisigPubKeysRequest {
  return {
    $type: "axelar.tss.v1beta1.SubmitMultisigPubKeysRequest",
    senderDeprecated: Buffer.alloc(0),
    keyId: "",
    sigKeyPairs: [],
    sender: "",
  };
}

export const SubmitMultisigPubKeysRequest = {
  $type: "axelar.tss.v1beta1.SubmitMultisigPubKeysRequest" as const,

  encode(message: SubmitMultisigPubKeysRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.senderDeprecated.length !== 0) {
      writer.uint32(10).bytes(message.senderDeprecated);
    }
    if (message.keyId !== "") {
      writer.uint32(18).string(message.keyId);
    }
    for (const v of message.sigKeyPairs) {
      SigKeyPair.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.sender !== "") {
      writer.uint32(34).string(message.sender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubmitMultisigPubKeysRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitMultisigPubKeysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.senderDeprecated = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.keyId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sigKeyPairs.push(SigKeyPair.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sender = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitMultisigPubKeysRequest {
    return {
      $type: SubmitMultisigPubKeysRequest.$type,
      senderDeprecated: isSet(object.senderDeprecated)
        ? Buffer.from(bytesFromBase64(object.senderDeprecated))
        : Buffer.alloc(0),
      keyId: isSet(object.keyId) ? gt.String(object.keyId) : "",
      sigKeyPairs: gt.Array.isArray(object?.sigKeyPairs)
        ? object.sigKeyPairs.map((e: any) => SigKeyPair.fromJSON(e))
        : [],
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
    };
  },

  toJSON(message: SubmitMultisigPubKeysRequest): unknown {
    const obj: any = {};
    if (message.senderDeprecated.length !== 0) {
      obj.senderDeprecated = base64FromBytes(message.senderDeprecated);
    }
    if (message.keyId !== "") {
      obj.keyId = message.keyId;
    }
    if (message.sigKeyPairs?.length) {
      obj.sigKeyPairs = message.sigKeyPairs.map((e) => SigKeyPair.toJSON(e));
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitMultisigPubKeysRequest>, I>>(
    base?: I,
  ): SubmitMultisigPubKeysRequest {
    return SubmitMultisigPubKeysRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitMultisigPubKeysRequest>, I>>(
    object: I,
  ): SubmitMultisigPubKeysRequest {
    const message = createBaseSubmitMultisigPubKeysRequest();
    message.senderDeprecated = object.senderDeprecated ?? Buffer.alloc(0);
    message.keyId = object.keyId ?? "";
    message.sigKeyPairs = object.sigKeyPairs?.map((e) => SigKeyPair.fromPartial(e)) || [];
    message.sender = object.sender ?? "";
    return message;
  },
};

messageTypeRegistry.set(SubmitMultisigPubKeysRequest.$type, SubmitMultisigPubKeysRequest);

function createBaseSubmitMultisigPubKeysResponse(): SubmitMultisigPubKeysResponse {
  return { $type: "axelar.tss.v1beta1.SubmitMultisigPubKeysResponse" };
}

export const SubmitMultisigPubKeysResponse = {
  $type: "axelar.tss.v1beta1.SubmitMultisigPubKeysResponse" as const,

  encode(_: SubmitMultisigPubKeysResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubmitMultisigPubKeysResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitMultisigPubKeysResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SubmitMultisigPubKeysResponse {
    return { $type: SubmitMultisigPubKeysResponse.$type };
  },

  toJSON(_: SubmitMultisigPubKeysResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitMultisigPubKeysResponse>, I>>(
    base?: I,
  ): SubmitMultisigPubKeysResponse {
    return SubmitMultisigPubKeysResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitMultisigPubKeysResponse>, I>>(
    _: I,
  ): SubmitMultisigPubKeysResponse {
    const message = createBaseSubmitMultisigPubKeysResponse();
    return message;
  },
};

messageTypeRegistry.set(SubmitMultisigPubKeysResponse.$type, SubmitMultisigPubKeysResponse);

function createBaseSubmitMultisigSignaturesRequest(): SubmitMultisigSignaturesRequest {
  return {
    $type: "axelar.tss.v1beta1.SubmitMultisigSignaturesRequest",
    senderDeprecated: Buffer.alloc(0),
    sigId: "",
    signatures: [],
    sender: "",
  };
}

export const SubmitMultisigSignaturesRequest = {
  $type: "axelar.tss.v1beta1.SubmitMultisigSignaturesRequest" as const,

  encode(message: SubmitMultisigSignaturesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.senderDeprecated.length !== 0) {
      writer.uint32(10).bytes(message.senderDeprecated);
    }
    if (message.sigId !== "") {
      writer.uint32(18).string(message.sigId);
    }
    for (const v of message.signatures) {
      writer.uint32(26).bytes(v!);
    }
    if (message.sender !== "") {
      writer.uint32(34).string(message.sender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubmitMultisigSignaturesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitMultisigSignaturesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.senderDeprecated = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sigId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.signatures.push(reader.bytes() as Buffer);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sender = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitMultisigSignaturesRequest {
    return {
      $type: SubmitMultisigSignaturesRequest.$type,
      senderDeprecated: isSet(object.senderDeprecated)
        ? Buffer.from(bytesFromBase64(object.senderDeprecated))
        : Buffer.alloc(0),
      sigId: isSet(object.sigId) ? gt.String(object.sigId) : "",
      signatures: gt.Array.isArray(object?.signatures)
        ? object.signatures.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
      sender: isSet(object.sender) ? gt.String(object.sender) : "",
    };
  },

  toJSON(message: SubmitMultisigSignaturesRequest): unknown {
    const obj: any = {};
    if (message.senderDeprecated.length !== 0) {
      obj.senderDeprecated = base64FromBytes(message.senderDeprecated);
    }
    if (message.sigId !== "") {
      obj.sigId = message.sigId;
    }
    if (message.signatures?.length) {
      obj.signatures = message.signatures.map((e) => base64FromBytes(e));
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitMultisigSignaturesRequest>, I>>(
    base?: I,
  ): SubmitMultisigSignaturesRequest {
    return SubmitMultisigSignaturesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitMultisigSignaturesRequest>, I>>(
    object: I,
  ): SubmitMultisigSignaturesRequest {
    const message = createBaseSubmitMultisigSignaturesRequest();
    message.senderDeprecated = object.senderDeprecated ?? Buffer.alloc(0);
    message.sigId = object.sigId ?? "";
    message.signatures = object.signatures?.map((e) => e) || [];
    message.sender = object.sender ?? "";
    return message;
  },
};

messageTypeRegistry.set(SubmitMultisigSignaturesRequest.$type, SubmitMultisigSignaturesRequest);

function createBaseSubmitMultisigSignaturesResponse(): SubmitMultisigSignaturesResponse {
  return { $type: "axelar.tss.v1beta1.SubmitMultisigSignaturesResponse" };
}

export const SubmitMultisigSignaturesResponse = {
  $type: "axelar.tss.v1beta1.SubmitMultisigSignaturesResponse" as const,

  encode(_: SubmitMultisigSignaturesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubmitMultisigSignaturesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitMultisigSignaturesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SubmitMultisigSignaturesResponse {
    return { $type: SubmitMultisigSignaturesResponse.$type };
  },

  toJSON(_: SubmitMultisigSignaturesResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitMultisigSignaturesResponse>, I>>(
    base?: I,
  ): SubmitMultisigSignaturesResponse {
    return SubmitMultisigSignaturesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitMultisigSignaturesResponse>, I>>(
    _: I,
  ): SubmitMultisigSignaturesResponse {
    const message = createBaseSubmitMultisigSignaturesResponse();
    return message;
  },
};

messageTypeRegistry.set(SubmitMultisigSignaturesResponse.$type, SubmitMultisigSignaturesResponse);

function createBaseUpdateParamsRequest(): UpdateParamsRequest {
  return { $type: "axelar.tss.v1beta1.UpdateParamsRequest", authority: "", params: undefined };
}

export const UpdateParamsRequest = {
  $type: "axelar.tss.v1beta1.UpdateParamsRequest" as const,

  encode(message: UpdateParamsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateParamsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateParamsRequest {
    return {
      $type: UpdateParamsRequest.$type,
      authority: isSet(object.authority) ? gt.String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: UpdateParamsRequest): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateParamsRequest>, I>>(base?: I): UpdateParamsRequest {
    return UpdateParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateParamsRequest>, I>>(object: I): UpdateParamsRequest {
    const message = createBaseUpdateParamsRequest();
    message.authority = object.authority ?? "";
    message.params =
      object.params !== undefined && object.params !== null ? Params.fromPartial(object.params) : undefined;
    return message;
  },
};

messageTypeRegistry.set(UpdateParamsRequest.$type, UpdateParamsRequest);

function createBaseUpdateParamsResponse(): UpdateParamsResponse {
  return { $type: "axelar.tss.v1beta1.UpdateParamsResponse" };
}

export const UpdateParamsResponse = {
  $type: "axelar.tss.v1beta1.UpdateParamsResponse" as const,

  encode(_: UpdateParamsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateParamsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpdateParamsResponse {
    return { $type: UpdateParamsResponse.$type };
  },

  toJSON(_: UpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateParamsResponse>, I>>(base?: I): UpdateParamsResponse {
    return UpdateParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateParamsResponse>, I>>(_: I): UpdateParamsResponse {
    const message = createBaseUpdateParamsResponse();
    return message;
  },
};

messageTypeRegistry.set(UpdateParamsResponse.$type, UpdateParamsResponse);

declare const self: any | undefined;
declare const window: any | undefined;
declare const global: any | undefined;
const gt: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(gt.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return gt.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Long
  ? string | number | Long
  : T extends globalThis.Array<infer U>
  ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends {}
  ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
